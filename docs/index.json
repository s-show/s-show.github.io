[{"categories":null,"content":"前置き Raspberry Pi に Klipper と FluiddPi をインストールして色々と設定を行っていますが、万が一の事態に備えて、RClone を使って設定ファイルをクラウドストレージに定期的にバックアップするようにしまし た。\nそこで、備忘録として実施した手順をメモします。\n手順 RClone のインストール  ホストPCから Raspberry Pi に SSH 接続する sudo ls を実行して root ユーザのパスワードを入力しておく curl https://rclone.org/install.sh | sudo bash でインストール用スクリプトをダウンロードして実行する  RClone の設定 RClone をインストールしたら、rclone config を実行して設定ダイアログを起動します。\nなお、ここでは過去に行った設定（ Fuliddpi_backup ）が表示されています。\n1Current remotes: 2 3Name Type 4==== ==== 5Fluiddpi_backup drive ← 過去に行った設定 6 7e) Edit existing remote 8n) New remote 9d) Delete remote 10r) Rename remote 11c) Copy remote 12s) Set configuration password 13q) Quit config 14e/n/d/r/c/s/q\u0026gt; n n を選択して新しい設定を開始します。\n1name\u0026gt; test 設定の名前を入力します。名前は任意のものを設定します。\n1Option Storage. 2Type of storage to configure. 3Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 4Choose a number from below, or type in your own value. 5 1 / 1Fichier 6 \\ \u0026#34;fichier\u0026#34; 7 2 / Alias for an existing remote 8 \\ \u0026#34;alias\u0026#34; 9 3 / Amazon Drive 10 \\ \u0026#34;amazon cloud drive\u0026#34; 11 4 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, SeaweedFS, and Tencent COS 12 \\ \u0026#34;s3\u0026#34; 13 5 / Backblaze B2 14 \\ \u0026#34;b2\u0026#34; 15 6 / Better checksums for other remotes 16 \\ \u0026#34;hasher\u0026#34; 17 7 / Box 18 \\ \u0026#34;box\u0026#34; 19 8 / Cache a remote 20 \\ \u0026#34;cache\u0026#34; 21 9 / Citrix Sharefile 22 \\ \u0026#34;sharefile\u0026#34; 2310 / Compress a remote 24 \\ \u0026#34;compress\u0026#34; 2511 / Dropbox 26 \\ \u0026#34;dropbox\u0026#34; 2712 / Encrypt/Decrypt a remote 28 \\ \u0026#34;crypt\u0026#34; 2913 / Enterprise File Fabric 30 \\ \u0026#34;filefabric\u0026#34; 3114 / FTP Connection 32 \\ \u0026#34;ftp\u0026#34; 3315 / Google Cloud Storage (this is not Google Drive) 34 \\ \u0026#34;google cloud storage\u0026#34; 3516 / Google Drive 36 \\ \u0026#34;drive\u0026#34; 3717 / Google Photos 38 \\ \u0026#34;google photos\u0026#34; 3918 / Hadoop distributed file system 40 \\ \u0026#34;hdfs\u0026#34; 4119 / Hubic 42 \\ \u0026#34;hubic\u0026#34; 4320 / In memory object storage system. 44 \\ \u0026#34;memory\u0026#34; 4521 / Jottacloud 46 \\ \u0026#34;jottacloud\u0026#34; 4722 / Koofr 48 \\ \u0026#34;koofr\u0026#34; 4923 / Local Disk 50 \\ \u0026#34;local\u0026#34; 5124 / Mail.ru Cloud 52 \\ \u0026#34;mailru\u0026#34; 5325 / Mega 54 \\ \u0026#34;mega\u0026#34; 5526 / Microsoft Azure Blob Storage 56 \\ \u0026#34;azureblob\u0026#34; 5727 / Microsoft OneDrive 58 \\ \u0026#34;onedrive\u0026#34; 5928 / OpenDrive 60 \\ \u0026#34;opendrive\u0026#34; 6129 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH) 62 \\ \u0026#34;swift\u0026#34; 6330 / Pcloud 64 \\ \u0026#34;pcloud\u0026#34; 6531 / Put.io 66 \\ \u0026#34;putio\u0026#34; 6732 / QingCloud Object Storage 68 \\ \u0026#34;qingstor\u0026#34; 6933 / SSH/SFTP Connection 70 \\ \u0026#34;sftp\u0026#34; 7134 / Sia Decentralized Cloud 72 \\ \u0026#34;sia\u0026#34; 7335 / Sugarsync 74 \\ \u0026#34;sugarsync\u0026#34; 7536 / Tardigrade Decentralized Cloud Storage 76 \\ \u0026#34;tardigrade\u0026#34; 7737 / Transparently chunk/split large files 78 \\ \u0026#34;chunker\u0026#34; 7938 / Union merges the contents of several upstream fs 80 \\ \u0026#34;union\u0026#34; 8139 / Uptobox 82 \\ \u0026#34;uptobox\u0026#34; 8340 / Webdav 84 \\ \u0026#34;webdav\u0026#34; 8541 / Yandex Disk 86 \\ \u0026#34;yandex\u0026#34; 8742 / Zoho 88 \\ \u0026#34;zoho\u0026#34; 8943 / http Connection 90 \\ \u0026#34;http\u0026#34; 9144 / premiumize.me 92 \\ \u0026#34;premiumizeme\u0026#34; 9345 / seafile 94 \\ \u0026#34;seafile\u0026#34; 95Storage\u0026gt; 16 利用するオンラインストレージを聞かれるので、利用したいものを選択します。今回は Google Drive を使うので、 16 を選択しています。\n1Option client_id. 2Google Application Client Id 3Setting your own is recommended. 4See https://rclone.org/drive/#making-your-own-client-id for how to create your own. 5If you leave this blank, it will use an internal key which is low performance. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7client_id\u0026gt; 8Option client_secret. 9OAuth Client Secret. 10Leave blank normally. 11Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 12client_secret\u0026gt; client_id と client_secret を聞かれますが、空欄でOKです。\n1Option scope. 2Scope that rclone should use when requesting access from drive. 3Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 4Choose a number from below, or type in your own value. 5 1 / Full access all files, excluding Application Data Folder. 6 \\ \u0026#34;drive\u0026#34; 7 2 / Read-only access to file metadata and file contents. 8 \\ \u0026#34;drive.readonly\u0026#34; 9 / Access to files created by rclone only. 10 3 | These are visible in the drive website. 11 | File authorization is revoked when the user deauthorizes the app. 12 \\ \u0026#34;drive.file\u0026#34; 13 / Allows read and write access to the Application Data folder. 14 4 | This is not visible in the drive website. 15 \\ \u0026#34;drive.appfolder\u0026#34; 16 / Allows read-only access to file metadata but 17 5 | does not allow any access to read or download file content. 18 \\ \u0026#34;drive.metadata.readonly\u0026#34; 19scope\u0026gt; 1 どのスコープ範囲を適用するか聞かれるので、フルアクセス可能な 1 を選択します。\n（書き込みオンリーの権限がないため、止むを得ずフルアクセスを選択しています。）\n1Option root_folder_id. 2ID of the root folder. 3Leave blank normally. 4Fill in to access \u0026#34;Computers\u0026#34; folders (see docs), or for rclone to use 5a non root folder as its starting point. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7root_folder_id\u0026gt; root_folder_id を聞かれますが、空欄のままでOKです。\n1Option service_account_file. 2Service Account Credentials JSON file path. 3Leave blank normally. 4Needed only if you want use SA instead of interactive login. 5Leading `~` will be expanded in the file name as will environment variables such as `${RCLONE_CONFIG_DIR}`. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7service_account_file\u0026gt; service_account_file について聞かれますが、こちらも空欄でOKです。\n1Edit advanced config? 2y) Yes 3n) No (default) 4y/n\u0026gt; n アドバンスト設定を行うか聞かれますので、 n を入力してアドバンスト設定を行わず先に進みます。\n1Use auto config? 2 * Say Y if not sure 3 * Say N if you are working on a remote or headless machine 4 5y) Yes (default) 6n) No 7y/n\u0026gt; n オート設定を行うか聞かれますが、SSH 接続で設定しているので n を選択します。\n1Option config_verification_code. 2Verification code 3Go to this URL, authenticate then paste the code here. 4https://accounts.google.com/o/oauth2/auth?... 5Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 6config_verification_code\u0026gt; *** https://~~ の URL をブラウザで開いて RClone に権限を与えます。\nそうするとアクセス用のコードが表示されるので、 config_verification_code のところに貼り付けます。\n使用するアカウントを選択  アクセスを許可  RClone で使うコードをコピー \n1Configure this as a Shared Drive (Team Drive)? 2 3y) Yes 4n) No (default) 5y/n\u0026gt; n 今回使う Google Drive がチームで使うものか聞かれますが、私の Google Drive は個人用なので n を選択します。\n1-------------------- 2[test] 3type = drive 4scope = drive 5token = {\u0026#34;access_token\u0026#34;:\u0026#34;***\u0026#34;,...} 6team_drive = 7-------------------- 8y) Yes this is OK (default) 9e) Edit this remote 10d) Delete this remote 11y/e/d\u0026gt; y これまでの選択に基づいた設定結果が表示されますので、問題がなれば y を選択します。\n1Current remotes: 2 3Name Type 4==== ==== 5Fluiddpi_backup drive 6test drive 7 8e) Edit existing remote 9n) New remote 10d) Delete remote 11r) Rename remote 12c) Copy remote 13s) Set configuration password 14q) Quit config 15e/n/d/r/c/s/q\u0026gt; 設定完了後のリモートドライブの一覧が表示されます。\n設定が上手くできたか確認するため、 rclone ls Fluiddpi_backup: を実行してリモートドライブの内容が表示されるか確認します。きちんと設定できていれば、Google Drive に保存しているファイルがリストアップされます。\n1pi@fluiddpiender3:~ $ rclone ls Fluiddpi_backup: 2 10138 FluiddPi_Prusa/klipper_config/printer.cfg 3 10138 FluiddPi_Prusa/klipper_config/printer-20220110_020804.cfg 4 10152 FluiddPi_Prusa/klipper_config/printer-20220110_020020.cfg 5 ... 続いて、Cron で定期的に実行するバックアップスクリプトを作成します。スクリプトは ~/klipper_backup.sh としました。\nなお、バックアップ先の Google Drive には、あらかじめ FluiddPi_Ender3 という名前でディレクトリを作成しています。\n1#!/bin/bash 2rclone copy klipper_config/ Fluiddpi_backup:FluiddPi_Ender3/klipper_config 3rclone copy -L klipper_logs/ Fluiddpi_backup:FluiddPi_Ender3/klipper_logs スクリプトを作成したら、 chmod 777 ~/klipper_backup.sh コマンドでスクリプトに実行権限を与えます。\nそれから crontab -e で Cron の設定ファイルを開き、バックアップスクリプトを実行する日時を設定します。ここでは、毎日夜中の2時15分にバックアップを実行する設定にしています。\n1# Edit this file to introduce tasks to be run by cron. 2# 3# Each task to run has to be defined through a single line 4# indicating with different fields when the task will be run 5# and what command to run for the task 6# 7# To define the time you can provide concrete values for 8# minute (m), hour (h), day of month (dom), month (mon), 9# and day of week (dow) or use \u0026#39;*\u0026#39; in these fields (for \u0026#39;any\u0026#39;). 10# 11# Notice that tasks will be started based on the cron\u0026#39;s system 12# daemon\u0026#39;s notion of time and timezones. 13# 14# Output of the crontab jobs (including errors) is sent through 15# email to the user the crontab file belongs to (unless redirected). 16# 17# For example, you can run a backup of all your user accounts 18# at 5 a.m every week with: 19# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ 20# 21# For more information see the manual pages of crontab(5) and cron(8) 22# 23# m h dom mon dow command 2415 2 * * * /home/pi/klipper_backup.sh 以上で設定完了です。これで毎日同じ時間にバックアップが実行されます。\n","date":"2022-01-16","img":"","permalink":"https://s-show.github.io/posts/2022-01-16/","series":null,"tags":null,"title":"RClone を使って Klipper の設定をバックアップする方法"},{"categories":null,"content":"3D プリンタで新しいフィラメントを使う場合、最適な温度やリトラクト長を探し出す必要がありますが、「プリント→結果を確認→設定変更→プリント」という順番で調査すると時間がいくらあっても足りません。そのため、1回のプリントで様々な設定を試せると便利ということになります。\n幸い、スライサー側の機能を使うことで、レイヤー高に応じて設定を変更することが可能となりますので、その方法を紹介します。\nなお、スライサーによって設定方法だけでなくできることも違いますので、スライサー毎に説明します。ただし、結論を先取りしますと、PrusaSlicer/SuperSlicer よりも Cura の方が設定が簡単な上に出来ることも多いので、こういう処理を行う場合は Cura を使うか、G-Code を生成してくれるサービスを利用することをお勧めします。\nCura の場合 まず、一度スライスしてからプレビュー画面に移動し、設定を変更するレイヤーの番号をメモします。ここでは45・90番目のレイヤーで温度を変更し、50番目のレイヤーでリトラクション長を変更するという前提とします。\nまず、Cura のメニューの 「Extensions ｰ\u0026gt; Post Processing ｰ\u0026gt; Modify G-Code」を開きます。\nそれから、Add a script ボタンをクリックして「ChangeAtZ」を追加して Trigger を layer No. にして、Change Layer に設定を変更したいレイヤーの番号を指定します。そして、Apply To を Target Layer + Subsequent Layersにします。これで layer No. より上のレイヤーでは変更した設定が適用されるようになります。\n例えば、最初は250度で印刷し、45番目のレイヤーから上は245度で印刷したいというときは Change Extruder 1 Temp にチェックを入れた上で、Extruder 1 temp に 245 を入力します。\n45番目のレイヤーから上の温度を240度に変更  また、最初はリトラクション長を 1mm で印刷し、50番目のレイヤーから上ではリトラクション長を 2mm にしたいというときは、Change Retraction にチェックを入れてから、Change Retraction Length にもチェックを入れ、Retract Length に 2 を入力します。\nリトラクション長を2mmに変更  あとは、必要な分だけこの設定を繰り返します。\n90番目のレイヤーから上の温度を230度に変更  PrusaSlicer/SuperSlicer の場合 PrusaSlicer/SuperSlicer の場合、温度設定は変更できますが、リトラクション長の変更方法は見つけられていません。\n一応、リトラクション長を変えつつ一度のプリントで9つのモデルを印刷するという方法はあるようですが、思わぬ失敗で時間を無駄にしそうなので挑戦していません。\n温度設定を変更する方法は、一度スライスしてからプレビュー画面に移動し、右側のスクロールバーを設定を変更するレイヤーに合わせます。\nそれから、そのレイヤーで右クリックして「カスタムG-Codeの追加」をクリックします。\nカスタムG-Codeの追加  カスタムG-Codeの追加（拡大） \nするとカスタム G-Code の入力画面が開きますので、以下のコードを追加します。なお、コードは上から順番に実行されるようです。\nM106 S0; M104 S240; M109 S240; M106 S255  M106 S0 パーツ冷却ファンをストップさせるコマンドです。これがないと、エクストルーダーの温度が設定温度になるまでの間、同じ個所を冷やし続けることになります。 M104 S240 エクストルーダーの温度が240度に設定するコマンドです。設定温度に到達する前に次のコマンドに移ります。 M109 S240 エクストルーダーの温度が240度になるまで待機するというコマンドです M106 S255 パーツ冷却ファンの回転数を元に戻す（ここでは全開にする前提）コマンドです。これがないと、パーツ冷却ファンがストップしたままとなります。  以上で PlusaSlicer/SuperSlicer を使ってレイヤー高に応じて設定を変える方法を紹介しましたが、正直な所、Cura と比較して明らかに面倒になります。\nなので、もっと楽をする方法を紹介します。\nウェブページで G-Code を生成する方法 YouTube で3Dプリンタの情報を中心に色々な解説動画を出している Teaching Tech が 3Dプリンタのキャリブレーションテクニックなどをまとめたページを作成しています。\nTeaching Tech 3D Printer Calibration こちらでは温度調整やリトラクト長の調整のための G-Code を生成することが出来ますので、こちらで G-Code を生成して印刷するとスライサーの設定をしなくても必要な G-Code が作れます。\nまとめ 新しいフィラメントを使う場合、温度設定やリトラクション長などは試行錯誤して最適値を割り出す必要がありますので、上記の方法を利用すると最適値の探索が少し楽になります。\n一度最適値を割り出してしまえば、その設定値はずっと使えますので、上記の方法が何かの役に立てば幸いです。\n","date":"2022-01-07","img":"","permalink":"https://s-show.github.io/posts/2022-01-07/","series":null,"tags":["3Dプリンタ","備忘録"],"title":"PrusaSlicer/SuperSlicer で 一定のレイヤー毎に温度を変化させる方法"},{"categories":null,"content":"目次  前置き 作業の順番 FluiddPi のインストール Kiuah のインストール Klipper ファームウェアのビルド \u0026amp; インストール Klipper の設定  移動距離の調整 PID チューニング Pressure advance の調整 コマンドでファームウェアを再起動 Input Shaper スライサーと FluiddPi を繋ぐ方法 G-Code の問題 position_min の設定 BLTouch の使い方 プローブの Z-Offset の調整 Mesh Bed Leveling のトラブル その他のエラー対策 printer.cfg 等の設定ファイルの保存場所       前置き 我が家の3Dプリンタのファームウェアを Marlin から Klipper に変更し、あわせてプリンタ操作ツールを OctoPrint から FluiddPi に変更しましたので、インストール方法などをメモしておきます。\n順不同であれこれ書いていますので、必要に応じて上の目次を利用してください。\n作業の順番 作業は次の順番で行います。\n FluiddPi をRaspberryPi にインストール 1.の RaspberryPi に Kiuah をインストール Kiuah を使って Klipper をインストール Klipper を設定  FluiddPi のインストール FluiddPI - Fluidd からイメージファイルをダウンロードし、Raspberry Pi Imager を使って MicroSD カードにイメージファイルを書き込みます。\nイメージを書き込んだら、MicroSD カードの fluiddpi-wpa-supplicant.txt ファイルを開いて無線LANの設定を行います。それからカードを RaspberryPi に差し込んで起動します。\nRaspberryPi が起動してしばらくしたら、作業用PCで ssh pi@fluiddpi.local コマンドを実行して RaspberryPi に SSH 接続し、sudo raspi-config を実行して次の設定を行います。\n System Options -\u0026gt; Password でパスワードを変更します Localization Options -\u0026gt; Timezone でタイムゾーンを変更します Localization Options -\u0026gt; Locale でローカル設定を変更します 必要に応じて System Options -\u0026gt; Hostname でホスト名を変更します  http://fluidd.local にアクセスして FluiddPi の画面が表示されることを確認します。\nFluiddPi の画面が表示されたら、ひとまずカメラの設定を行います。\n私は Logitech の C270 カメラを利用していますので、左の Configuration タブにある webcam.txt ファイルを開いて camera_usb_options をアンコメントします。画面解像度は、FluiddPi の中の小さな画面で見ますので 640x480 とし、フレームレートを 30 にしています。\nそれから Settings の Cameras でカメラを追加します。Stream type は MJPEG Adaptive にします。\nKiuah のインストール Klipper のビルドや各種アップデートを簡単に行うため、Kiuah をインストールします。インストールは以下のコマンドで行います。\n1cd ~ 2git clone https://github.com/th33xitus/kiauh.git Klipper ファームウェアのビルド \u0026amp; インストール Kiuah をインストールしたら、./kiauh/kiauh.sh を実行し、4) [Advanced] を選択してメニューを開きます。\n/=======================================================\\ | ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | | Klipper Installation And Update Helper | | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | \\=======================================================/ /=======================================================\\ | ~~~~~~~~~~~~~~~ [ Main Menu ] ~~~~~~~~~~~~~~~ | |-------------------------------------------------------| | 0) [Upload Log] | Klipper: Installed: 1 | | | Branch: master | | 1) [Install] | | | 2) [Update] | Moonraker: Installed: 1 | | 3) [Remove] | | | 4) [Advanced] | Mainsail: Not installed! | | 5) [Backup] | Fluidd: Installed! | | | KlipperScreen: Not installed! | | 6) [Settings] | Telegram Bot: Not installed! | | | | | | DWC2: Not installed! | | v3.1.0-85 | Octoprint: Not installed! | |-------------------------------------------------------| | Q) Quit | \\=======================================================/ Perform action: 4 メニューを開いたら、3) [Build only] を選択してファームウェアビルドのオプション画面に移ります。\n/=======================================================\\ | ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | | Klipper Installation And Update Helper | | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | \\=======================================================/ /=======================================================\\ | ~~~~~~~~~~~~~ [ Advanced Menu ] ~~~~~~~~~~~~~ | |-------------------------------------------------------| | Klipper: | Mainsail: | | 1) [Switch Branch] | 7) [Theme installer] | | 2) [Rollback] | | | | System: | | Firmware: | 8) [Change hostname] | | 3) [Build only] | | | 4) [Flash only] | Extensions: | | 5) [Build + Flash] | 9) [Shell Command] | | 6) [Get MCU ID] | | | | CustomPiOS: | | | 10) [Migration Helper] | |-------------------------------------------------------| | B) « Back | \\=======================================================/ Perform action: 3 ファームウェアビルドのオプション画面が開きますので、必要な設定を行って保存するとファームウェアがビルドされて ~/klipper/out/klipper.elf に保存されます。\nあとは、作業用 PC で scp pi@fluiddpi.local:~/klipper/out/klipper.bin ~/ を実行してファームウェアをダウンロードし、プリンタに書き込みます。\nKlipper の設定 Klipper の設定は、~/klipper_config/printer.cfg を編集して行います。\nFliddpi をインストールした RaspberryPi の ~/klipper/config/ ディレクトリには主要なマザーボードの設定例が保存されていますので、自分に合ったものを cp ~/klipper/config/generic-einsy-rambo.cfg ~/klipper_config/printer.cfg でコピーして編集していきます。なお、FluiddPi の Configuration タブの Other Files の CONFIG_EXAMPLES からも同じ設定例にアクセスできます。\nなお、Prusa MK3S+ については、Klipper の Github のプルリク に「Prusa i3 MK3S に合わせた printer.cfg を作成したので config/printer-prusa-mk3s-2021.cfg として追加して欲しい」とがありましたので、これを元に設定していきました。\n移動距離の調整 Marlin では「プリンタを 1mm 動かすのにステッピングモーターを何ステップ動かすか」を設定する steps_per_mm でプリントヘッドやベッドの移動距離を調整していましたが、Klipper では「ステッピングモーターが完全に1回転したときに軸方向に動く距離」を設定する rotation_distance で調整します。\n klipper/Rotation_Distance.md at master · Klipper3d/klipper  Klipper is a 3d-printer firmware. Contribute to Klipper3d/klipper development by creating an account …\n   \u0026#x2139; 以前は `step_distance` という項目で調整されていましたが、2021年11月2日の変更でこの項目は使えなくなっています。  rotation_distance を求める方法は次の4つですが、上記で説明した printer.cfg の見本には標準的な値が設定されていますので、そちらを用いて微調整する方が早いと思います。\nrotation_distance の値はプリンタの部品で決まるため、printer.cfg の見本がない場合、同じ部品を使っているプリンタの値を流用すれば大丈夫だと思います。\n ベルトのピッチとプーリーの歯の数から求める方法 (XY 軸) リードスクリューのピッチとスレッド数から求める方法 (Z 軸) エクストルーダーのホブボルトの直径から求める方法 (エクストルーダー) step_distance から求める方法 (古い設定例を用いる場合)  調整方法の具体的な内容 ベルトのピッチとプーリーの歯の数から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\nrotation_distance = ベルトのピッチ数 * プーリーの歯の数 （筆者翻訳） 2mmピッチのベルトと20歯のプーリーを使っていれば 2 * 20 = 40 となります。\nリードスクリューのピッチとスレッド数から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\nrotation_distance = ピッチ数 * スレッド数 （筆者翻訳） 3Dプリンタで良く使われる T8 リードスクリューの場合、ピッチ数が 2 でスレッド数が 4 なので、2 * 4 = 8 となります。\nエクストルーダーのホブボルトの直径から求める方法 ホブボルトとは、次の写真のような溝付きボルトのことのようです。このボルトの直径を公式リファレンスに掲載されている計算式に代入して求めます。\nrotation_distance = \u0026lt;diameter\u0026gt; * 3.14 ただ、エクストルーダーの場合、後述の「rotation_distance の調整」に沿って調整する方が手っ取り早いと思います。\nstep_distance から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\nrotation_distance = \u0026lt;full_steps_per_rotation\u0026gt; * \u0026lt;microsteps\u0026gt; * \u0026lt;step_distance\u0026gt;  full_steps_per_rotation ステッピングモーターが一回転するためのステップ数です。モーターの最小回転角が 1.8度なら 200 に、0.9度なら 400 になります。  私の Prusa で使用中のモーターは全て最小回転角が1.8度なので、200 を代入します。\n microsteps モータードライバーのマイクロステッピング機能です。大抵の場合 1/16 なので 16 を代入します。Prusa の TMC2130 も 1/16 です（実際は補間機能で 1/256 になっています）。  TMC2130 のマイクロステッピングは、Trinamic が公表しているデータシート の86ページで確認できます。\nギア比の設定 エクストルーダーなどにギアボックス (BMG Extruder 等) を使っている場合、歯車の歯の数の比に応じて gear_ratio: 50:17 のように設定します。\n注意点は、商品説明で「3:1」のギア比と紹介されていても、歯車の数は「50:17」となっていたりしますので、設定値は歯車の歯の数に基づく必要があります。\nrotation_distance の調整 エクストルーダーの rotation_distance の値の調整は、100ミリ押し出した時に何ミリ押し出されたか確認し、その値を元に 実際に押し出された距離 / 100mm * 現在の設定値 を計算して行います。\nXYZ 軸については、XYZ 20mm Calibration Cube by iDig3Dprinting - Thingiverse を印刷して XYZ 方向の実測値を元に 実測値 / 20mm * 現在の設定値 を計算して調整します。\nなお、’rotation_distance は、steps_per_mm` とは違い、値が小さくなるほど移動量が増えることに注意が必要です。\nPID チューニング エクストルーダーのチューニングは PID_CALIBRATE HEATER=extruder TARGET=170 コマンドで行います。コマンドを実行して結果が出たら、SAVE_CONFIG コマンドを実行してチューニング結果を printer.cfg に保存します。ベッドのチューニングは PID_CALIBRATE HEATER=heater_bed TARGET=60 コマンドで同様に行います。\nPressure advance の調整 Pressure advance は、Marlin の Linear_advance に相当する機能です。\n調整方法は Klipper の公式リファレンス に掲載されていますが、簡単に言うと、プリンタの設定を一時的に変更してからテスト印刷し、その結果から設定値を計算して printer.cfg に設定するというものです。\nまず、SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 コマンドを実行してコーナーの速度を落とします。速度を落とす理由は、コーナーでエクストルーダーの押し出し効果を強調するためです。\n次に、TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 を実行して、1レイヤー毎に PRESSURE_ADVANCE のパラメータを 0 から 0.005 ずつ増やしていきます。なお、ボーデン型のプリンタを使っている場合、FACTOR=.005 を FACTOR=.020 にします。\nそれから square_tower.stl を次の設定で印刷します。\n レイヤーの高さ ノズルの直径の 75% とするよう指示されていますので、0.4mm ノズルなら 0.3mm とします。 速度 100mm/s のような高速にし、スライサーの加速度コントロール機能は無効にします。 インフィル 0% にします。 トップレイヤー 不要なので 0 とします。  印刷が終わったら、底面からコーナーの造形がダメになる部分までの高さを測り、次の式で PRESSURE_ADVANCE のパラメータを求めます。なお、この印刷は「上のレイヤーほどコーナーの造形がダメになる」ので、コーナーの造形がダメになった時点で印刷を中止すると時間の節約になります。\n底面から造形がダメになる部分までの高さを計測 Klipper documentation Pressure advance より   pressure_advance = \u0026lt;start\u0026gt; + \u0026lt;measured_height\u0026gt; * \u0026lt;factor\u0026gt;. (For example, 0 + 12.40 * 0.005 would be 0.062.) なお、PRESSURE_ADVANCE のパラメータは、温度やフィラメントによって異なりますので、その都度調べる必要があります。\n The pressure advance value is dependent on the extruder, the nozzle, and the filament. It is common for filament from different manufactures or with different pigments to require significantly different pressure advance values. Therefore, one should calibrate pressure advance on each printer and with each spool of filament.\nPRESSURE_ADVANCE の値は、エクストルーダー、ノズルまたはフィラメントに依存します。メーカーや顔料が異なるフィラメントでは、PRESSURE_ADVANCE の値が大きく異なるのが一般的です。そのため、フィラメントスプール毎またはプリンター毎に PRESSURE_ADVANCE の値を調整するべきです。（拙訳）\nPressure advance - Klipper documentation より引用\n コマンドでファームウェアを再起動 次のコマンドでファームウェアを再起動できます。これで再起動できない場合、本体の電源を切ることになります。\n1curl -X POST fluiddpi.local/printer/firmware_restart Moonraker Docs » Client Developers » Client API Input Shaper Input Shaper とは、プリンタ自身の振動をキャンセルして印刷物の品質を向上させる機能で、Klipper オリジナルの機能です。大量の計算を必要とするため、現時点では RapberryPi をプリンタの MCU として使用する Klipper しか実現できない機能ではないかと思います。\n Input shaping is an open-loop control technique which creates a commanding signal that cancels its own vibrations.\nInput Shaping は、プリンタ自身の振動をキャンセルする制御信号を作成するオープンループの技術です。（拙訳）\n この機能を使うにはプリンタ特有の振動を調べる必要があり、調査方法は、手動＆目視で行う方法と加速度センサーを使う方法の2つがあります。最初は手動＆目視で調査を試みましたが、確認が難しかったため加速度センサーを使うことにしました。\n事前準備 Input Shaper の測定はハードとソフトの両方で事前準備が必要ですので、それぞれ説明します。\nハードの準備 まず、加速度センサーを入手する必要があります。使うセンサーは ADXL345 で、私は Amazon で販売されている HiLetgo のセンサーを使っています。\n  HiLetgo® 2個セット GY-291 ADXL345 3軸デジタル 加速度モジュール 重力 加速度 チルトセンサモジュール 傾斜センサモジュール 傾斜センサ [並行輸入品]  amazon.co.jp    このセンサーで XY 軸の振動をそれぞれ計測しますが、X 軸の計測ではセンサーをエクストルーダーに、Y 軸の計測ではセンサーをベッドに固定する必要があるため、センサーマウントを設計しました。\nADXL345 をプリントヘッドに取り付け  ADXL345 をベッドに取り付け \nこのセンサーと Raspberry Pi の接続は次のとおりです。ジャンパワイヤを1本ずつ繋ぐのは面倒なので、2x4 のコネクタと 1x4 のコネクタを作成して少しでも配線を楽にしました。\nKlipper documentation Measuring_Resonances.html#wiring より   ソフトの準備 RapberryPi で Input Shaper の計算を行うため、Python で数値計算を効率的に行うための拡張モジュールである numpy をインストールします。\nインストールは、SSH コマンドで Raspberry pi にログインしてから ~/klippy-env/bin/pip install -v numpy コマンドを実行して行います。インストールに時間がかかるのでしばし待機します。\nnumpy をインストールしたら、sudo apt update でパッケージを更新してから sudo apt install python-numpy python-matplotlib を実行して numpy が依存するライブラリをインストールします。\n次に RapberryPi の MCU を klipper のためのセカンダリ MCU として使うための設定を行います。\nまず、以下のコマンドを実行して、RapberryPi をセカンダリ MCU として使うためのスクリプトをデーモンに登録します。\ncd ~/klipper/ sudo cp \u0026quot;./scripts/klipper-mcu-start.sh\u0026quot; /etc/init.d/klipper_mcu sudo update-rc.d klipper_mcu defaults 次に sudo raspi-config を実行して Raspberry Pi の設定画面を開き、3 Interface Options -\u0026gt; P4 SPI と設定画面を開いて SPI 機能を有効化します。\nそれから次のコマンドを実行して Klipper のビルドオプション画面を開きます。ビルドオプションでは、Microcontroller Architecture を Linux process にして設定を保存します。\ncd ~/klipper/ make menuconfig そして、次のコマンドを実行してファームウェアのビルドと書き込みを行います。\nsudo service klipper stop make flash sudo service klipper start これで RapberryPi をセカンダリ MCU として使う準備が出来ましたので、printer.cfg に次の設定を追加します。\n[mcu rpi] serial: /tmp/klipper_host_mcu [adxl345] cs_pin: rpi:None [resonance_tester] accel_chip: adxl345 probe_points: 100,100,20 # an example 以上で事前準備は完了です。\n測定 センサーをプリンタに固定して RapberryPi に接続したら、FluiddPi から SHAPER_CALIBRATE AXIS=X コマンドを実行して計測と調整を行います。センサーの XYZ 軸の方向を計測したい方向に合わせます。測定が終わったら SAVE_CONFIG を実行して測定結果に基づく設定値を printer.cfg に保存します。\nADXL345 の測定向きを計測方向に合わせる  // 測定結果 [x-axis] 21:14:50 // Wait for calculations.. 21:14:51 // Calculating the best input shaper parameters for x axis 21:14:52 // Fitted shaper 'zv' frequency = 59.4 Hz (vibrations = 8.1%, smoothing ~= 0.050) 21:14:52 // To avoid too much smoothing with 'zv', suggested max_accel \u0026lt;= 13800 mm/sec^2 21:14:54 // Fitted shaper 'mzv' frequency = 54.0 Hz (vibrations = 0.2%, smoothing ~= 0.070) 21:14:54 // To avoid too much smoothing with 'mzv', suggested max_accel \u0026lt;= 8600 mm/sec^2 21:14:56 // Fitted shaper 'ei' frequency = 64.0 Hz (vibrations = 0.0%, smoothing ~= 0.079) 21:14:56 // To avoid too much smoothing with 'ei', suggested max_accel \u0026lt;= 7600 mm/sec^2 21:14:57 // Fitted shaper '2hump_ei' frequency = 79.8 Hz (vibrations = 0.0%, smoothing ~= 0.085) 21:14:57 // To avoid too much smoothing with '2hump_ei', suggested max_accel \u0026lt;= 7100 mm/sec^2 21:14:59 // Fitted shaper '3hump_ei' frequency = 95.8 Hz (vibrations = 0.0%, smoothing ~= 0.089) 21:14:59 // To avoid too much smoothing with '3hump_ei', suggested max_accel \u0026lt;= 6700 mm/sec^2 21:14:59 // Recommended shaper_type_x = mzv, shaper_freq_x = 54.0 Hz 21:14:59 // Shaper calibration data written to /tmp/calibration_data_x_20211229_211233.csv file 21:14:59 // The SAVE_CONFIG command will update the printer config file // with these parameters and restart the printer. なお、測定結果には加速度の上限値 (suggested max_accel \u0026lt;= 8600 mm/sec^2) も表示されていますが、加速度は SAVE_CONFIG コマンドでは保存されないため、手動で [printer] セクションの max_accel を修正します。\n[printer] max_accel: 4000 スライサーと FluiddPi を繋ぐ方法 Cura の場合 Settings → Printer → Manage Printers → Connect Octoprint → Add の順番で設定画面を開き、接続名称と IP アドレスを入力します。それから Connect ボタンをクリックしますと接続します（API Key は不要）。\nCura の設定画面  Cura の設定画面 \nPrusaSlicer / SuperSlicer の場合 右パネルのプリンタメニューの右側の歯車アイコンをクリックして “Add physical printer” を開き、ホスト名に fluiddpi.local (ホスト名を変更している場合は変更後のホスト名) を入力し、テストボタンをクリックします。API Key は入力不要です。\nPrusaSlicer/SuperSlicer の設定画面  G-Code の問題 Klipper 非対応の G-Code PrusaSlicer と SuperSlicer の Start G-code にある M862.3 と M862.1 は、Prusa のオリジナル G-Code なので、Klipper に読み込ませても Unknown command:\u0026quot;M862.3\u0026quot; となってしまいます。また、G29 と G80 も Klipper は対応していないので、マクロとして登録する必要があります。\n[gcode_macro G29] gcode: G28 BED_MESH_CALIBRATE [gcode_macro G80] gcode: BED_MESH_CALIBRATE G1 X0 Y0 Z0.4 F4000  G-code - RepRap - M862  G-code - RepRap - G29  G-code - RepRap - G80   Cura でスライスした場合の問題 Cura でスライスした場合、最初のノズル加熱の G-Code が M104 S210 � となり、プリンタがこのコードに到達した時点で停止してしまうという不具合に遭遇しました。\nPrusaSlicer や SuperSlicer では発生しないので、考えられる原因は、Cura がノズルの温度を小数点以下第1位 (ex: 220.0) まで指定できることではないかと思っています。\n手作業で修正すれば OK なのですが、面倒なので Ender 3 Pro で印刷するときは Cura ではなく SuperSlicer を使うようにしました。\nposition_min の設定 Ender 3 Pro のエクストルーダー改造により、ベッドを Y=0 の場所まで移動させるとノズルがベッドからはみ出してしまう状態になっています。\nノズルのはみ出し状況  この状態だと Y=0~20 の部分が印刷に使えないため、[stepper_y] セクションに次の設定を追加して、ノズル位置のオフセットを行っています。\n[stepper_y] position_endstop: -20 position_min: -20 BLTouch の使い方 マザーボードとの接続方法 SKR mini e3 V2.0 と BLTouch は、BIGTREETECH の Github に掲載されている次の写真のとおり接続します。\nhttps://github.com/bigtreetech/BIGTREETECH-SKR-mini-E3/blob/master/hardware/BTT SKR MINI E3 V2.0/Hardware/bltouch-2.0-1.jpg より   Github には、次の写真のように Z 軸のエンドストップに接続する方法も掲載されていますが、こちらでは上手くいきません。\nhttps://github.com/bigtreetech/BIGTREETECH-SKR-mini-E3/blob/master/hardware/BTT SKR MINI E3 V2.0/Hardware/bltouch-2.0-2.jpg より   Klipper で BLTouch を Z 軸のエンドストップとして使う場合、[stepper_z] セクションの endstop_pin を endstop_pin: probe: z_virtual_endstop と指定するため、BLTouch の Zmin は、SKR mini e3 V2.0 の Z-STOP(PC2) ではなく PROBE(PC14) に接続します。\n If the BL-Touch will be used to home the Z axis then set endstop_pin: probe:z_virtual_endstop and remove position_endstop in the [stepper_z] config section, then add a [safe_z_home] config section to raise the z axis, home the xy axes, move to the center of the bed, and home the z axis\nBLTouch を Z 軸のホーミングで使うなら、endstop_pin: probe:z_virtual_endstop を設定するとともに、position_endstop を [stepper_z] セクションから削除します。それから、XY 軸のホーミングの時に Z 軸を持ち上げて、Z 軸のホーミングでベッドの中心に移動するために [safe_z_home] セクションを追加します。（拙訳）\nBL-Touch - Klipper documentation より\n [stepper_z] endstop_pin: probe:z_virtual_endstop #position_endstop: 0.0 BIGTREETECH-SKR-mini-E3/BTT SKR MINI E3 V2.0SCHpdf.PDF at master · bigtreetech/BIGTREETECH-SKR-mini-E3 より   そして、printer.cfg の [bltouch] セクションにピンの設定を追加します。\n[bltouch] sensor_pin = ^PC14 control_pin = PA1 pin_up_reports_not_triggered = false probe_with_touch_mode = true ちなみに、3DTouch の各ピンと SKR mini e3 V2.0 のピンの対応関係は次のとおりです。BLTouch のクローン品である 3DTouch は、オリジナルの BLTouch とワイヤーのカラーが違いますが、各ピンの用途は同じです。\n   BLTouch のワイヤーカラー 3DTouch のワイヤーカラー 用途 SKR mini e3 V2.0 の対応するピン Klipper の対応する設定     Brown White GND GND ***   Red Black 5V 5V ***   Orange Yellow Control Signal PA1 (SERVOS) control_pin   Black Red GND GND ***   White Blue Z min PC14 (PROBE) sensor_pin    Creality3D CR-10S Pro | antclabs より   [safe_z_home] セクションの設定 Z 軸のホーミング時に、どの場所にノズルを下ろすか、下ろすときの速度、2回目のプロービングの速度などを設定します。\n[safe_z_home] home_xy_position: 115,115 # Change coordinates to the center of your print bed speed: 50 z_hop: 10 # Move up 10mm z_hop_speed: 5 プローブピンのオフセット設定 ノズルとプローブピンの位置のずれを設定します。以下の設定値のうち、x_offset はエクストルーダー改造 MOD の作者が指定した値であり、y_offset は実測値に基づいて設定した値です。\n[bltouch] x_offset = 38.2 y_offset = -5 #z_offset = 0 z_offset は、最初は設定しますが、次に説明する Z-Offset の調整を行ったら自動でコメントアウトされ、新しい設定値が printer.cfg ファイルの末尾に自動で追加されます。\nプローブの Z-Offset の調整 G28 でホーミングしてから PROBE_CALIBRATE コマンドを実行すると測定地点に移動しますので、TESTZ Z=-x.x or TESTZ Z=+x.x を実行して、シックネスゲージの 0.1mm ゲージが若干引っ掛かるところまでノズルの位置を調整します。\nちょうど良いところまでノズルが下がったら、ACCEPT コマンドを実行してから SAVE_CONFIG コマンドを実行し、オフセット値を printer.cfg に保存します。\nメッシュベッドレベリングの設定 メッシュベッドレベリングを行う場合、printer.cfg に [bed_mesh] セクションを追加して測定個所やポイント数などを設定します。\nmesh-min の場所が最初の測定個所で、mesh_max の場所が最後の測定個所となります。重要な点として、Klipper はここで設定した座標にプローブピンを下ろしますが、プローブピンのオフセット値を考慮しない座標を設定すると、ノズルの位置がマイナスになって Move out of range というエラーが発生することがあります。\n私の場合、プローブピンがノズルから X 方向に +38.2 ずれていますので、X: 0~38.1 の範囲を測定個所に指定しますと、ノズルの位置が X: -38.2~-0.1 となりエラーとなります。\n[bed_mesh] speed = 60 horizontal_move_z = 6 mesh_min = 40, 10 mesh_max = 190, 210 probe_count = 5, 5 mesh_pps = 2,2 probe_count は、mesh_min と mesh_max の2点を結んだ長方形を何分割して測定するかというものです。具体的な動作は次の図のとおりです。\nBed Mesh - Klipper documentation より   mesh_pps は、プロービング地点とプロービング地点の間の高低差を補間します場合のポイント数を指定するもので、mesh_pps = 2,2 は、XY でそれぞれ補間するポイントの数を2つにするというものです。\nBed Mesh - Klipper documentation より   メッシュベッドレベリングの結果に基づくベッドのネジ調整(Prusa限定) (2022年1月16日追記)\nPrusa の定番改造の1つに、ナイロンナットを使ってベッドの高さを厳密に調整できるようにするというものがあります（ PRUSA i3 MK3 Nylock Bed Leveling - YouTube 参照）。\n私はナイロンナットの代わりにシリコンチューブを使う方法（Silicone Bed Level Mod Prusa MK3 – SCHWEINERT.COM 参照）を採用していますが、どちらの方法でも、メッシュベッドレベリングの計測結果から中心部を除く8つのネジの回転量を計算する必要があります。\nOctoPrint にはそのためのプラグイン（PrusaOwners/OctoPrint-PrusaMeshMap: This plugin performs a mesh bed leveling operation then returns the results as an easy to read heatmap. がありますが、FluiddPi にはそうした機能がありません。\nそのため代替手段が必要になりますが、Convert g81 absolute values to relative ones. を使えば、メッシュベッドレベリングの結果を元にネジの回転量を計算してくれます。\n作業の流れは次のとおりです。\n ベッドを加熱する（ex: 60℃） 左のメニューの Tune を開いて XYZ のホーミングを行う CALIBRATE をクリックしてメッシュベッドレベリングを行う 測定結果を SAVE_CONFIG コマンドで printer.cfg に保存する printer.cfg に保存された測定結果を Convert g81 absolute values to relative ones. に貼り付ける 求められたネジの回転量に従ってネジを回す   に戻って調整結果の確認と再調整を行い、納得できるまで繰り返す。    測定結果を毎回 printer.cfg に保存するのは無駄に見えますが、FluiddPi のターミナルに表示される測定結果を Convert g81 absolute values to relative ones. の形式に整えるのは面倒なのに対し、printer.cfg に保存した測定結果の形式を整えるのは相対的に楽なので、測定結果を printer.cfg に保存してから作業を行っています。\nFuliddPi のターミナルに表示される測定結果 17:09:21 // probe at 1.806,14.998 is z=2.166976 17:09:26 // probe at 39.303,14.998 is z=2.076594 ,. 17:11:00 // probe at 114.297,215.002 is z=1.853148 17:11:05 // probe at 151.794,215.002 is z=1.687447 //printer.cfg に保存される測定結果 #*# 0.075000, 0.032500, -0.001250, 0.030000, 0.052500 #*# 0.081250, 0.061250, -0.022500, 0.011250, 0.026250 #*# 0.040000, -0.007500, -0.008750, 0.011250, -0.022500 #*# 0.070000, 0.058750, 0.083750, 0.033750, 0.035000 #*# 0.102500, 0.062500, 0.083750, 0.072500, 0.071250 Convert g81 absolute values to relative ones. の貼り付け画面  Mesh Bed Leveling のトラブル Mesh Bed Leveling が途中で停止する現象に悩まされていましたが、Discord の The 602 Wastelan の投稿 を元に horizontal_move_z: 2 を horizontal_move_z: 5 に変更したところ、きちんとレベリングしてくれるようになりました。\n4隅のレベリング調整機能 Ender 3 Pro は、ベッドの4隅にあるネジで高さを調整してベッドの水平を出しますが、Klilpper には、BLTouch で4隅の高さを測り、ベッドを水平にするにはネジをどれだけ回せば良いか教えてくれる機能が備わっています。\nManual leveling - Klipper documentation 参照\nこの機能を使うには、printer.cfg に [screws_tilt_adjust] セクションを追加して測定個所を設定します。\n[screws_tilt_adjust] screw1: 0, 32.5 screw1_name: front left screw screw2: 164.3, 32.5 screw2_name: front right screw screw3: 164.3, 202.5 screw3_name: rear right screw screw4: 0, 202.5 screw4_name: rear left screw horizontal_move_z: 10 speed: 30 screw_thread: CW-M4 ここで指定している座標値はノズルを下ろす場所なので、ノズルとプローブピンの位置のずれを考慮して座標を指定する必要があります。\nEnder 3 Pro のネジの場所は、次の図のとおりベッドの角から XY 方向に 32.5mmの場所に中心点があります。\nEnder 3 Pro のネジの配置  よって、最初の点（左手前）は X:32.5 Y:32.5 を測定すべきですが、プローブピンがノズルから X方向に +38.2 ずれているため、やむを得ず X:0 Y:32.5 を測定しています。この設定だと X:38.2 Y:32.5 を測定することになります。その次の2番目の点（右手前）の X座標は 235-32.5-38.2 で求めています。\n設定が終わったら SCREWS_TILT_CALCULATE コマンドを実行します。そうすると、FluiddPi のターミナルに測定結果とネジの回転量が出力されるので、ネジを回して再度 SCREWS_TILT_CALCULATE コマンドを実行し、可能な限りベッドが平面になるように調整していきます。\n// 調整途中の結果のため、座標値は上の設定値と異なっている 22:31:02 $ SCREWS_TILT_CALCULATE 22:31:08 // probe at 0.000,57.500 is z=0.845000 22:31:16 // probe at 159.800,57.500 is z=2.102500 22:31:25 // probe at 159.800,227.500 is z=1.970000 22:31:33 // probe at 0.000,227.500 is z=0.862500 22:31:33 // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise 22:31:33 // front left screw (base) : x=0.0, y=57.5, z=0.84500 22:31:33 // front right screw : x=159.8, y=57.5, z=2.10250 : adjust CCW 01:48 22:31:33 // rear right screw : x=159.8, y=227.5, z=1.97000 : adjust CCW 01:36 22:31:33 // rear left screw : x=0.0, y=227.5, z=0.86250 : adjust CCW 00:02 なお、ここにある時計回り・反時計回りは、ベッドを上から見た場合の回転方向です。\nクローン品を使うための追加設定 純正の BLTouch ではなくクローン品の 3DTouch を使っているせいか、Failed to verify BLTouch probe is raised; retrying. というエラーと No trigger on probe after full movement というエラーが発生したため、以下の設定を追加して対応しています。\n[bltouch] pin_up_reports_not_triggered = false probe_with_touch_mode = true その他のエラー対策 上記以外のエラーとその対応策をメモします。\nEndstop x still triggered after retract 原因は不明ですが、センサーレスホーミングを使っている状態で [stepper_x], [stepper_y] セクションの homing_retract_dist: に 0 以外を設定していると発生します。\nhoming_retract_dist: に 5 とかの値を設定していると、エクストルーダーやベッドが端に衝突した後に設定値の分だけ反対方向に移動するようになり、0 を設定すると衝突した場所で停止します。衝突後に反対方向に移動してもらう必要性は乏しいので 0 を設定してエラーが発生しないようにしています。\n!! Move exceeds maximum extrusion (0.752mm^2 vs 0.640mm^2) このエラーは、Klipper が「一度に押し出すフィラメントの量が多過ぎる」と判断した時に生じるエラーです。小さなエリアに過度のフィラメントを押し込んでしまうことを防ぐために設けられたエラーチェック機能です。\nエラーメッセージの 0.752mm^2 が G-Code を元に計算された押し出し量で、0.640mm^2 が閾値です。閾値の 0.640mm^2 はデフォルト設定で、これを変えるには、[extruder] セクションの max_extrude_cross_section に任意の値 (ex: 1.00) を設定します。\nなお、デフォルト閾値の 0.640mm^2 は、公式リファレンスによると「ノズルの直径の2乗に4を乗じた」数値とのことですが、この計算式を採用した理由は不明です。\nこのエラーについては、max_extrude_cross_section に大きな値 (ex: 50) を設定して対応しているケースが多い模様ですが、Klipper の作者は「スライサーのバグが原因で発生していると思う」とコメント しています。\nそのコメントを踏まえてエラー発生個所の G-Code を見ると、印刷前のノズル掃除を行う部分でエラーになっていました。\nG1 X60.0 E9.0 F1000.0 ; intro line G1 X100.0 E12.5 F1000.0 ; intro line ノズル掃除のためにフィラメントを多めに押し出していることが原因と思われたので、押し出し量 (E9.0) を少なくするとエラーが発生しなくなり、かつ、ノズル掃除にも支障がなかったので、押し出し量を抑えて対応しました。\nなお、このエラーチェックを行っている部分のコード (klippy/kinematics/extruder.py) を見ると、フィラメントの直径やノズルの大きさも考慮してチェックしているようです。\nUnable to read tmc uart 'stepper_z' register MSCNT UART 通信で Z 軸のモータードライバーの MSCNT レジスタを読み取ろうとしたが読み取れなかったというエラーで、Z 軸のホーミングを開始しようとした時に発生していました。\nTrinamic 社の TMC2209 のデータシートの28ページ によると、MSCNT レジスタは、マイクロステップのカウンタで、マイクロステップテーブルにおける位置を示すインジケータのようです。\n公式リファレンスの TMC Driver のページの「一般的な質問」に、よく似たエラーとして Unable to read tmc uart 'stepper_x' register IFCNT というものが掲載されており、そこでは、原因として次の2つが挙げられています。\n モータードライバが Klipper と互換性のない状態にプログラムされている (Klipper インストール直後にエラーが発生している場合)  （対応策）プリンタの電源コードを抜き、Raspberry pi と接続している USB ケーブルも抜いてから数秒間待ってリセットします。   UART 通信の配線又はピン設定が間違っている  しかし、電源コードと USB ケーブルを抜いてしばらく放置してもエラーが解消できず、また、配線と設定を再確認しても問題はありませんでした。Klipper の Discord サーバで質問しても解決しませんでしたが、マザーボードを新品に交換したら解消したので、ボードの故障が原因だったと思います。\nディスプレイ関係 Klipper は FluiddPi で操作しますので、配線を楽にするために思い切って外部ディスプレイを取り外したところ、次の警告メッセージが表示されるようになりました。\nfluidd warnings found. [display_status] is required if you do not have a [display] defined. Fluidd setup requirements can be found here. そこで、警告メッセージ中の [display_status] を printer.cfg に追加したところ、警告メッセージが表示されなくなりました。なお、このセクションの下に設定を追加する必要はありません。\nprinter.cfg 等の設定ファイルの保存場所 ~/klipper_config/ ディレクトリに保存されています。\n","date":"2022-01-02","img":"","permalink":"https://s-show.github.io/posts/2022-01-02/","series":null,"tags":["3Dプリンタ","備忘録"],"title":"Klipper と FluiddPi の設定について"},{"categories":null,"content":"前置き 自作キーボードのトラブルシューティングのための問診票テンプレート を作る時に、QMK Firmware リポジトリの keyboards ディレクトリにあるキーボードのリストを取得する方法を発見していました。\nネットを検索しても紹介されているページが見当たらないので、こちらで紹介します。\n方法 https://api.qmk.fm/v1/keyboards にアクセスするとキーボードのリストが JSON 形式で返ってきますので、使用目的に合わせてテキスト処理をして使います。\n1// コード例 2fetch(\u0026#39;https://api.qmk.fm/v1/keyboards\u0026#39;) 3 .then(response =\u0026gt; { 4 if (!response.ok) { 5 throw new Error(\u0026#39;Response not success.\u0026#39;); 6 } 7 return response.text(); 8 }) 9 .then(data =\u0026gt; { 10 // `data` は CSV なので `split(\u0026#39;,\u0026#39;)` で配列に変換。 11 const keyboardList = data.split(\u0026#39;,\u0026#39;); 12 console.log(keyboardList); 13 }) 14 .catch(error =\u0026gt; console.error(\u0026#39;There has been a problem with your fetch operation:\u0026#39;, error)); 15 16\u0026gt; [\u0026#34;[\u0026#34;0_sixty\u0026#34;\u0026#34;, \u0026#34;\u0026#34;10bleoledhub\u0026#34;\u0026#34;, \u0026#34;\u0026#34;1upkeyboards/1up60hse\u0026#34;\u0026#34;, \u0026#34;\u0026#34;1upkeyboards/1up60hte\u0026#34;\u0026#34;, ... コード例2\n1curl https://api.qmk.fm/v1/keyboards | jq 2 3[ 4 \u0026#34;0_sixty\u0026#34;, 5 \u0026#34;0_sixty/underglow\u0026#34;, 6 ... 7 \u0026#34;zvecr/zv48/f401\u0026#34;, 8 \u0026#34;zvecr/zv48/f411\u0026#34; 9]  参考情報  qmk_api/keyboard_api.md at master · qmk/qmk_api  QMK API, information on keyboards and keymaps, and a compile service. - qmk_api/keyboard_api.md at …\n    Fetch の使用 - Web API | MDN  Fetch API を利用すると、リクエストやレスポンスといった HTTP のパイプラインを構成する要素を操作できるようになります。また fetch() メソッドを利用することで、非同期のネットワー …\n  \n","date":"2021-12-12","img":"","permalink":"https://s-show.github.io/posts/2021-12-12/","series":null,"tags":["プログラミング","自作キーボード"],"title":"QMK API を使ってキーボードのリストを取得する方法"},{"categories":null,"content":"前置き 今年の3月から部下に業務遂行のバックグラウンドとなる知識を伝えるための勉強会を開いており、そのための資料を RE:View Starter で作成しています。\n勉強会の都度その回の資料を執筆し、ビルドして出来た PDF ファイルを職場にメールで送っているのですが、送り忘れた場合に備えて、Github Actions を使って Github 上でもビルドを行ってリポジトリからダウンロードできるようにしようと思いました。\nそのため Github Actions の設定をあれこれ調べたのですが、プライベートリポジトリにしているせいで詰まった部分が結構ありましたので、備忘録代わりに調べたことをまとめます。\n前提 ファイルの構成は次のとおり（主なファイルのみ列挙）で、リポジトリはプライベートリポジトリ。contens/ ディレクトリに .re ファイルを保存しています。\n1. 2├ README.md 3├ Rakefile 4├ catalog.yml 5├ config-starter.yml 6├ config.yml 7├ contents/ 8├ workshop.pdf 結論 .github/workflows/main.yml を次のとおり設定し、環境変数 PAT に Personal access token（Scope は repo ）を設定すればビルドできます。\n1on:[push]23jobs:4review:5runs-on:ubuntu-latest6container:docker://kauplan/review2.57steps:8- name:Checkout9uses:actions/checkout@v210with:11repository:s-show/workshop_document12token:${{ secrets.PAT }}13path:./14- name:Build pdf15run:rake pdf16- uses:actions/upload-artifact@v117with:18name:Save PDF19path:./workshop.pdf解説  on: [push] アクション実行のタイミングを push 時に設定します。 jobs.review:runs-on: ubuntu-latest ワークフローを実行する仮想環境に Ubuntu の最新版を指定します。 jobs.container: docker://kauplan/review2.5 Re:view Starter のビルドは Docker のコンテナを利用しているので、Github Actions でも Docker のコンテナを利用するための設定。コンテナには Re:view Starter の作者が作成したコンテナを指定します。   Docker Hub      jobs.steps.name: Checkout ジョブの命名。このジョブは、勉強会資料のリポジトリを Github Actions で使うためにチェックアウトするものなので「Checkout」としています。 jobs.steps.name.uses: actions/checkout@v2 Github Actions の環境はリポジトリがチェックアウトされていない状態なので、そのままではリポジトリのデータにアクセスできません。そこで、公開アクションの actions/checkout@v2 を使ってリポジトリをチェックアウトして $GITHUB_WORKSPACE の下に置くようにします。   GitHub - actions/checkout: Action for checking out a repo  Action for checking out a repo. Contribute to actions/checkout development by creating an account on …\n    jobs.steps.name.with.repository: s-show/workshop_document 勉強会資料のリポジトリをチェックアウトの対象に指定してます。 jobs.steps.name.with.token: ${{ secrets.PAT}} 勉強会資料のリポジトリはプライベートリポジトリなので、認証情報がなければ Github Actions はリポジトリにアクセスできない。そのため、ここで環境変数経由で認証情報を渡しています。  プライベートリポジトリを使う場合のコードは以下に掲載されています。\n GitHub - actions/checkout: Action for checking out a repo  Action for checking out a repo. Contribute to actions/checkout development by creating an account on …\n   認証情報の生成は後で説明します。\n jobs.steps.name.with.path: ./ リポジトリのトップディレクトリを作業ディレクトリに指定しています。 jobs.steps.name: Buid pdf ジョブの命名。このジョブは、PDFファイルを出力するジョブ。 jobs.steps.run: rake pdf PDF ファイルをビルドするコマンド。Re:view Starter のユーザーズガイドに記載されている PDF 出力コマンドは docker run --rm -v $PWD:/work -w /work kauplan/review2.5 rake pdf であるが、最後の rake pdf だけで実行可能。 jobs.steps.uses: actions/upload-artifact@v1 ビルドした PDF ファイルを保存するため、公開アクションの upload-artifact@v1 を使用しています。 jobs.steps.uses.with.path: ./workshop.pdf トップディレクトリに workshop.pdf というファイル名で保存するよう設定しています。  プライベートリポジトリにアクセスするための準備 プライベートリポジトリにアクセスするには認証情報が必要なので、認証情報を環境変数経由で Github Actions に渡すための設定を行います。\nPersonal access token の生成 Personal access token の生成画面はユーザー設定画面にありますので、画面右上のユーザーアイコンの「Settings」を開いてから「Developer settings -\u0026gt; Personal access token -\u0026gt; generate new token」の順番で開いていきます。\n生成ページを開いたら、Note に任意の名称を入力し、スコープに repo を指定して Personal access token を生成し、生成した Personal access token をコピーします。\n環境変数の設定 環境変数はリポジトリ毎に設定するので、リポジトリの「Setting」を開いてから「Secrets -\u0026gt; New repository secret」の順番で開いていきます。\n環境変数の設定画面を開いたら、 Name に PAT を、 Value に Personal access token の値を貼り付けて保存します。\nデバッグ用の設定 デフォルト設定でもそこそこ詳しいログが保存されますが、さらに詳細なログが保存されても問題はないので、環境変数に次のペアを登録して詳細なログが保存されるように設定します。\nACTIONS_STEP_DEBUG → true\nACTIONS_RUNNER_DEBUG → true\n デバッグロギングの有効化 - GitHub Docs  ワークフロージョブあるいはステップが期待どおりに動作しない理由を診断する上で、十分な詳細がワークフローのログになかった場合、追加のデバッグロギングを有効化できます。\n   ","date":"2021-12-11","img":"","permalink":"https://s-show.github.io/posts/2021-12-11/","series":null,"tags":null,"title":"Github Actions で Re:view Starter のファイルをビルドする方法"},{"categories":null,"content":"前置き ~~この記事は 3Dプリンター改造記録 Advent Calendar 2021 - Adventar の1日目の記事です。\n（最初に本記事を執筆したときは2日目の記事でしたが、トップバッターを務められる予定だった tomorrow56@ガジェット分解(モ2済) さんが公開日を12日に変更されたので、期せずしてトップバッターになりました。）\n本アドベントカレンダーは「今年実施した/今年までに実施した3Dプリンターへの改造内容をまとめる記事」なので、今使っている Prusa MK3S+ と Ender3Pro の改造履歴をまとめます。\n実際の改造 私が現在使っている 3Dプリンタは「Prusa i3 MK3S+」と「Ender 3 Pro」の2台で、それぞれの改造は次のとおりです。\nPrusa MK3S+ Prusa の改造は次のとおりです。Prusa は元の性能が高いので、Ender 3 Pro に比べると小規模な改造に留まっていると思います。\n Bear Extruder の導入 ギヤードモーターの導入 Klipper の導入 シリコンベッドレベリング リニアブッシュの交換  Bear Extruder ホットエンド回りのメンテナンス性を上げるため、エクストルーダーを gregsaun/bear_extruder_and_x_axis: An improved extruder and X axis for Prusa i3 printers に切り替えました。プリンター全体を Bear にしなかったのは、そこまでしなくても大丈夫だろうという思いと、アルミフレームを買う出費と改造の手間を惜しんだためです。\nただ、吐き出し量のチューニングに問題があったのか、ナットが手で入らないので止むなくハンダごてを使って力技でナットを入れた個所があり、あらためて印刷してパーツを交換する必要があるかなと考えているところです。\n当初の狙いであったメンテナンス性の向上については、何度か分解を繰り返していますが、分解＆再整備に苦労することがないので、向上が図られていると思います（切り替え前の記憶が乏しいので正確なところが不明になっています）。\nギヤードモーターの導入 フィラメントの送り出し量を細かく制御するため、減速ギヤを使ってモーターの回転数を減速させることにしました。\nまず、既存のモーターにギヤを後付けできる次の MOD を使うことを検討しました。\nNema 17 Gearbox \u0026ldquo;Pulleybox\u0026rdquo; Mod for Extruder by vertigo235 - Thingiverse しかし、これを使う改造が上手くいかないときに、3Dプリンタパーツを多数販売している TriangleLab からギヤ内蔵のモーターが販売されましたので、こちらを導入することにしました。\nTrianglelab nema 17ギヤードステッピングモータ1:3 reductingステッピングモータprusa I3 MK3S押出機変更1:3ギヤ比|3D Printer Parts \u0026amp; Accessories| - AliExpress フィラメントの送り出し量が細かく制御できるようになり、プリント品の品質が向上しました。\nKlipper の導入 既存のファームウェアに大きな不満があったわけではないのですが、印刷品質の向上等を図るためにファームウェアを Klipper にしました。なお、プリンタの制御は FluiddPi で行っています。\nWelcome - Klipper documentation fluidd-core/fluidd: Fluidd, the klipper UI. ファームウェア切り替え後は設定で大分悩みましたが、設定ができてしまうと FluiddPi から何でもできるため非常に便利になりました。\nEnder 3 Pro にも導入する予定ですが、なかなか時間がとれないため作業が進んでいません。\nシリコンベッドレベリング ベッドの水平を出すために PRUSA i3 MK3 Nylock Bed Leveling - YouTube で紹介されている方法を導入していましたが、調整がとにかく面倒でした。レベリングを繰り返して調整を追い込んでいく必要があるのは仕方ないのですが、調整の際にナイロンナットをペンチで固定しながらネジを回すという作業がとにかく面倒で、一度実施したら可能な限り再調整したくないという状況でした。\nそんなとき、Silicone Bed Level Mod Prusa MK3 – SCHWEINERT.COM でシリコンチューブを使ってレベリングする方法が紹介されていて、これならベッドの上からネジを回すだけで調整が可能になって調整が楽になると思って導入しました。\n実際に導入してみると、ナイロンナットを使うより簡単に導入できて調整作業も楽なので、非常にコストパフォーマンスの良い改造でした。\nなお、上記のサイトでは「外径 7-8mm、内径 3mm」のシリコンチューブを使うとありますが、国内でこのサイズのシリコンチューブが見つからなかったので、モノタロウで「外径 6mm、内径 3mm」のシリコンチューブを購入しました。\nSR1554 シリコンチューブ タイガースポリマー 内径 3Φmm、外径 6Φmm、長さ 1m、SR1554、1巻 - 【通販モノタロウ】 リニアブッシュの交換 Prusa は XY 軸の可動部分が V スロットではなくリニアブッシュですが、移動時に結構な音がするので、これを少しでも静かにするためにプラスチック製のリニアブッシュに交換しました。使ったリニアブッシュは ドライリンR リニアベアリング RJ4JP-01 です。\n体感による比較ですが、交換してからは XY 軸の移動時の音が少し静かになりました。これ以上静かにしようと思ったら、モーターダンパーを導入して、さらにプリンタをコンクリート板の上に載せる必要がありますが、いまのところそこまで行う予定はないです。\nEnder 3 Pro Ender 3 Pro の改造も色々行っています。MOD も改造パーツも豊富な機種なので、色々いじりがいがあります。\n マザーボードの交換 BLTouch の導入 XY 軸のリミット制御をセンサーレスホーミングに切り替え エクストルーダーをダイレクト化 Z 軸をデュアル化 エクストルーダーファンを Noctua 製に切り替え  マザーボードの交換 私が買った Ender 3 Pro のストックのマザーボードのモータードライバーは8ビットだったので、印刷中の騒音がひどかったです。そのため、モータードライバーの32ビット化を図るため、Bigtreetech 製の SKR mini e3 V2.0 に取り換えました。これにより騒音問題が解消し、動きも滑らかになって印刷品質も向上しました。また、後述する BLTouch の導入やセンサーレスホーミングの導入も簡単にできるようになりました。\nあと、ファームウェアを更新するときにマザーボードと PC を接続する必要がないのも便利です。\nBIGTREETECH SKR MINI E3 V2 32Bit Motherboard Integrated TMC2209UART Upgrade For SKR V1.4 Creality Ender 3/5 Pro 3D Printer Parts BLTouch オートベッドレベリング導入のために行いました。これにより、最初にベッド4隅のネジを調整してベッドの水平を出してしまえば、ベッド内の凹凸によるレベリングの差は BLTouch のメッシュベッドレベリングで対応できるようになりました。\nセンサーレスホーミング SKR mini e3 V2.0 のモータードライバーは TMC2209 で、ジャンパコネクタでマザーボードのヘッダーピンの接続を変えるだけでセンサーレスホーミングが使えます。印刷品質向上には繋がらないですが、リミットスイッチを撤去できて配線が楽になり、また、リミットスイッチが壊れても限界を超えてエクストルーダーやベッドが動くことが無くなりました。あと、なんとなく Prusa っぽい動きにもなったのもうれしい点です。\n“ジャンパコネクタの取り付け図”  これに伴い、ついでにリミットスイッチの代わりになる部品を設計して取り付けています。Auto Home 移動時は、この部品にぶつかってプリントヘッドやベッドが停止します。\n“リミットスイッチの代替品”  ダイレクトエクストルーダー化 エクストルーダーのダイレクト化は、次の MOD を使って行いました。\nPetsfang Bowden Direct with Bondtech BMG for CR10/S/4, Ender3 and Tevo Tornado by dpetsel - Thingiverse ダイレクト化により、糸引きを大幅に減らすことができるようになりました。また、この MOD は V6 ホットエンド対応なので、ストックの MK8 ホットエンドから V6 ホットエンドに交換しました。これにより、それまでたまに発生していたホットエンド内でのフィラメント詰まりも発生しにくくなりました。\nZ 軸のデュアル化 Z 軸のデュアル化は、左右の Z 軸で動きに差が出ることを避けるために行いました。幸い、SKR mini e3 V2.0 はデュアル Z 軸に対応しているため、パーツを購入して配線すれば簡単に実現できます。これにより、左右の Z 軸の動きにずれが出なくなりました。\n購入したパーツはこちらです。\n3dプリンター部品Ender 3プロ用アップグレードキット,アルミニウム,デュアルz軸|3D Printer Parts \u0026amp; Accessories| - AliExpress エクストルーダーファンの交換 エクストルーダーファンの交換ですが、ストックのエクストルーダーファンは爆音で耳障りだったため、Noctua ファンに交換しました。\nEnder 3 Pro のエクストルーダーファンは24Vで動く前提となっており、SKR mini e3 V2.0 も24Vの電圧を供給しているため、DCDCコンバーターで電圧を24Vから12Vに変換しています。これによりファンが非常に静かになりました。\nなお、この改造はつい最近行ったため、これで冷却が十分足りるかどうかの検証は不十分な状態です。\n最後に 以上が2021年に実施した3Dプリンタの改造です。\n色々と改造を行っていますが、どちらのプリンタもまだ改造したい点はあります。現時点で考えている改造は次のとおりです。\nPrusa\n The PitStop Extruder for Prusa printers の導入 フレーム全体を Bear に改造 リニアレールの採用 Backlash 低減のための改造  Ender3\n Klipper の導入 エクストルーダーの交換（今のエクストルーダーはホットエンドの冷却が少々気になる） リニアレールの採用  何かを作ることも楽しいですが、改造すること自体も楽しいのが3Dプリンタだと思っていますので、来年も色々やってみる予定です。\n次のアドベントカレンダーの記事は @Ikeji さんの Ender 3改造記録 | my.remarkbox.com です。\n","date":"2021-12-10","img":"","permalink":"https://s-show.github.io/posts/2021-12-10/","series":null,"tags":null,"title":"2021年に実施した3Dプリンターの改造"},{"categories":null,"content":" Name s-show  このブログについて プログラミングや3Dプリンタや自作キーボードの話題を中心に、自分が学んだことを色々書いていくブログです。それ以外の時事ネタなども気が向いたら書きます。\nちなみに、以前はさくらサーバに WordPress をインストールしてブログを作っていましたが、更新の度に WordPress 特有の書き方に悩まされたりするのが嫌になったので、Hugo に切り替えました。ブログ末尾の Copyright の年次より前の記事があるのはそのためです。\nブログタイトルの意味 閑古鳥が鳴いているようなインターネットの片隅にあるブログ、という意味を込めています。\n GitHub s-show (s-show)  Qiita s-show - Qiita   ライセンス \nこのブログの内容は、 クリエイティブ・コモンズ 表示 4.0 国際 ライセンスの下に提供されています。\n","date":"2021-12-08","img":"","permalink":"https://s-show.github.io/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"前置き この記事は キーボード #2 Advent Calendar 2020 の4日目の記事です。何気に Advent Calendar 初参加です。 さて、この記事で何を書くかですが、「キーボードのお店を始めるに至った話」とか「小説家に営業した話」といったディープな話題は書けません。 なので、自作キーボード活動2年目を振り返る記事を書きたいと思いますが、2年目を簡単に振り返ると、オリジナルキーボードの製作が一番比重が大きく、QMK のドキュメント翻訳レビューがそれに続き、Discord の #mon-shin チャンネル用のダイアログページを作ったという1年間でした。なので、これらの活動について書いていきます。\nオリジナルキーボードの設計 オリジナルキーボードの設計については、1年目に色々なキーボードを使う中で自分なりに「こういうキーボードが良さそう」という像が見えてきたことから、それを形にするべく挑戦しました。 最初の1台目は、ProMicro を使う方法で3〜4月に作成したのですが、コネクタ類の位置を間違えて、USB ケーブルと TRRS ケーブルが PCB と干渉してしまいました。そのため、TRRS ケーブルのコネクタをナイフで削り、ProMicro と基板の間のスペースを確保するためピンヘッダを基板に取り付ける羽目になりました。とはいえ、キー入力は問題なくできることと、自分が理想と考えていたキー配列の打ちやすさを実地に試すことができたので、失敗も含めて収穫は大きかったと思います。\nそのキーボードを現在まで使っているのですが、ケーブルが PCB と干渉するキーボードを End Game にするのは無理があるのと、キー配列の問題点 (Zの入力が失敗しやすい) が判明したことから、9月頃から2台目の作成に着手しました。 2台目のキーボードの設計コンセプトは\n 配列はColumn Staggerd 形状は左右分離型 キー数は48 親指で『Space/BackSpace、Lower/Raise、Win/CMD、Alt』キーが押せる プレートとケースは3Dプリントで作る ProMicro を使わずに ATMega32U4 直付け  このうち、1〜4番目は単なる好みに基づくものですが、5番目はへそ曲がりな性格が顔を出したが故のコンセプトです。\n自作キーボードでは、打ち心地の向上などを図るため、ケースをアルミ削り出しで、プレートを真鍮やステンレスの穴あけ加工で作成することがありますが、1年前よりもそういったケースなどを作る人が増えているという印象です。ただ、それらを見ていると「そこまでお金を出すのは躊躇うな〜」と感じていました。そこで、その対極という訳ではないのですが、ケースやプレートの3Dモデルをダウンロードすれば誰でも 3Dプリンタで安価に出力できて、その気になれば自分でカスタマイズできるキーボードがあっても良いのではないかと考えて、このコンセプトを盛り込みました。\n6番目のコンセプトは、ProMicro による出っ張りを上手に活かせる設計がどうにもこうにもできなかったので、レイアウトの自由を求めて ATMega32U4 直付けに切り替えたものです。これにより、USB コネクタを Micro-B から TypeｰC にできるという収穫もありました。\nこれらのコンセプトを満たすべく設計に着手したのですが、小学1年生の時から科学図鑑を読むのが大好きだったとはいえ、文系高卒で文系職場に就職した身では電子回路の知識が乏しく、ATMega32U4 の使い方をどうやって勉強するかを勉強するところからのスタートでした。\nそして勉強を始めて痛感したのは、ATMega32U4 を使う人は使い方や前提知識をわざわざ書かない、ということでした。具体的には、ATMega32U4 を使うためのコンデンサやクリスタルや抵抗について、なぜそれらの部品が必要なのか、どういう基準で選べば良いのか、どのように配置していくのか、といった点を説明しているサイトがほとんど見つけられませんでした。そのため、ATMega のデータシートを読み込み、個別の項目に絞って検索して調べ、それを自分なりにまとめていくという方法で理解に努めました。その成果はこちらですが、実際に設計に着手すると色々と改善点が見えてきたので、今後修正する予定です。 ATMega32u4を使う場合の設計メモ.md とまあ、こんな具合に2台目のキーボードを設計しているのですが、基板設計まで進んだところで Discord でレビューをお願いしたら、見事なダメ出しを受けて自分の知識の無さと皆さんの協力のありがたさを痛感している、というのが現時点の状況です。(そのまま PCBA 発注していたら間違いなく動かないキーボードになっていたので、本当に感謝しています。\nQMK の翻訳レビュー こちらは 2019年11月4日に umi-umi (umi) さんが add japanese translation by umi-umi · Pull Request #7248 · qmk/qmk_firmware で47ファイルの日本語への翻訳のプルリクを出したところから始まったもので、私も docs/ja/feature_tap_dance.md (Merge 済) や docs/ja/keycodes.md (レビュー中) 、docs/ja/keycodes_basic.md (レビュー待ち) を翻訳したり、他の方々の翻訳をレビュー(こちらがメイン) したりしています。\n自分の翻訳については、ケアレスミスから翻訳漏れまで多数の指摘をいただくことになり、レビュワーの方々に多大なご迷惑をおかけしています。その穴埋めという訳ではないですが、他の方々の翻訳のレビューにあたっては、指摘の根拠を明示し、レビューされる側の負担を少しでも減らすように努めています。\n進歩の早い分野では、英語に怯まず公式ドキュメントに当たるのが正しい姿勢なので、その公式ドキュメントに日本語訳があることは日本のコミュニティにとってプラスにこそなれマイナスになることはないと思います。そう思って、少しでも日本の自作キーボードコミュニティに貢献すべく、翻訳とレビューに取り組んでいます。\nちなみに、Windows と Mac の両方を使っているのですが、翻訳はレビューを含めて Mac で行なっています。理由は、ランチャーアプリの Alfred を設定すれば、d hogehoge と打ち込むだけで内蔵辞書を開けるためです。文法を調べる頻度はそんなに多くないので、文法書を手でめくっていても作業効率にたいした影響は無いのですが、単語はしょっちゅう調べるので、手作業では作業効率がガクッと落ちてしまいます。そのため、翻訳は Mac で行なっています。 note: 翻訳の進捗状況は、ファイル数ベースで未翻訳が19%という状況です。\nダイアログページの作成 キーボード制作でトラブルに遭遇した時に Discord で質問する際のチャンネルとして #mon-shin というチャンネルがあり、質問用テンプレートが用意されています。\nただ、テンプレートの穴埋め状況にばらつきがあると感じていましたので、誰でも必要項目を選んでいけば質問文が容易に作れるようにするため、専用のページを作成しました。\n問診票テンプレート 幸い、作成したページが採用され、これまでにこのページを利用した質問がいくつも出されていますが、実際に運用すると足りない機能も出てくるので、これから修正していく予定です。\nまとめ 「自作キーボードについて考えていることなどをつらつら書きます」と Advent Calendar には書いておきながら活動報告になってしまいましたが、自作キーボードを始める前は、自分が同好の士の中に混じってこんな形で活動することになるなんて全く予想していませんでした。 毎日使う道具でありながら、凝ったことをしなければ制作は思うほど難しくないという絶妙な存在なのが自作キーボードだと思っていますが、こういうとっても面白い世界に巡り合えたことには感謝しています。\nまた、あれこれ迷惑をかけているのに、いつも親切に対応していただいているコミュニティの皆様にも感謝しています。少しでもコミュニティに貢献できるべく努力したいと思っていますので、引き続きよろしくお願いします。 明日は、Takeshi Nishio さんの『自キ活1年目で出来たものと、総当たりマトリクスのご紹介。』という記事です。\n最後まで読んでいただきありがとうございます。この記事は、自作のオリジナルキーボードで書きました。\n","date":"2020-12-03","img":"","permalink":"https://s-show.github.io/posts/2020-12-03/","series":null,"tags":["未分類","自作キーボード"],"title":"自作キーボード活動2年目の振り返り"},{"categories":null,"content":"明けましておめでとうございます。新年もよろしくお願いします。\n本記事が新年最初の記事になるが、新年最初の記事ということで、昨年1年間を振り返って今年の簡単な抱負を書いてみようと思います。\n昨年1年間の大きな変化 仕事は変わらなかったので大きな変化はありませんが、私生活では意外な変化がありました。といっても、結婚とかそういう話ではなく、趣味というか、新たな世界が広がったという話です。\nこう書くと大仰な話に聞こえますが、簡単に言えば「物を作る」とことの面白さを知ったということです。\n以下、そういう変化に至った経緯を簡単に書いていきます。\n経緯 「物を作る」ことの面白さを知ったきっかけは、自作キーボードを作ったことです。では、なぜ自作キーボードを作ったのかというと、始まりは Amazon で以下のキーボードを買ったことです。\nAmazon | HAVIT | havit | パソコン用キーボード 通販 このキーボードが「メカニカルキーボード」という分類に属すると知り、それではメカニカルキーボードとはなんぞやと調べていたところ、自作キーボードのキットが販売されているのを発見し、面白そうだと思って2019年1月にキットを買ったのが自作キーボードの始まりです。\nMint60スターターセット – ゆかりキーボードファクトリー この Mint60 に限らず、大部分の自作キーボードは QMK Firmware というファームウェアを使用しており、ファームウェアを書き換えてキーマップに自由に変えられるのが自作キーボードの非常に大きなメリットです。そのメリットを享受すべく色々模索していましたが、その過程で、「親指キーが多い方が便利じゃない？」と思うようになり、新しいキットを購入しました。\nErgoDash | 遊舎工房 このキーボードは親指キーが豊富で、ホームポジションから手をほとんど動かさずに大抵の入力が可能です。これ以降も以下のキーボードを組み立てていますが、テンキーを除いたキーボードのキーマップは、この ErgoDash で作ったキーマップがベースになっています。\nNaked48LED - 自キ温泉街販売所 - BOOTH Setta21 - 自キ温泉街販売所 - BOOTH Plaid | 遊舎工房 Attack25 自作キーボードキット - 25KEYS - BOOTH Corne Cherry | 遊舎工房 Kugel-1 - のぎけす屋 - BOOTH とまあ、こうやって自作キーボードの沼に入っていったのですが、そうこうしているうちに東京メイカーフェア2019 が開催され、自作キーボードのコミュニティである「Self-Made Keyboards in Japan」の方々も出展すると聞いたので、休みを取って足を運びました。\nメイカーフェアに参加したのは初めてでしたが、Google とか LINE のハイレベルな展示物もさることながら、個人でロボットアームを作ったり、R2-D2が動いていたり、挙げ句の果てには個人制作の加速器まであったりと、ものづくりの奥行きと凄さを肌で感じることができたのは大きな収穫でした。\nそうやってものづくりに触れた後、新たなキーボードを作るだけではなく、作成済みのキーボードをカスタマイズしてみようと思い、Illustrator でケースを設計して HANDS Fab でレーザーカットしてもらうことを始めました。しかし、切断しかできないレーザーカッターでは複雑な形状を作るのに限度があると気づき、代わりに3Dプリンタを購入しました。\nそして3Dプリンタを使い始めましたが、間に合わせのデスクでは水平が出ない、水平を出すべく脚に物を挟んで調整すると振動が大きくなって品質が悪化する、仕方がないので床に置いて印刷すると不便で邪魔になる、とにっちもさっちもいかなくなったので、SUS社のアルミフレームを発注して専用の印刷台を作成するに至りました。\nまた、3Dプリンタを買う前には、雑多な物をまとめて置いておける背高の棚（木製）も自作しました。小ぶりな棚は以前から作っていましたが、部屋に合わせて作ると引越しで間取りが変わると使いにくくなるし、そもそも全く塗装していない白木では高級感も何もあったものではないので、その都度バラして粗大ゴミになっていました。その反省を踏まえて、どの部屋でも使えるような設計にするとともに、しっかりワックスを塗り込んで高級感を出し、引越しても使う気になる家具に仕上げてみました。\nさらに、Raspberry pi を使ったスマートリモコンを作ってみるため、プリント基板CADを使って設計した基板の製造を中国の業者に発注することまで行いました。\nこうしてみると、自作キーボードから始まって色々な物を作ってきた1年間でしたが、1年前には自分がこうして何かを作っている姿は全く想像していませんでした。\nなにも広い部屋に引っ越して工作機械が置けるようになった訳ではないし、自分で作らないと生活に支障が出るから作っている訳ではないです。ただ、キーボードが自作できることを知り、そして、個人でも色々なものが作れるということを知ることで、何かを作るということに対する心理的なハードルが大きく下がったと実感しています。そして、物を作るのは苦労も多いですが、制作過程では「大変だけど楽しい」というある意味矛盾した感覚が得られるので、まだまだ色々なモノづくりに挑戦してみようと思っています。\n一寸先は闇なのが現実世界ですが、面白いと思ったことに挑戦していけば色々なものが得られるという当たり前の事実が分かった以上、うだうだ考えるよりとにかく動いてみることを信条にしてこの1年間を過ごしてみたいと思います。そうすれば、来年の今頃に新たな記事も書けるようになっている（と思います）。\n","date":"2020-01-01","img":"","permalink":"https://s-show.github.io/posts/2020-01-01/","series":null,"tags":["未分類"],"title":"自作キーボードから始まったものづくりへの取り組み"},{"categories":null,"content":"前置き AnyCubic 製の AnyCubic Mega S という3Dプリンタを使っていますが、動作中にモーター音に加えて結構な大きさの電子音が鳴ってうるさいので、モータードライバを工場出荷時の A4988 から TMC2208 に交換しました。ただ、手順を紹介した記事が少なくて苦労しましたので、備忘録代わりに手順をまとめてみました。\nなお、この記事の前提は次のとおりです。\n プリンタの機種 AnyCubic Mega S マザーボード Trigorilla Mega2560+ramps 1.4 作業PC Windows10  必要なもの TMC2208 Amazon や Aliexpress で「TMC2208」を検索するといくつかヒットしますが、バージョン違いがあるので注意が必要です。\n私は FYSTEC社が販売しているVer.1.2を使いました。Ver.1.0と1.2の違いは、UART を使うときの設定方法のようです。\nMarlin Firmware TMK2208 のピン配置は、Mega Sに最初から取り付けられている A4988 と反対なので、TMC2208 を使う場合はマザーボードとモーターを繋ぐコネクタの向きを反対にする必要があります。\nしかし、Anycubic i3 Mega / Mega-S Marlin 1.1.9 Custom Firmware - Extra Features \u0026amp; Quality Tweaks を使うとコネクタの向きを変える必要が無いので、これを使うと便利です。というか、TMC2208のコネクタ以外にも便利な機能があるので、ぜひこのカスタムファームウェアをインストールするべきです。\nRaspberry pi 3 Raspberry pi 3 に OctoPrint という3Dプリンタ制御用の OS を書き込んで、プリンタ制御や設定を行います。無くても交換できるが、交換後の設定変更などで非常に重宝しますし、今後の印刷や設定変更でも大活躍するので、この機会に導入しておいた方が良いと思います。\n作業手順（TMC2208） TMC2208 は、工場出荷時点では StelthChop2 という静穏化を最重要視したモードになっています。このモードは、静穏化には有効な反面、トルクが弱い、チップが高温になるという問題があります。そこで、StelthChop2 より少しうるさいが、トルクが強く温度上昇も抑えられる SpreadCycle というモードを利用することにしました。\nSpreadCycle モードを利用するには TMC2208 のマイコンの設定を変える必要があります。ブレッドボードに TMC2208 と抵抗等を差し込んで USB-シリアル変換装置で PC と繋げば書き込みできますが、専用の書き込み装置を使う方が簡単で FYSTEC 社は専用の書き込み装置も販売していますので、TMC2208 とあわせて購入すると便利です。\nなお、TMC2208 のマザーボードとの接続パターンは次の3つがあるようです。\n Legacy Mode ドライバを取り付けて電圧を調整すればOKという簡単な方法だが、StelthChop2 しか使えないようです。 Stand Alone Mode SpreadCycle モードが使えますが、TMC2208 を PC と接続して動作モードを変更する必要があります。私はこのパターンで接続しています。 UART Mode マザーボードとジャンパピンで接続してファームウェアのソースコードを修正したりと手間がかかりますが、その代わり、SPI でドライバをコントロールすることができるようです。  書き込み装置の準備 書き込み装置を使うには次の作業が必要です。なお、書き込み作業は Windows10 で行なっています。\n 書き込み装置にジャンパピンを2つ差し込む シリアル通信用のドライバをインストールする 設定書き込みに使うソフトウェアをインストールする  まず、ジャンパピンは次の写真の2箇所に差し込みます。\nTMC2208書き込み装置にジャンパピン取り付け  次に、シリアル通信用のドライバを CH340 Drivers for Windows, Mac and Linux からダウンロードしてインストールします。\nそれから、TMC2208の設定を変えるために使う ScriptCommunicator / serial terminal download | SourceForge.net をインストールし、専用のファイルである Configurator for TMC220x | SilentStepStick | Watterott electronic をリンク先からダウンロードします。\nTMC2208 の半田付け 上記の作業で PC と書き込み装置側の設定はOKですが、設定を変えるには、TMC2208 のパッドをハンダでブリッジする必要があります。ブリッジする箇所は次の写真のとおりです。\nTMC2208の半田ブリッジ  SpreadCycleへの書き換え ここまでの作業が完了したら、書き込み装置をPCに接続し、デバイスマネージャーで書き込み装置の COMポート番号を確認します。それから、 MC220X.scez を ScriptCommunicator で開いて書き込み装置に TMC2208 を取り付けます。\nTMC2208 を SpreadCycle モードで使う場合、OTPメモリの値を書き換える必要がありますので、OPT Programmer タブを開いて、次の手順で OTPメモリの値を書き換えます。\n OTP の値を 2.7 にするため、次の画面のとおり数値を入力して write 1-bit to OTP memory ボタンをクリック  TMC2208 のOTP書き換え1  TOFF の値を 1.1 にするため、次の画面のとおり数値を入力して write 1-bit to OTP memory ボタンをクリック  TMC2208 のOTP書き換え2  作業手順（本体） 分解 底板の取り外し 椅子を隙間を空けて2つ並べ、その隙間にZ軸のフレームを通して本体を裏返すと作業が楽です。\nAnyCubic Mega S の底板取り外し準備  なお、AnyCubic Mega S は、モータードライバを冷却するファンの吸気部分が塞がれていて吸気に問題がありますが、底板の手前と奥を180度回転させると吸気部分が開くので、この方法をお勧めします。\nAnyCubic Mega S の底板の前後入れ替え  モータードライバ用ファンの取り外し 作業の邪魔になるので、モータードライバ用のファンを取り外します。\nモータードライバ交換 X軸、Y軸、Z軸（左右で1つずつ）、エクストルーダーのモーターを制御するドライバ5個を全て取り外します。万が一、元のドライバに戻すことになった場合に備えて、ドライバの向きや、どのドライバがどこに差し込まれていたかを記録することをお勧めします。\nモータードライバの電圧調整 テスターの端子を FYSTEC社の解説 Wiki で紹介している場所に当てます。YouTube の動画では同 Wiki とは異なる場所にテスターを当てていたりするが、どこで測定しても電圧は同じでした。\nTMC2208 の電圧測定  プリンタの電源を入れてから、テスターを当てて電圧を測定します。電圧の設定ボルトについては、この後インストールするファームウェアの作者が提案している電圧に設定しました。（リンク ）\n X, Y, Z, E1 (E1 = 2nd Z axis) 1.1V E0 (=extruder) 1.2V  Firmwareの書き込み Curaで書き込む方法 Cura を立ち上げて「Settings \u0026gt; Printer \u0026gt; Manage Printers..」を開いたら、「Update Firmware \u0026gt; Upload Custom Firmware」をクリックしてカスタムファームウェアのファイルを選択します。\nOctoPrintで書き込む方法 OctoPrint を起動して、ファームウェア作者の指示に沿って次のコマンドを実行します。なお、コマンドは Cura でも実行できますが、プリンタが返したメッセージが表示されないので、OctoPrint で作業をする方が楽です。\n M502 - load hard coded default values M92 E384 - set correct steps for the new extruder M203 E30 - limit extruder feedrate M204 R1500.00 - lower retract acceleration M500 - save the values  Accelaration \u0026amp; Jerk の設定 Accelaration \u0026amp; Jerk の設定を、ファームウェア作者の推奨値に変更します。\n M201 X2000 Y1500 Z60 E10000 ; max acceleration M204 P1200.00 R3000.00 T1500.00 ; default acceleration M205 S0.00 T0.00 Q20000 X9.00 Y9.00 Z0.40 E5.00 ; min segment time and jerk M500 - save the values  ヘッド移動のテスト OctoPrint のコントロール画面かプリンタのメニューでヘッドをホームポジションに移動させます。\nリミットスイッチがあるのでプリンタの制限以上に動かないはずですが、念のため、ヘッドの動きがおかしかったら直ちにプリンタの電源を切れるよう構えておきます。\nMeshBedLeveling実行 5×5 の25点のレベリングができるようになったので、印刷品質向上のためベッドのレべリングを調整します。Anycubic i3 Mega / Mega-S Marlin 1.1.9 Custom Firmware - Extra Features \u0026amp; Quality Tweaks by davidramiro - Thingiverse の手順に従って行うこともできますし、OctoPrint にカスタムボタンを追加して行うこともできます。\nテスト印刷 \u0026amp; キャリブレーション テスト印刷 レベリングが適切にできているか確認するため、次のデータを印刷します。\n Bed test pattern for 200mm square bed. by N3wSp3ak - Thingiverse  Customizable Bed Leveling Test by kenwebart - Thingiverse   レべリングの調整 全体的にノズルが近い/遠い場合、OctoPrintのプラグインの EEPROM Marlin Editor で Z軸のオフセットを調整してレベリングをカバーすることが可能です。\n測定箇所毎のレべリングの値は G29 S0 コマンドを実行すると以下のとおり確認できます。\nSend: G29 S0 Recv: State: Off Recv: Num X,Y: 5,5 Recv: Z offset: 0.00000 Recv: Measured points: Recv: 0 1 2 3 4 Recv: 0 -0.35000 -0.18000 -0.01500 +0.18000 +0.42000 Recv: 1 +0.01000 +0.03000 +0.09000 +0.18000 +0.41000 Recv: 2 -0.01000 +0.09000 +0.11000 +0.13000 +0.45000 Recv: 3 +0.09000 +0.09000 +0.10000 +0.16000 +0.30000 Recv: 4 +0.06000 +0.11000 +0.17000 +0.17000 +0.29000 Recv: Recv: X:-5.00 Y:215.00 Z:23.41 E:372.56 Count X:-405 Y:17381 Z:9730 Recv: ok レべリング確認の印刷で部分的にレベリングに問題があった場合、G29 S3 Xn Yn Z-n.nn コマンドで測定箇所毎にレべリングの値を変えられます。レべリングの値を変えた時は、M500 コマンドで忘れずに保存すること。\nちなみに、上記のコマンドで XY を指定する時は、以下のとおり指定します。\n// XY軸の表示 X1 X2 X3 X4 X5 Y1 -0.35000 -0.18000 -0.01500 +0.18000 +0.42000 Y2 +0.01000 +0.03000 +0.09000 +0.18000 +0.41000 Y3 -0.01000 +0.09000 +0.11000 +0.13000 +0.45000 Y4 +0.09000 +0.09000 +0.10000 +0.16000 +0.30000 Y5 +0.06000 +0.11000 +0.17000 +0.17000 +0.29000 このコマンドによる修正は、レベリングを完璧にするというよりも、どの部分でもノズルとベッドの距離が同じになることを目指します。どの部分でもノズルとベッドの距離が等しくなれば、あとは OctoPrint のプラグインの EEPROM Marlin Editor で Z軸のオフセットを調整することでレベリングを完璧にすることができるようになります。\nEEPROM Marlin Editor による Z軸のオフセットの調整は、Steps -\u0026gt; Home Offset で Load を押して現在の値を取得してから、Z axis のインプットボックスにオフセット値を書き込んで Upload をクリックしてオフセットを変更します。\n正の値を入力するとベッドに近づき、値が増えるに従ってよりベッドに近づきます。逆に、負の値を入力するとベッドから遠ざかり、値が減少するに従ってよりベッドから遠ざかります。\n","date":"2019-12-20","img":"","permalink":"https://s-show.github.io/posts/2019-12-20/","series":null,"tags":["3Dプリンタ","備忘録"],"title":"AnyCubic I3 Mega S に TMC2208 を導入する"},{"categories":null,"content":"前置き 自作キーボードのPlaidはお気に入りのキーボードであるが、このキーボードは、ProMicro の代わりにマイコンの ATMega328P を使っており、キーボードには ISP ポートが用意されている。\nなので、このキーボードを AVR ライターがわりに使えるのではないか、また、秋月とかで購入した ATMega328P にデータをバックアップしておいて、いざというときはマイコンだけ置き換えて対処する、といったこともできるんじゃないかと思って挑戦してみた。\nその挑戦がうまくいったので、その手順を備忘録として残しておく。\n作業の手順 作業に使うものは次のとおり。\n Plaid Arduino Uno（互換品でOK） ブレッドボード・ジャンパーワイヤ（オス－メス）6本  作業の手順は以下のとおり。\nArduinoをAVRライターにする 手順 Arduino IDEをインストール まず、Arduino の公式サイトでアプリをダウンロードしてインストールする。\nArduino - Software Arduinoのシリアルポートの接続先を確認 Arduino IDEを使う方法 まず、Arduino を接続せずに Auduino IDE を立ち上げ、メニューバーの「ツール」-\u0026gt;「シリアルポート」に表示されるデバイスを確認する。\nArduino 接続前のデバイス確認  それからArduinoを接続して再度「ツール」-\u0026gt;「シリアルポート」を確認すると、Arduinoのシリアルポートの接続先を確認できる。\nArduino 接続後のデバイス確認  ターミナルで確認する方法 まず、Arduino を接続しないでターミナルを開いて次のコマンドを実行し、現在接続されているシリアルデバイスを確認する。\n1$ ls -la /dev/tty.* 2crw-rw-rw- 1 root wheel 19, 0 9 25 07:35 /dev/tty.Bluetooth-Incoming-Port 3crw-rw-rw- 1 root wheel 19, 2 9 25 07:35 /dev/tty.iPhone-WirelessiAP-1 次に、Arduino を接続して同じコマンド実行すると、Arduino のシリアルポートの接続先を確認できる。\n1$ ls -la /dev/tty.* 2crw-rw-rw- 1 root wheel 19, 0 9 25 07:35 /dev/tty.Bluetooth-Incoming-Port 3crw-rw-rw- 1 root wheel 19, 2 9 25 07:35 /dev/tty.iPhone-WirelessiAP-1 4crw-rw-rw- 1 root wheel 19, 200 10 10 00:02 /dev/tty.usbmodem14212401 #これが Arduino のシリアルポート Arduino に ArduinoISP スケッチを書き込む メニューバーの「ファイル」-\u0026gt;「スケッチ例」-\u0026gt;「11. Arduino ISP」-\u0026gt;「ArduinoISP」を選択する。\n書き込みスケッチの選択  それから、「スケッチ」-\u0026gt;「マイコンボードに書き込む」を選択して書き込む。\n書き込み実行  これで、Arduino を AVR ライターとして使う準備が整ったことになる。\n必要なバイナリやライブラリのインストール 以下のコマンドで必要なバイナリやライブラリをインストールできる。ただし、Plaid を使うために QMK Firmware をセットアップすれば必要なバイナリ等もインストールされるので、改めてインストールする必要性は乏しい（はず）。\n1$ brew tap osx-cross/avr 2$ brew tap PX4/homebrew-px4 3$ brew update 4$ brew install avr-gcc@8 5$ brew install dfu-programmer 6$ brew install gcc-arm-none-eabi 7$ brew install avrdude 手順 avrdude のインストール 次のコードを実行して avrdude をインストール\n$ brew install avrdude --with-usb avrdude のテスト起動 次のコードを実行して avrdude を実行してみる。\n1$ avrdude 2Usage: avrdude [options] 3Options: 4 -p \u0026lt;partno\u0026gt; Required. Specify AVR device. 5 -b \u0026lt;baudrate\u0026gt; Override RS-232 baud rate. 6 -B \u0026lt;bitclock\u0026gt; Specify JTAG/STK500v2 bit clock period (us). 7 -C \u0026lt;config-file\u0026gt; Specify location of configuration file. 8 -c \u0026lt;programmer\u0026gt; Specify programmer type. 9 -D Disable auto erase for flash memory 10 -i \u0026lt;delay\u0026gt; ISP Clock Delay [in microseconds] 11 -P \u0026lt;port\u0026gt; Specify connection port. 12 -F Override invalid signature check. 13 -e Perform a chip erase. 14 -O Perform RC oscillator calibration (see AVR053). 15 -U \u0026lt;memtype\u0026gt;:r|w|v:\u0026lt;filename\u0026gt;[:format] 16 Memory operation specification. 17 Multiple -U options are allowed, each request 18 is performed in the order specified. 19 -n Do not write anything to the device. 20 -V Do not verify. 21 -u Disable safemode, default when running from a script. 22 -s Silent safemode operation, will not ask you if 23 fuses should be changed back. 24 -t Enter terminal mode. 25 -E \u0026lt;exitspec\u0026gt;[,\u0026lt;exitspec\u0026gt;] List programmer exit specifications. 26 -x \u0026lt;extended_param\u0026gt; Pass \u0026lt;extended_param\u0026gt; to programmer. 27 -y Count # erase cycles in EEPROM. 28 -Y \u0026lt;number\u0026gt; Initialize erase cycle # in EEPROM. 29 -v Verbose output. -v -v for more. 30 -q Quell progress output. -q -q for less. 31 -l logfile Use logfile rather than stderr for diagnostics. 32 -? Display this usage. 33 34avrdude version 6.3, URL: \u0026lt;http://savannah.nongnu.org/projects/avrdude/\u0026gt; Arduino と Plaid を接続する Arduino と ISPポートの接続 Arduino を ISP ライターとして使う場合に Arduino で使うピンと、書き込み先の ATMega328P で使うピンの対応関係は次のとおり。\nArduinoのブートローダー書き込み(2種類) - Qiita    Arduino ATMega328P     10 1(reset)   11 17   12 18   13 19   5V (VCC)   GND (GND)    Plaid の ISP ポートと ATMega328P のピン配置の接続 Plaidの回路図で、基板にあるISPポートの各ピンがATMega328Pのどのピンと接続されているか確認する。確認結果は次のとおり。\nplaid/plaid.pdf at master · hsgw/plaid    Plaid(ISP) ATMega328P     1 18   3 19   4 17   2 (VCC)   5 (RESET)   6 (GND)    なお、Plaid の基板にあるピンの順番は次の写真のとおり。黒い三角（▲）が指し示すピンが1番ピンである。\nPlaid の ISP ポート  Plaid と Arduino の接続 上の2つの表を元に、ArduinoとPlaidを次のとおり接続する。\n   Arduino Plaid     10 5(RESET)   11 4   12 1   13 3   5V 2(VCC)   GND 6(GND)    Avrdudeの読み込みが可能か確認する 次のコマンドを入力して、デバイスIDを読み取る。無事に読み取れれば次のようなメッセージが出力される。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p 2 3avrdude: AVR device initialized and ready to accept instructions 4 5Reading | ################################################## | 100% 0.02s 6 7avrdude: Device signature = 0x1e950f (probably m328p) 8 9avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) 10 11avrdude done. Thank you. 正常に動く Plaid のデータを読み込む 以上の作業により、Plaid に取り付けている ATMega328P のデータを読み取って、新しい ATMega328P に書き込むことができるようになった。\nそのため、次は具体的な作業方法を説明する。\nヒューズビットの読み込み 次のコマンドを入力して、正常に動いている ATMega328P のヒューズビットを読み込んでおく。この値は、新しい ATMega328P に .hex データを書き込んだ後の設定作業で使用する。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U lfuse:r:con:h -U hfuse:r:con:h -U efuse:r:con:h 2avrdude: AVR device initialized and ready to accept instructions 3Reading | ################################################## | 100% 0.03s 4avrdude: Device signature = 0x1e950f (probably m328p) 5avrdude: reading lfuse memory: 6Reading | ################################################## | 100% 0.01s 7avrdude: writing output file \u0026#34;con\u0026#34; 8avrdude: reading hfuse memory: 9Reading | ################################################## | 100% 0.01s 10avrdude: writing output file \u0026#34;con\u0026#34; 11avrdude: reading efuse memory: 12Reading | ################################################## | 100% 0.01s 13avrdude: writing output file \u0026#34;con\u0026#34; 14 15avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) #カッコ内の値がヒューズビットの値 16 17avrdude done. Thank you. hexデータの読み込み 次のコマンドを入力して、正常に動いている ATMega328P に書き込まれているデータを backup.hex ファイルとして読み込む。このファイルを使って、別の ATMega328P に書き込む。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:r:backup.hex:i 2avrdude: AVR device initialized and ready to accept instructions 3Reading | ################################################## | 100% 0.02s 4avrdude: Device signature = 0x1e950f (probably m328p) 5avrdude: reading flash memory: 6Reading | ################################################## | 100% 19.92s 7avrdude: writing output file \u0026#34;backup.hex\u0026#34; 8avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) 9avrdude done. Thank you. 新しい ATMega328P への書き込み 上記の作業で正常に動いてる Plaid のデータは読み込めたので、ここで、Plaid に取り付けてある ATMega328P を取り外す。それから、新しい ATMega328P を取り付ける。\n取り外す前に、Arduino と Plaid の接続を切るか Arduino と PC の接続を切ること。そして、接続を切ったまま取り外しと取り付けを行い、取り付けが完了したら再接続する。\nブートローダの書き込み ブートローダが書き込まれていない ATMega328P を使う場合、ブートローダの書き込みを最初に行う。ブートローダ書き込み済みならこの作業は不要である。\nPlaid のブートローダには USBaspLoader を USB ブートローダとして使用する。そのため、USBaspLoader が必要になるが、Plaid の開発者の hsgw 氏が Plaid 用の USBaspLoader を公開してくれているので、それを利用する。\n1# hsgw氏が作成しているPlaidのブランチをcloneする 2# MasterブランチにPlaid用のファームウェアは存在しないので注意！ 3$ git clone -b plaid https://github.com/hsgw/USBaspLoader.git 続いて、USBaspLoader を ATMega328P に書き込む。\n1$ cd USBaspLoader/firmware 2$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:main.hex:i 3avrdude: AVR device initialized and ready to accept instructions 4Reading | ################################################## | 100% 0.03s 5avrdude: Device signature = 0x1e950f (probably m328p) 6avrdude: NOTE: \u0026#34;flash\u0026#34; memory has been specified, an erase cycle will be performed 7To disable this feature, specify the -D option. 8avrdude: erasing chip 9avrdude: reading input file \u0026#34;main.hex\u0026#34; 10avrdude: writing flash (30878 bytes): 11Writing | ################################################## | 100% 0.00s 12avrdude: 30878 bytes of flash written 13avrdude: verifying flash memory against main.hex: 14avrdude: load data flash data from input file main.hex: 15avrdude: input file main.hex contains 30878 bytes 16avrdude: reading on-chip flash data: 17Reading | ################################################## | 100% 0.00s 18avrdude: verifying ... 19avrdude: 30878 bytes of flash verified 20avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) 21avrdude done. Thank you. hex データの書き込み 次のコマンドを入力して、先ほど読み取った backup.hex ファイルを書き込む。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:backup.hex:i 2 3avrdude: AVR device initialized and ready to accept instructions 4Reading | ################################################## | 100% 0.02s 5avrdude: Device signature = 0x1e950f (probably m328p) 6avrdude: NOTE: \u0026#34;flash\u0026#34; memory has been specified, an erase cycle will be performed 7To disable this feature, specify the -D option. 8avrdude: erasing chip 9avrdude: reading input file \u0026#34;backup.hex\u0026#34; 10avrdude: writing flash (30866 bytes): 11Writing | ################################################## | 100% 33.70s 12avrdude: 30866 bytes of flash written 13avrdude: verifying flash memory against backup.hex: 14avrdude: load data flash data from input file backup.hex: 15avrdude: input file backup.hex contains 30866 bytes 16avrdude: reading on-chip flash data: 17Reading | ################################################## | 100% 18.83s 18avrdude: verifying ... 19avrdude: 30866 bytes of flash verified 20avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) 21avrdude done. Thank you. ヒューズビットの値書き込み 最後に、新しい ATMega328P のヒューズビットに、上記の作業で確認した値を書き込む。\n$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:backup.hex:i avrdude: AVR device initialized and ready to accept instructions Reading | ################################################## | 100% 0.02s avrdude: Device signature = 0x1e950f (probably m328p) avrdude: NOTE: \u0026quot;flash\u0026quot; memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option. avrdude: erasing chip avrdude: reading input file \u0026quot;backup.hex\u0026quot; avrdude: writing flash (30866 bytes): Writing | ################################################## | 100% 33.70s avrdude: 30866 bytes of flash written avrdude: verifying flash memory against backup.hex: avrdude: load data flash data from input file backup.hex: avrdude: input file backup.hex contains 30866 bytes avrdude: reading on-chip flash data: Reading | ################################################## | 100% 18.83s avrdude: verifying ... avrdude: 30866 bytes of flash verified avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) avrdude done. Thank you. 動作確認 ここまでの作業が終わったら、Arduino から Plaid を外し、Plaid と PC を接続して入力テストを行う。\n作業がきちんとできていれば、それまでと同様に Plaid が使えるはずである。\n","date":"2019-10-13","img":"","permalink":"https://s-show.github.io/posts/2019-10-13/","series":null,"tags":["プログラミング","自作キーボード"],"title":"ArduinoとPlaidを使ってマイコンを複製する方法"},{"categories":null,"content":"salicylic-acid3 さんが作成・販売されている自作キーボードのNaked48LED - 自キ温泉街販売所 - BOOTH とSetta21 - 自キ温泉街販売所 - BOOTH を組み立てた際、LED の取り付けで四苦八苦したので、その時にネットで集めた情報や Discord の Self-Made Keyboards in Japan で教えていただいた情報をまとめてみたいと思う。\nLED チップの向きの確認 LED チップが点灯しない時、まず最初に確認するのは取り付けた LED チップの向きである。LED の向きが違えば当然点灯しないし、テスターを使う必要もない簡単な作業なので、まずはここから開始する。\nもし向きが違っていた場合、一度外して再度取り付けることは可能である。しかし、自分の体験から言うと、取り外す時の熱でチップが壊れる可能性があるので、新品に交換した方がトラブルが少ないと思う。\nProMicro の LED の確認 LED チップの向きが正しいことが確認できたら、次はテスターを使った確認に進む…でも間違いでは無いが、テスター無しでもできる確認事項が1つあるので、それも行ってみる。\n方法は、 ProMicro に QMK Firmware を書き込んだ後、基盤に ProMicro を取り付けた上でPCとUSBケーブルで接続し、 ProMicro のLEDが点灯するか確認するというものである。\nProMicro の LED が点灯した場合、 ProMicro から LED に電力を供給する VCC（＋）と GND（ー）はショートしていないことが確認できるので、その場合、次の確認作業に進むことになる。\nテスターによるテスト 続いて、テスターを使って導通を確認する。\n注意事項として、電源を供給しない状態のキーボードにテスターを当てて分かるのは「ショートの有無と基盤内の断線の有無」までで、 LED チップが壊れているか否かは、キーボードに電源を供給した上で、点灯している LED と点灯していない LED を繋いでみないと分からない。\nなので、テスターによる調査で全てが分かる訳では無いが、デバッグ作業では「原因では無いもの」を除外していくことが大事なので、この作業は省略できない。\n基盤内の断線の有無の調査 まずは、基盤内の断線の有無を調べるため、 LED チップに点灯のための電力や制御信号を送信する ProMicro の設置箇所から各 LED チップまでの導通を確認していく。\n基本情報 フルカラーで輝度・色味を制御できる LED チップの場合、電源のVCCとGNDパッドに加えて、輝度・色味を制御するための DIN と DOUT のパッドがある。それぞれのパッドの位置関係は次の図のとおり（SK6812miniデータシートより） 。\nSK6812mini のパッド  また、 ProMicro のピン毎の説明は次の図のとおり（製造元の SparkFunのWebページ より）。\nProMicro のピン配置  VCC ラインの導通確認 LED チップを点灯させる電力は ProMicro のVCCから供給されるので、基盤に ProMicro を取り付けた際にVCCのピンが刺さるスルーホールにテスターの電極の片方を当て、もう片方を各 LED チップのVCCに当てる。これを全ての LED チップに対して行っていく。 もし、ここが導通していなければ、基盤内部の電源供給ラインが断線している可能性が考えられる。\nGND ラインの導通確認 ProMicro のVCCから供給された電力はGNDに戻るので、VCCラインを調査した時と同様に、GNDのピンが刺さるスルーホールにテスターの電極の片方を当て、もう片方を各 LED チップのGNDに当てていく。\nGNDは複数のピンがあるので、どれが LED チップと接続しているかは、試行錯誤して確認するしかない。\nDIN ラインの導通確認 LED チップの制御信号を送信する DIN ラインも確認するが、 ProMicro のどのピンから制御信号が出ているかはキーボードによって異なる。\n私が調べたところ、制御信号の出力ピンは config.h ファイルの #define RGB_DI_PIN で定義される1ので、そこを確認する。 ちなみに、QMK-Firmwareのディレクトリで grep -r \u0026quot;#define RGB_DI_PIN\u0026quot; keyboards | cut -d \u0026quot;:\u0026quot; -f 2 | cut -d \u0026quot; \u0026quot; -f 3 | sort | uniq -c | sort -nr | awk -F, '{ sum += $1 } END{ print sum }' コマンドを実行したところ、一番多かったピンはD3（88件）で、二番目のE2（39件）の2倍以上であった。\n何番のピンから制御信号が出力されているか確認できたら、これまでと同様に確認する。\nただし、LEDの制御信号は、 ProMicro から最初のこの方法で確認できるのは、「 ProMicro が送信した制御信号が通るラインが断線していないか」であって、「 LED チップ間のデータ送信の成功・不成功」は、次の方法で確認することになる。\nDOUT ラインの確認 LED チップの制御信号を次の LED チップに送信するのが DOUT になるが、これだけは ProMicro と繋がっていない。\nその代わり、1番目の LED チップの DOUT は2番目の LED チップの DIN に繋がり、2番目の LED チップの DOUT は3番目の LED チップの DIN に繋がり…という連結が繰り返されている。ただし、最後の LED チップの DOUT はどこにも繋がらない形になる。\nそのため、 DOUT については、 ProMicro との接続ではなく、次の LED の DIN との接続を確認することになるが、電源を接続して確認する方が視覚的に分かりやすいので、確認方法は次で述べる。\nLED チップ間の導通確認・ LED チップの故障の調査 まず、作者のウェブサイトなどで、自分が組み立てているキーボードの LED の順番を確認する。続いてキーボードに電気を供給するため、キーボードをPCに接続する。私が組み立てた Setta21 の場合、次の順番となっている。\n(自作テンキーキット『Setta21』ビルドガイド - 自作キーボード温泉街の歩き方より) Setta21 の LED の接続順  それから、点灯していない LED の一つ前にある点灯している LED の DIN と、点灯していない LED の DIN をジャンパワイヤーなどで接続する。(@mteiさんのツィートより) DINとDOUTの接続確認  もし、この方法で点灯していない LED が点灯した場合、点灯している LED の DOUT が壊れているので、点灯していてもその LED チップは交換しないといけない。\n一方、この方法でも点灯していない LED が引き続き点灯しない場合、点灯していない LED は壊れていると思われるので、交換する必要がある。\n何だかまどろっこしい確認方法であるが、 LED チップが壊れているか否かは、点灯のための電力を供給している状態で、 DIN に制御信号を送り込んで点灯するかどうかで調べるしか無い模様なので、面倒でもこの方法で進めるしか無い。\nまとめ 以上の内容が、私が調べたり教えていただいた情報を自分なりにまとめたものである。\nプログラミングのデバッグ作業とは異なり、「点灯しない」というメッセージ以外のエラーメッセージが表示されないので、骨が折れる作業である。\nその分、全部の LED が点灯した時はとても嬉しいので、この記事が誰かの参考になれば幸いである。\n 本記事の執筆で参考にした記事\n m.tei / ishiiさんのツイート  コルネキーボードを作りました ～LED取り付けに四苦八苦記～ | キオクノロンダリング  QMK Firmware でオリジナルキーボードのファームウェアを作成する - Qiita  DiscordのSelf-Made Keyboards in Japanサーバで教えていただいた方々の投稿     Config Options - QMK Firmware のRGB Light Configurationにて確認した。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2019-07-22","img":"","permalink":"https://s-show.github.io/posts/2019-07-22/","series":null,"tags":["プログラミング","備忘録","自作キーボード"],"title":"自作キーボードでLEDが点灯しない時のテスト方法と対処方法"},{"categories":null,"content":"前置き 自作キーボードキットのErgoDashを組み立てて日々使っているが、以下のページで紹介されている方法を使って、Raise/Lowerキーを「単独で押せば変換/無変換 or かな/英数、他のキーと組み合わせて押せばRaise/Lower」となるように設定して使っている。\nQMK Firmware で Raise/Lower と変換/無変換を同じキーに割り当てる MacOSは「かな/英数キー」でIMEのオン/オフが切り替えられ、Windowsも、enthumbleというアプリを使えば「変換/無変換キー」で同じことができるので、こうした設定を行なっている。\nMacOSではこの設定で問題なくIMEを切り替えられたのだが、Windowsで同じことを実現しようとした時に思いっきりつまづいてしまった。\n試行錯誤の末に、WindowsでもIMEをMacOSと同様に切り替えられるようになったのだが、そのときの知見を備忘録代わりにまとめておこうと思う。\nenthumbleとは？ 前置きでも少し触れているが、Windowsで出番がほとんどない無変換キーをFnキーの代わりとして使うことで、「無変換-HJKL」でカーソル移動、「無変換-スペース」でEnterキーを入力、「無変換-S」でCtrl-Sを入力、といった機能に加えて、変換/無変換キーをIMEのオン/オフのキーとして使えるようにするアプリである。\nenthumble Readme 【説明書】 - Qiita 自作キーボードを使う前から重宝していたアプリなのだが、自作キーボード導入後はしばらくWindowsPCを操作していなかったので、自作キーボード導入後の最初のWindowsPC操作の時点で、変換/無変換キーをIMEの切り替えに使えないという問題に遭遇してしまったのである。\n最初の悪戦苦闘 enthumbleを入れても変換/無変換キーをIMEのオン/オフキーとして使えなかったので、まずは、本当に変換/無変換がWindowsに送信されているのか調べることにした。\n調査では、まず、Change Key というキーボードカスタマイズソフトのキーコード調査機能を使ったのだが、以下のスクリーンショットのとおり、ちゃんと変換/無変換キーが送信されているという結果が出てきた。\n変換/無変換キーが送信されているのは確認できたので、Raise/Lowerキーを「単独で押せば変換/無変換、他のキーと組み合わせたらRaise/Lower」という設定がきちんとできていることは確認できたのだが、それでもenthumbleが動作しない理由が分からなかった。とりあえず、enthumbleを再インストールしたりWindowsを再起動したりといった定番の作業は行ったが、一向に問題が解決しない。\nここで、enthumbleを使うことは諦めて、キーボードカスタマイズソフトのAutoHotkey を使うことにした。\nAutoHotKeyとは？ AutoHotKeyは、元々はキーボードカスタマイズソフトとして開発されていたが、ユーザーの要望を取り入れながら開発しているうちに、Windowsの動作制御までできるようになったソフトである。\n本当に多機能なソフトで、\n アプリ毎に自分用のショートカットキーを作る 変換/無変換キーをIMEの制御キーする アプリ操作を自動化 GUIフォームを備えたアプリを作成する  といった具合に、とにかく色んなことができるようになるソフトである。\n[AHK基礎] AutoHotkeyはどんな言語か - ITジョー RPA（ロボテックプロセスオートメーション）なくても、AutoHotKeyでPC入力自動化できますが何か？ - ノリックのIT生産性向上、ライフハック、プロマネのお仕事備忘録 Windows で簡単な GUI ラッパーアプリを作るなら AutoHotkey が良さそうという話 - Qiita Auto Hot Keyで簡単にGUIフォームアプリを作る | 読書とプログラミングを中心とした覚書ブログ また、書いたスクリプトを.exeファイルにコンパイルすることもできるので、自作の設定を他人に使ってもらうことも可能である。ちなみに、enthumbleもAutoHotKeyで作成されている。\nただし、様々なことができるとはいえ、自分でスクリプトを書かないといけないので、マウスでぽちぽちクリックすればOKと言う訳ではない。とはいえ、自分用のショートカットキーを作ったり、IMEの制御を「全角/半角」キー以外で行うと言うレベルであれば、そこまで難しいものではない。\nというわけで、AutoHotKeyの使い方を簡単に紹介するとともに、私が行っている設定も紹介したいと思う。\nAutoHotKeyの使い方 詳しい使い方については、ネットを検索すれば優れた先人の解説がいくつも見つかるので、本記事では基本的な部分に絞って解説する。\nAutoHotkeyのチュートリアルを読んだ - もうカツ丼はいいよな Autohotkeyに関する記事で1万字超えの記事を書き、 Google からの検索流入が一か月後に増加するかどうかを確認しつつ、タイトルはやっぱり長い方が良いのかも検証する - ノリックのIT生産性向上、ライフハック、プロマネのお仕事備忘録 AutoHotkey Wiki AutoHotKeyの使用方法 基本的な構文 AutoHotKeyでMyショートカットキー（AutoHotKeyではホットキーと呼ぶ）を作成する場合、*.ahkという拡張子の設定ファイルにホットキーを割り当てるキー::という形でコードを書く。こう書くことで、AutoHotKeyではサブルーチンのラベルとして認識され、指定のキーを押すと、ラベルの次の行以降に処理が移り、ReturnかExitが実行されるまで処理が続けられる。\nなお、/* ~ */という構文はコメントである。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; example2: Alt-Qの2連打でアプリを閉じる ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ ~!q:: Input, inputText, I L1 T0.5, !q IfInString, ErrorLevel, EndKey: { Send, !{F4} } Return なお、割り当てる処理が1行で足りる場合、以下のコードのようにReturnを省略できる。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; example1: Ctrl-Alt-Rでこのスクリプトを再読み込みする ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ ^!r::Reload ホットキーの指定方法 ホットキーを指定するには、こちらに掲載されている キーリストに沿って指定するが、基本的に、アルファベットキーは印字通り（大文字小文字は不問）指定すればOKである。BackSpaceやReturnなどのキーも、基本的にキーの印字通りでOKである。\n一方、変換/無変換のような一部のキーは、vkXX(仮想キーコード)かscYYY(スキャンコード)というキーコードで指定する必要がある。キー毎の具体的なコードは、上記のリンク先を参考にするか、AutoHotKeyのキースキャン機能で確認できる。\nなお、注意事項として、ネットではvkXXscYYYという指定方法が散見されるが、この方式は、2017年12月25日にリリースされたバージョン1.1.27.00で*.ahkスクリプトのバリデーションが変更されたことにより、現在ではエラーとなる。そのため、現在はvkXXかscYYYと指定する。\nCtrlやAltキーなどのモディファイヤキーと組み合わせるホットキーを指定する際は、以下の表に示したコードと組み合わせて指定する（例: ^j）。上の設定例の^!rは\u0026quot;Ctrl-Alt-R\u0026quot;という組み合わせを指定している。\n   キー名 説明     + shift   ^ control   ! alt   # windows    なお、上の設定例の~!q::の行頭にある~は、押したキーをそのままシステムに通すという設定である。この例で言えば、\u0026ldquo;Alt-Q\u0026quot;というキーをAutoHotKeyで受け取った後システムにも渡すという設定である。\n変数と条件分岐 変数 変数は、事前の宣言不要でMyVar = 123abcの形で値を代入できる。また、変数の値の展開はMsgBox, MyVar is %MyVar%のように%で囲めばOKである。\nなお、関数の返り値を変数に代入する際は、MyVar := function()のように、=ではなく:=とする必要がある。\n参考\n スクリプト仕様 - 変数 - AutoHotkey Wiki   条件分岐 If文による条件分岐が可能であり、ElseでIfの条件に当てはまらない場合の処理が指定できる。その場合、Elseの後にIfを追加して細かい条件分岐を行うことも可能である。\nIf MyVar \u0026gt; 10000 MsgBox,\u0026quot;たくさん\u0026quot; Else If MyVar \u0026gt; 1000 MsgBox,\u0026quot;多い\u0026quot; Else MsgBox,\u0026quot;そこそこ\u0026quot; If文による条件分岐は、「等しい、以上・以下、超・未満」のような判定に加えて、指定した文字列が含まれているか、変数のデータ型が特定の型に等しいか、という判定も可能である。\n参考\n スクリプト仕様 - 条件分岐 - AutoHotkey Wiki   設定ファイルの分割 AutoHotKeyの設定は*.ahkファイルに書いていくが、全ての設定を1つのファイルに書く必要はなく、複数の*.ahkファイルに書くことが可能である。設定が増えた際の管理の手間を考えると、アプリ毎の設定ファイル、Windows全体で適用する設定ファイルのように、目的別で分けた方が良いと思う。\n私の場合、IME関係(IME-setting.ahk)、アプリ毎の設定(settings-for-each-app.ahk)、その他の設定(misc-setting.ahk)の3つに分けて管理しており、その3つのファイルをmy_keybind.ahkで以下のとおり読み込んでいる。なお、1行目では各設定で使うIME.ahkを読み込んでいる。ここで読み込むと、それぞれの設定ファイルでは改めて読み込む必要がなくなる。\n#Include %A_ScriptDir%/IME.ahk #Include %A_ScriptDir%/IME-setting.ahk #Include %A_ScriptDir%/settings-for-each-app.ahk #Include %A_ScriptDir%/misc-setting.ahk Return 実際のファイルを確認したい人は、私のGitHubのリポジトリ を確認して欲しい。\n参考\n #Include / #IncludeAgain - AutoHotkey Wiki   具体的な設定 AutoHotKeyの各機能を1つ1つ説明すると非常に長くなるし、そもそも「まずホットキーを指定し、そのホットキーに処理を割り当てる」というスタイルで設定していくアプリなので、これ以降は具体的な設定を逐一解説することで、AutoHotKeyの使い方を説明するという流れにする。\nIMEのオン/オフの切り替え 最初は、上記のとおり悪戦苦闘したIMEのオン/オフの切り替えから。\nキーコードの指定でつまずいたが、以下のコードで望み通りの動作を実現することができた。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Title: 変換/無変換でIMEをオン/オフする ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ SC079::IME_SET(1) SC07B:: if IME_GetConverting() \u0026gt;= 1 { Return } else { IME_SET(0) } Return この設定で使用しているIME_SET()関数とIME_GetConverting関数は、前述の「設定ファイルの分割」の1行目（#Include %A_ScriptDir%/IME.ahk）で読み込んだIME.ahkで定義されている。IME周りの制御では必須の関数が定義されているスクリプトファイルなので、IME制御を行うなら必ずダウンロードすることになる。\nスクリプトを解説すると、6行目で\u0026quot;変換\u0026quot;キーをホットキーに、7行目で\u0026quot;無変換\u0026quot;キーをそれぞれホットキーに指定している。\n変換/無変換キーはキーコードを使ってホットキーに指定する必要があるので、上記の設定を行う前にキーコードを調査した。調査画面は次のとおりである。\n調査結果  ここで、変換キーのスキャンコード(SC)が079、無変換キーのスキャンコードが07Bだと分かるので、SC079、SC07Bと指定した。そのうえで、変換キーにIMEオンの機能を割り当てるため、IME.ahkに定義されているIME_SET関数を使用した。IME_SET(1)でIMEをオンに、IME_SET(0)でオフにできる。\n次に、無変換キーにIMEオフの機能を割り当てるが、私のErgoDashでは、無変換キーがスペースキーの隣の親指担当の場所にあるため、スペースキーと間違えて無変換キーを押すことがしばしばあった。そのため、IMEオンで入力しているときは、無変換キーを押してもIMEをオフにしない設定にした。\nそのため、IME_GetConverting関数でIMEの状態を確認し、返り値が1以上（IMEオンで入力中 or 変換中）なら、何もしない（Returnで処理終了）設定にし、それ以外の場合（IMEオンだが入力していない）にIME_SET(0)関数を実行してIMEをオフにする設定にした。\nなお、IME_GetConverting関数でIMEの状態が取得できるのは、インラインで入力が行われないアプリだけである。そのため、WordやNotepadのようにインラインで入力が行われるアプリでは、IMEの状態が取得できないので、入力中はIMEをオフにしないという細かい調節はできない。\n参考\n IME制御 - eamat @Cabinet - アットウィキ   補足 ちなみに、上記で調査した変換/無変換キーのスキャンコードは、市販のJISキーボードでも同じである。しかし、仮想コードはErgoDashと市販のキーボードで異なっている。\nキーの指定は、スキャンコードか仮想コードで行うので、enthumbleは、スキャンコードではなく仮想コードで指定しているか、それともvkXXscYYYという組み合わせで指定しているのではないかと思う。そのため、ErgoDashでは動作しなかったのではないかと思う。\n   仮想キーコード 変換 無変換     ErgoDash FF EB   市販品 1C 1D    IME関連の他の設定 これで最大の懸念であったIMEの切り替えが実現できたが、変換キーにIMEオンの機能を割り当てたので、本来の変換キーが無くなっている。誤入力した箇所にカーソルを置いて変換キーを押すと再変換できる機能は便利なので、Ctrl-BackSpaceに変換キーの機能を割り当てることにする。\nBS::Send, {vk1C} BSはBackSpaceの指定（BackspaceでもOK）で、Sendは、引数に指定したキーをシステムに送信するコマンドである。vk1Cは変換キーの仮想キーコードなので、\u0026ldquo;Ctrl-BackSpace\u0026quot;を押すと変換キーが送信されるという動作になる。\n参考\n Send / SendRaw / SendEvent / SendInput / SendPlay - AutoHotkey Wiki   アプリ毎の設定 AutoHotKeyでは、アプリ毎に設定を行うことも可能である。\n次の例は、Excelで行（列）選択のショートカットキーのShift(Ctrl)-SpaceをIMEオンでも動作させるというものである（このショートカットキーはIMEオンだと動かない）。キーボードでExcelを操作するときに必須のショートカットキーなので、IMEオンでも動作するようにする。\n#ifWinActive ahk_exe EXCEL.EXE $^Space:: if (IME_GET()) { IME_SET(0) Sleep 30 Send,^{Space} Sleep 30 IME_SET(1) } else { Send,^{Space} } Return $+Space:: if (IME_GET()) { IME_SET(0) Sleep 30 Send,+{Space} Sleep 30 IME_SET(1) } else { Send,+{Space} } Return #ifWinActive IME_GET関数やIME_SET関数は、上記のIME関連の設定で説明したとおりIME.ahkで定義されているものである。\n1行目の#ifWinActiveは、特定のウィンドウがアクティブの時だけ実行するというコマンドである。ウィンドウの指定はウィンドウタイトルやウィンドウクラスで行うが、ウィンドウタイトルで行うのが簡単だと思う。\nウィンドウタイトルの確認は、AutoHotKeyに備わっている「Window Spy」という機能を使うのがベストである。Window Spyは、右下のタスクトレイにあるAutoHotKeyのアイコンを右クリックしたメニューにあるので、そこから起動する。起動した後の操作方法は以下のスクリーンショットのとおり。\n2行目の$^Space::は、\u0026ldquo;Ctrl-Space\u0026quot;というホットキーを指定するものであるが、行頭に$をつけているのは、\u0026ldquo;Ctrl-Space\u0026quot;をAutoHotKeyで強制的にフックするためである。システムが使うショートカットキーを上書きする場合に必要となる。\n3行目のif (IME_GET())は、IME_GET()の返り値が1、つまりIMEがオンになっているという条件式である。AutoHotKeyは、数値が0ならfalse、それ以外の数値はtrueと処理するので、こういうコードでOKとなる。\n5〜9行目はIMEがオンの場合の処理であるが、まず、5行目のIME_SET(0)でIMEをオフにし、続いて6行目のSleep 30で30ミリ秒処理を中断する。この中断処理を除くとIMEオンの状態で\u0026quot;Ctrl-Space\u0026quot;を入力したのと同じ動作になるので、中断処理を行っている。なお、30ミリ秒より短いと上手くいかない。\nそれから7行目のSend,^{Space}で\u0026quot;Ctrl-Space\u0026quot;を送信し、8行目のSleep 30で再び処理を中断している（この中断処理を省略しても上手く動作しない）。\nそして、9行目のIME_SET(1)でIMEをオンに戻している。\n11行目のelseは、IMEがオフの場合の分岐で、この場合は、単純に13行目のSend,^{Space}で\u0026quot;Ctrl-Space\u0026quot;を送信している。\n17行目の$+Space::は、\u0026ldquo;Shift-Space\u0026quot;というホットキーを指定するものである。以降の設定はこれまでと同じなので、省略する。\nなお、Excelについては、次のような設定も行なっている。説明の都合上2つに分けているが、実際の設定ファイル では、#ifWinActiveを除いた部分を上記のコードの続きに書いている。\n#ifWinActive ahk_exe EXCEL.EXE $F1::Return $+F1::SendInput, {F1} #ifWinActive 2行目の$F1::Returnは、\u0026ldquo;F1\u0026quot;キーを無効化する設定である。以前使っていたキーボードで、F1キーがEscキーの隣にあるためにEscとF1をの押し間違いが頻発していたので、思い切ってF1を無効化したのである。特定のキーを無効化する場合、無効化したいキー::Returnとすることで、そのキーを無効化できる。\nなお、F1キーを無効化したが、ヘルプを見たい時があるかもしれないので、$+F1::SendInput, {F1}で\u0026quot;Shift-F1\u0026quot;に元々のF1を割り当てている。\n参考\n IfWinActive / IfWinNotActive - AutoHotkey Wiki   キー２連打への割り当て キー２連打への割り当て方法は２通りあるので、それぞれ紹介する。\n方法１（モディファイヤキーが無い場合） CtrlやAltなどのモディファイヤキーと組み合わせないキーの２連打の場合、AutoHotKeyの組み込み変数を使うことで簡単に２連打の設定ができる。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Title: テンキーのピリオド2連打でカンマ入力 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ ~NumpadDot:: If (A_PriorHotKey == A_ThisHotKey and A_TimeSincePriorHotkey \u0026lt; 200) { SendInput, {BackSpace 2} Send,{U+002c} } Return 上記のコードを解説すると、まず、~NumpadDot::でテンキーの\u0026rdquo;.\u0026ldquo;をホットキーに指定している。行頭に~を追加しているので、\u0026rdquo;.\u0026ldquo;の入力はシステムにも渡されて\u0026rdquo;.\u0026ldquo;が入力される。\nそして、7行目のIf (A_PriorHotKey == A_ThisHotKey and A_TimeSincePriorHotkey \u0026lt; 200)は、組み込み変数を使って、「前回入力されたホットキーと今回のホットキーが同じ」かつ「前回のホットキー入力から今回のホットキー入力までの時間が200ミリ秒未満」という条件文を組み立てている。\nA_PriorHotKey変数には前回押されたホットキー、A_ThisHotKey変数には今回押されたホットキーが格納されているので、2つの変数が等しければ同じホットキーを2回連続で入力したと判断できる。そして、A_TimeSincePriorHotkey変数には、前回のホットキー入力から今回のホットキー入力までの時間がミリ秒単位で格納されているので、この変数の値が200未満なら２連打したと判断している。\nつまり、最初の\u0026rdquo;.\u0026ldquo;入力では、7行目のIf文の条件が必ず満たされず最後のReturnコマンドに直行し、2回目の\u0026rdquo;.\u0026ldquo;入力で7行目のIf分の条件が満たされて、次のSend~の処理に移るという訳である。\nそして、この段階までに2回入力されている\u0026rdquo;.\u0026ldquo;を削除するため、SendInput, {BackSpace 2}コマンドでBackSpaceを2回入力している。それからSend,{U+002c}コマンドで\u0026rdquo;,\u0026ldquo;を入力している。なお、{U+002c}は、\u0026rdquo;,\u0026ldquo;のUnicodeの文字コードである。わざわざUnicodeの文字コードで指定している理由は、Send,{,}だとIMEがオンの場合に全角の\u0026rdquo;、\u0026ldquo;が入力されてしまうためである。\n参考\n 組み込み変数 - AutoHotkey Wiki  If (式)  Unicode文字一覧表 - instant tools   方法２（モディファイヤキーがある場合） CtrlやAltなどのモディファイヤキーと組み合わせたキーの２連打の場合、上記より面倒になる。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Title: Alt-Qの2連打でアプリを閉じる ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ ~!q:: Input, inputText, I L1 T0.5, !q IfInString, ErrorLevel, EndKey: { Send, !{F4} } Return 最初に掲載した設定例の再掲であるが、解説すると、まず~!q::で\u0026quot;Alt-Q\u0026quot;をホットキーに指定している。\nそして、Inputコマンドで最初の\u0026quot;Alt-Q\u0026quot;に続くキー入力を横取りして、inputText変数に格納している。\nInputコマンドのI L1 T0.5という引数は、「AutoHotKeyが生成したキー入力は無視、入力を受け付けるキーの長さは1文字、キー入力を待つ時間は0.5秒以内」という条件を指定するもので、!qという引数は、「\u0026ldquo;Alt-Q\u0026quot;が入力されたらコマンドを終了して次の行に進む」という条件を指定するものである。\nその次のIfInString, ErrorLevel, EndKey:は、「ErrorLevel変数にEndKey:という文字列が含まれているか」という条件文である。\nInputコマンドの待ち時間（0.5秒）以内に\u0026quot;Alt-Q\u0026quot;が押されたら、ErrorLevel変数にEndKey:!{q}という値が格納され、0.5秒以内に\u0026quot;Alt-Q\u0026quot;が押されない場合はTimeoutという値が格納されるので、EndKey:が含まれていれば「Alt-Qが２連打された」と判断できる。\nそのうえで、Send,!{F4}で\u0026quot;Alt-F4\u0026quot;キーを送信してアプリを終了させている。\n参考\n Input - AutoHotkey Wiki  IfInString - AutoHotkey Wiki   クリップボードを活用 クリップボードを活用することで、選択した文字列を\u0026rdquo;(\u0026ldquo;や\u0026rdquo;[\u0026ldquo;や\u0026rdquo;#\u0026ldquo;で囲むということも可能になる。なお、このコードだけ Gist から引っ張っている理由は、コードの「Send,{{}」の {{} が Hugo のビルド時に文法エラー扱いされてビルドが中断されるのを避けるため。\n 8行目のbackup = ClipboardAllは、その時点でクリップボードに格納されているデータをbackup変数に退避させる処理である。ClipboardAll変数は組み込み変数で、クリップボードのデータを読み取る際に使用する。\n9行目のClipboard =は、クリップボードを空にする処理である。Clipboard変数も組み込み変数で、クリップボードの中身を書き換える際に使用する。\n10行目のSend, ^cで、\u0026ldquo;Ctrl-C\u0026quot;をシステムに送信して選択中の文字列をコピーするが、コピー失敗に備えて、11行目にClipWait, 1という処理を挟んでいる。ClipWaitコマンドは、引数で指定した秒数の間待機し、時間内にコピーが成功すればその時点でErrorLevel変数に0を格納する。そのため、ErrorLevel変数の値でコピーが成功したか否かが確認できるようになる。\n12行目はIME_GET()関数で現在のIMEの状態を変数に格納している。この処理はSendコマンドで囲み文字を入力する方法なので、囲み文字を確実に半角入力するため、一度IMEをオフにする必要がある。そのため、処理実行前のIMEの状態を取得している。なお、関数の戻り値を変数に格納する際は:=で代入する必要がある。\n15行目のInput, inputText, I L1 T1,{Esc}, (,[,\\`{,',\u0026quot;,`,-,_,=,`%,`#,`*, ,|は、前述のInputコマンドを使って、\u0026ldquo;Ctrl-,\u0026ldquo;の次に入力された文字が( [ { ` - _ = % # | 半角スペースだった場合に、その文字をinputText変数に格納している。なお、{ ` # % *はAutoHotKeyで特別な意味のある文字であることから、これらの文字を指定する際は`でエスケープ処理する必要があり、また、半角スペースは条件式の途中（この例では|の前）に書かないと認識されないという2点に注意が必要である。\n16行目のIf ErrorLevel = Matchは、Inputコマンドで(,[,\\`{,',\u0026quot;,`,-,_,=,`%,`#,`*, ,|が入力されていればErrorLevel変数にMatchが格納されているので、それを分岐条件にしている。\nあとは、18行目のIME_SET(0)でIMEをオフにして、入力された文字に応じた分岐を18行目以降のIf inputText =で行い、\n 入力された文字をSendコマンドで送信 Send,^vコマンドでクリップボードの文字を貼り付け 再び入力された文字をSendコマンドで送信  という処理を行うことで、選択した文字列を指定した文字で囲むという動作を実現している。\n工夫が必要な点は、まず、(,[,\\`{は、対になる),],\\`}とセットで囲む必要があることから、この3つのカッコは個別に分岐条件を設定している。そのほかの囲み文字については、同じ文字を2回入力すればOKである。\nまた、半角スペースはIf inputText = \u0026quot; \u0026quot;のような条件判定がどうやってもできなかったので、指定した変数のデータ型で判断するif inputText is typeを使って、inputTextが半角スペース（タブもOK）か否かによる条件判定を行なった。\nそのほか、なぜか#は個別に条件判定を行う必要があったので、やむなく個別に判定している。\nそれ以外の囲み文字については、まとめて最後のElse節で処理している。\n最後に、IMEの状態を処理前に戻して動作完了である。\n参考\n If var is [not] type - AutoHotkey Wiki   設定ファイルの再読み込みを簡単に 設定ファイルを編集した場合、右下のタスクトレイにあるAutoHotKeyのアイコンを右クリックして「Reload This Script」をクリックする必要があるが、非常に面倒な作業なので、設定ファイル再読み込みのショートカットキーを作成する。\n/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Title: Ctrl-Alt-Rでこのスクリプトを再読み込みする ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */ ^!r::Reload 最初の方で紹介した設定例の再掲であるが、^!rで\u0026quot;Ctrl-Alt-R\u0026quot;をホットキーとして指定し、現在実行中の設定ファイルの再読み込みを行うReloadコマンドを割り当てている。\n参考\n Reload - AutoHotkey Wiki   ","date":"2019-06-18","img":"","permalink":"https://s-show.github.io/posts/2019-06-18/","series":null,"tags":["プログラミング","備忘録"],"title":"AutoHotKeyの解説と自分の設定について"},{"categories":null,"content":"前置き メルカリで売りに出ていた「Macbook pro, 2011Early, 15インチ」を購入して、さらにメモリを16GBに増強して快適な環境を構築しようとしたら、メモリ交換後に電源ボタンを押しても反応がないというまさかの事態に陥ってしまった。何とか蘇らせることができてこの記事を書けるまでになったので、同じ症状に遭遇した人のために、顛末を書いてみたいと思う。\n経緯（購入まで） それまで使用していたMacbook pro(2015, 13インチ)は、持ち歩きも考慮して13インチにしたものの、据え置きで使うことが多く、また、据え置きで使うべく外付けディスプレイやキーボードを接続しているので、外に持ち出す都度、ケーブル類や電源の着脱が手間になっていた。\nそこで、もし、安価な15インチのMacbook proがあればそれを据え置き機にして、既存の13インチは持ち歩き専用にしようと思い立ち、メルカリで探したらちょうど良い商品があったので、Amazonで16GBのメモリを購入するのと合わせて、早速購入した。\n経緯（商品到着からメモリ交換実施まで） メルカリで購入したMacとAmazonで購入したメモリが同時に届いたので、まずはMacの起動確認を行い、ちゃんと起動することを確認したら、出品者を評価してからMacの電源を落とした（後述するが、多分この時に、間違えて電源オフではなくスリープにした可能性がある。） それから、以下のページを参考にしてメモリを交換して、上手くいったか確認するために電源ボタンを押した。 MacBook Pro：メモリの取り外し方法と取り付け方法 - Apple サポート ・・・全く反応がない。。。\n一体何が起きたか分からなかったが、交換したメモリに不具合があるかと思い、元から取り付けられていたメモリに戻して電源ボタンを押す。\n・・・さっきと同じように全く反応がない。。。\nここまで来て事態の深刻さに気付き、対処策を探すことになる。\n経緯（試行錯誤の過程） まずはネットで同様の症状に遭遇した人がいないか検討するが、電源が入らなくなった時の対処方法は見つかるものの、メモリ交換で電源が入らなくなった事例は見つからなかった。\n仕方なく、NVRAMのリセット やSMCのリセット を試すものの、全く事態は改善されない。\n最初のトラブルの時にNVRAMリセットを行っても復旧しなかったが、３時間後にリセットしたら復旧したという記事も見つけたので、２時間ほど経ってからリセットしてみるが、反応が無い状態は全く変わらない。\n対象方法を探す中で地元の修理ショップの存在を発見するが、ロジックボードの修理費が３〜６万円とあるのを見て、これだけ出すなら諦めた方が安上がりかなという考えも浮かんでくる。\nまた、この辺りになると、最初の起動確認をした後、いつもの癖で電源オフではなくスリープを選んでしまい、その状態でメモリ交換をしてしまったのではないかという嫌な予感がして来てしまい、さらに気が滅入ることになる。\nとはいえ、あれこれ作業をしていると夜遅くになってしまったので、仕方なくその日はそれ以上の作業を諦めて寝ることにした。\n経緯（復旧まで） 次の日は朝から用事があったため、夕方に帰って来てから作業に取り掛かった。\n昨日、スリープ状態でメモリ交換をしてしまった可能性を考えていたので、一度完全に電源オフにした上で、あらためてNVRAMリセットとかしたら復旧するのはないかと思い、バッテリーを取り外すことにした。 以下のページを見ながらバッテリーを取り外し、その状態で一度電源ボタンを押して内部の電気を完全に放出したうえで、２時間ほど待つことにした。 MacBook Pro 15\u0026quot; Unibody Early 2011 Battery Replacement ２時間待ったところで、バッテリーを取り付けて電源ボタンを押したところ、DVDドライブへのアクセス音が聞こえてMacの起動音が鳴り、少ししてからMacが無事に起動した。この時は本当にホッとしたのを覚えている。\nMacが無事に起動するのを確認したが、内部時計がおかしくなっていたのと、一度リセットした方が良いと判断して、あらためて電源オフにしてから、NVRAMリセットを行ったところ、内部時計もちゃんとした日時になった。動作にも問題がないので、\n SMCリセット OSをOS X LionからHigh Sierraにアップグレード 外付けHDDにバックアップしたTimeMachineのデータを使用して環境を移行  の作業を行い、こうしてブログ記事を書けるまでの環境構築に成功した。\nまとめ トラブルの原因は、起動確認後に間違えて電源オフではなくスリープを選んでしまっていて、それに気づかないままメモリ交換に着手してしまったことではないかと思う。OSのアップデートでもない限り、電源オフではなくスリープを選んでいるので、その癖でスリープを選んでいたのではないかと思う。\n電源ボタンを押しても反応が無い時はNVRAMのリセットもできないので、こういう時はダメ元でバッテリーを外して完全に電源オフにし、その状態をしばらく続けた後にリセットすると直るかもしれない。 この記事が誰かの役に立てば幸いである。\n蛇足 元々使っていたMacbook proの環境を移行するため、外付けHDDにTimeMachineでデータをバックアップして移行したが、アプリやデータに加えて各アプリの設定まで自動的に移行されるのには驚いた。新しいMacで行う必要があった作業は、Homebrewを使うためにXcodeをインストールすることだけで、Karabiner-Elementsの設定も1Passwordの設定もそのまま移行されたので、環境移行は拍子抜けするほど簡単だった。\nただ、買った直後のOSがOS X Lionだったが、このOSには２ファクタ認証の機能がないので、iCloudの設定などでIDとパスワードを入力しても、確認コードを入力する画面が表示されず随分と困った。\nこの問題には、パスワードの後に確認コード６桁を入力すれば対処できる。具体的には、まず、IDとパスワードを一度入力し、手持ちのiPhoneなどに確認コードが表示されたら、再度IDとパスワードを入力し、そのパスワードの後ろに確認コード６桁を入力すれば認証される。 Mac OSでApple IDの確認コード画面が表示されない場合の対応方法 | 好きな音楽をいい音で ","date":"2018-05-22","img":"","permalink":"https://s-show.github.io/posts/2018-03-22/","series":null,"tags":["Mac","備忘録"],"title":"Macbook Proでメモリ交換して電源が入らなくなってから復活するまでの経緯"},{"categories":null,"content":"  日本軍兵士―アジア・太平洋戦争の現実 (中公新書)  amazon.co.jp    太平洋戦争において、日本軍が補給をおろそかにしたことで前線の兵士が塗炭の苦しみを味わったことは周知の事実であるが、その苦しみがどれほどのものであったかを克明に記したのが本書である。\n膨大な戦病死と餓死や、劣悪極まりない輸送船の悲劇などは他の書籍でも描かれているが、本書は大量の資料――日本軍と戦った米軍側の資料も含めて――を駆使してそうした事実を「兵士の目線」で「兵士の立ち位置」から捉えなおし、その悲惨な現実を描き出すとともに、日本軍の実情が貧弱なものであったことも描き出している。\n兵士を戦場に送り込むために用意した輸送船は奴隷船のような船であり、攻撃を受ければ瞬く間に沈没して多数の兵士が海没死し、攻撃を受けなくても船倉の異常な温度と湿度の上昇で中枢神経障害を起こして死亡する。\nそうやって送り込まむ兵士の質も、日中戦争の全面戦争化に伴う大量動員の必要から、\n 身体または精神にわずかな異常があっても、軍陣医学上」、軍務に支障なしと判断できる者は、「できるだけ徴集の栄誉に浴し得るよう、身体検査の条件を全般的に緩和した (p.86)\n 条件で集められた兵士であり、体格や体力の劣る兵士、病弱な兵士が増加していくこととなった。さらに、軍服は地の厚い毛織物から綿製になって洗濯のたびに生地が傷む代物になり、軍靴も素材が牛革から馬革や豚革に、さらには鮫皮にまで劣化し、補強用の釘や鋲まで減らされたことで耐久性がなくなり、前線では靴を履けない兵士が多数存在していた。飯盒さえ、金属製から孟宗竹製になっていった。戦国時代の足軽よりひどい装備ではないかと思うが、太平洋戦争の戦地は日本と環境が大きく異なる東南アジアや中国であり、装備品の劣悪化によるダメージはより深刻になっていたはずである。\n前線に到着した兵士も、上記のような劣悪な装備で補給なき戦いを強いられ、餓死する者、マラリヤなどの病気で死亡する者が続出し、さらには自分の身体を傷付けて戦場を離脱する者がでてくるまでに追い詰められていった。\n視点をマクロ的な面に移しても、当時の日本は後発の近代国家であり、機械化が遅れ労働生産性は低く、工場では多数の熟練労働者を現場に確保する必要があり、農村でも大量の農業従事者を確保する必要があった。このため、兵力と労働力の競合関係が深刻で、大規模な徴兵を行うと労働力が不足してしまうことになった。この「後発の近代国家」という弱点については経理から見た日本陸軍 (文春新書 1312) | 本間 正人 |本 | 通販 | Amazon でも触れられているが、同じ部品でも工場が違うとはまらないといった不具合が出るのは当たり前で、物資については輸送だけでなく生産についても大問題を抱えていた。\nこの状況では軍隊の機械化も進むはずもなく、日本軍はトラックの不足を歩兵の背負う荷物を増やすことで、土木機械の不足を『つるはし・もっこ・ローラー』で対応しようとした。そして、通信機器は米軍から10年遅れており、中国戦線の歩兵第二三二連隊第二大隊に配属された小柴無線分隊の「装備」は、無線機１台と伝書鳩５羽（！）であった。もはや、どこを見ても日米の軍事力の差は絶望的であり、日本軍が米軍を苦しめたとはいっても、それは前線の兵士の超人的な努力に頼ったものであり、兵士の塗炭の苦しみを一層際立たせるものでしかない。\n太平洋戦争の意味をどのように捉えるにせよ、本書が示す戦場の現実は、太平洋戦争は勝てる戦争でもなければ、まともに戦える戦争でもなかったことを示している。それは、後発の近代国家である日本が戦うにはあまりにも無謀な戦いであり、また、中国を簡単に屈服させられると思い込んで日中戦争を泥沼化させ、その挙句に日米戦争に向かわざるを得なくなった戦前日本の政治的・戦略的ミスの悲惨な総決算となってしまった戦争であった。\n","date":"2018-02-12","img":"","permalink":"https://s-show.github.io/posts/2018-02-12/","series":null,"tags":["太平洋戦争","読書記録","読書記録"],"title":"【読書記録】日本軍兵士――アジア・太平洋戦争の現実"},{"categories":null,"content":"  日米開戦と情報戦 (講談社現代新書)  amazon.co.jp    本の概要 日米戦争の開戦決定過程を、インテリジェンスの問題も視野に入れて再検討する著作である。著者は、南部仏印進駐（1941年7月末）以降、日米開戦に到るまでの決定過程については『日本はなぜ開戦に踏み切ったか』（新潮社、2012年）で道筋を説明していたが、同書では南部仏印進駐に至った経緯や、英米の動向については最小限にとどめていたことから、本書でそうした点を補うとともに、政策決定に密接に関わるインテリジェンスの問題も取り上げている。\n本書が対象とする期間は、1940年7月から1941年12月の真珠湾攻撃の直前までの期間であり、日米双方がどのような情報を基にし、その情報をどのように評価しながら政策を決定したのかという過程を描き出している。それはまた、情報の入手方法と評価軸を巡る問題を描き出すものでもある。\n感想 敵国の暗号を解読すれば機密の通信を読むことができる。しかし、暗号文を平文に戻せたからといって、その平文を\u0026quot;きちんと\u0026quot;読むことができるとは限らない。\n開戦前の日本と英米は、相手国の暗号を解読して平文に戻すことに成功していた。そして、解読した情報は最高機密情報として管理し、政策立案者が首相や大統領が直接目を通していた。日英米の過ちは、解読情報を読み解くという仕事を、情報の専門家ではなく、政策立案者や首脳が行なってしまったことであった。彼らには、得られた機密通信の行間や文脈を読み取る力量は欠けており、また、自らに都合の良い情報ばかり集める傾向にも無自覚であった。\nさらに、日本の暗号の解読文は、漢字を含まない音だけで構成された文章であった。例えば、「御前会議」を暗号化して送信して英米が解読した場合、得られる情報は「GOZENKAIGI」という日本語の音だけであった。これを日本語に翻訳する際、通訳の力量によっては「GOZENKAIGI」を「午前会議」と訳すこともあった。これはマシな方で、中には悪意を持って翻訳したとしか思えない翻訳もあり、それはアメリカ側の対日不信感を増幅させることとなった。一方、日本側にはそうした問題は原理的に起こり得ないため、得られた平文をそのまま日本語に訳せば良いという有利な立場であったにも関わらず、そもそも暗号文を読んでいた陸海軍の首脳部がアメリカについて無知であったため、自らの行動がアメリカにどう解釈されるのかという点を見誤ることとなった。\nしかし、機密の通信を読むことができているという事実は、アメリカに「自分たちは日本の出方を知悉している」と思い込ませることとなった。日米は、お互いに機密通信を読んでいたが故に、相手からのメッセージについて、双方でコミュニケーションを重ねてその意図を探るという行為を軽んじることとなり、それが結果的に深刻なコミュニケーションギャップを生むことになった。\nここで非常に示唆的なのは、そうした暗号解読情報に接することはできないが、相手国のことは熟知している外交官——幣原やグルー駐日大使——は、公開情報と相手国に対する深い理解を根拠として、相手の出方を正確に予測できていたことである。そこから得られる教訓は、たとえ苦労の末に解読した暗号文であったとしても、その情報は単なるインフォメーションであって、インテリジェンスでは無いということ。そして、そうした情報を慎重かつ正確に評価できる専門家に評価を依頼し、その意見を尊重する文化がなければ、たとえ軍や政府の首脳であっても、情報の評価を誤ってしまうということであろう。\nその結果は、日本は無条件降伏をして明治維新以降の成果のほとんど失い、英国は勝利したが、植民地を失い大英帝国の栄光を完全に失うこととなった。アメリカも勝ったとはいえ、日米間の原則的対立の中心だった中国は、アメリカの巨大市場となることはなく、竹のカーテンの向こうへ消えていってしまった。日本との戦いに投じた労力に見合う成果を得られたのかは疑問であった。\nこうしたことを踏まえ、著者は最後に日英米の情報戦の結果を次のようにまとめている。\n 戦争では、どの国も過誤を犯す。そして、より少なく過誤を侵した国が勝利を収める。情報戦でも、日英米何れもが過誤を犯した。その結果が、あの戦争だった。最も少ないコストで目的を達成するという観点からすれば、日英米いずれも開戦前の情報戦に敗れたのである。\n ","date":"2017-11-27","img":"","permalink":"https://s-show.github.io/posts/2017-11-27/","series":null,"tags":["読書","読書記録"],"title":"【読書記録】日米開戦と情報戦"},{"categories":null,"content":"  忘れられた日本の村  amazon.co.jp    本の概要 著者の筒井功氏は、元共同通信社の記者で、正史に登場しない非定住民の生態や民俗の調査・取材を行っている。\n本書を一言で紹介するのは難しく、著者も本書を「エッセイとも旅行記ともつかない妙な内容の著述」と後書きに記している。学術書ではないが、風景の美しさや旅情とやらを紹介する旅行記でもないし、旅の感想を述べるエッセイでもない。著者が、民俗学や歴史の研究成果を踏まえ、実地調査も行い、そこから得られた知見をまとめた書物、というのが本書の簡単な紹介になるかと思う。\n現在の町や村が見かけは似ていてたしても、少し古い時代に遡れば、様々な歴史を辿ったために豊かな個性を持つ町村は多数存在していた。例えば、全戸が狩猟を生業にしていた、芸能を演ずることで生活を支えていた、無籍の漂白民が集住して一村をなした、など非常に個性豊かな町村が多数存在していたのである。そうした個性は、通りすがりに一瞥しただけでは気付くことのないが、文献を紐解き、現地を訪れ、人々に話を聞くことで見えてくるものであり、そうして見えたものを文章にしてみたいという著者の思いから本書は生まれている。\n本書で紹介されている村は、南は大分県から北は秋田県まで7つあり、それらの村が辿った歴史に触れることは、日本が辿った歴史の一端を垣間見ることでもある。\n感想 特に個性的な村を選んだはずなので、出てくる村の歴史はどれも面白いものばかりである。歴史学者の網野義彦氏は「日本の東西間の違いは、日本と外国の違いより大きいのではないかと思う」と述べていたが、本章に登場する村々を見ていると、日本には豊かな歴史があるという思いが非常に強くなる。\nただ、その豊かな歴史は、歴史教科書に掲載される大事件ではなく、歴史教科書に登場しない人々の日々の営みが積み重なってできたものであり、どうしてもその歴史を確認したいと強く願う人が探さなければ見つからない。この本を読むと、そうした歴史の痕跡を探そうと、古い地名、地元の祭り、はたまた地元民の良く知る場所についてもっと知りたいと思うようになってくる。戦後の高度経済成長で山間部から都会へ人が大量に移動し、昔のことを知る人がどんどん減っていることを踏まえると、そうした歴史を掘り起こすことが出来る時間も、そんなに残されていないと思う。だからこそ、そうした歴史を掘り起こすことは大切なことだと思う。\n特に印象に残った部分 どれも印象に残るが、一つ挙げるとすれば、本書第六章に登場する徳島県美馬市穴吹の三ツ木が一番印象に残る。四国の徳島県美馬市木屋平字三ツ木という山奥に三木家（場所は下の地図参照）という家がある。その住宅は母屋の平屋だけで建坪200平方メートル余り、茅葺きの江戸時代初期の建築であり、1976年に国の重要文化財に指定されている。とはいえ、本章の主題はこの建物についてではなく、この三木家が果たしてきた役割である。\n三木家は、天皇が大嘗祭（天皇が即位後初めて行う新嘗祭のこと。詳細は脚注のリンクを参照1）を行う際に着用する麁布（読みは「あらたえ」。麻布で作った服。）を貢納する家であり、貢納が始まった時期は、伝承では古代から、文献で確認できるところでは文保2年（1318年）からである。この麁布の貢納の話を紹介し、そこから三木家を含めた村の歴史を、平安時代の京都の動きと絡めながら現代まで描き出していく。それは、三木家が古代の阿波忌部氏にまで遡るという話から始まり、後醍醐天皇即位の際の大嘗祭に麁布を献上し、その繋がりで南朝側に立って戦ったこと、百姓身分でありながら苗字帯刀が許されていた江戸時代の状況、そして、地区の発展や村の歴史書の執筆に尽力した明治・大正までの歴史であり、村が辿った歴史を描くことでもある。\nこの本を読むまで、天皇が執り行う神事で使う物は、宮内庁で作るか皇室御用達の店から購入しているのかと思っていて、四国の山奥にある一つの家が貢納しているとは夢にも思っていなかった。見方を変えれば、今は途絶えているとしても、昔は三木家と同様に天皇家に何らかの品を貢納していた家が存在していたのではないだろうか。もし、そうした家の歴史を振り返ることが出来たなら、多彩な歴史を有する村が日本には多数あったことが裏付けられると思う。\n   宮内庁公表資料：皇位の継承に係わる儀式等（大嘗祭を中心に）について \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2017-11-26","img":"","permalink":"https://s-show.github.io/posts/2017-11-26/","series":null,"tags":["読書記録","読書記録"],"title":"【読書記録】忘れられた日本の村"},{"categories":null,"content":"Karabiner-Elementsとは Karabiner-Elementsは、Macのキーボードカスタマイズアプリで、設定ファイルを自分で記述することで以下のような機能を実現できます。\n \u0026ldquo;control-H\u0026quot;のようなキー入力を\u0026quot;Command-A\u0026quot;の入力に変換 \u0026ldquo;Escape\u0026quot;を１回入力したら\u0026quot;Escape, 英数, Escape\u0026quot;のようなキー入力を実現する \u0026ldquo;control-2\u0026quot;のようなキー入力に\u0026quot;open -a 'safari'\u0026quot;のようなシェルコマンドの実行を割り当てる \u0026ldquo;スペースバー\u0026quot;を押している間だけ、\u0026ldquo;H, J, K, L\u0026quot;をカーソルキーに変換する \u0026ldquo;control-x control-c\u0026quot;のようなキー入力を\u0026quot;command-Q\u0026quot;の入力に変換したり、シェルコマンドの実行を割り当てる。 左右のコマンドキーを押すとIMEをオン・オフできるようにする  同じキーボードカスタマイズアプリで、同じ開発者が開発していたKarabinerがmacOS Sierraで使用できなくなったため、後継アプリとして開発されています。ちなみに、KarabinerはKeyRemap4MacBookと呼ばれていたアプリです。 アプリの配布場所：Karabiner-Elements Karabiner-Elementsを使って実現した機能（主なもの） Karabiner-Elementsを使うと様々な機能を実現することが可能で、コピーなどの各種操作をWindowsと同じにしたり、キーボードの配列をQWERTYからDVORAKに変更するカスタマイズまでしている人もいるようです。そこまでいかなくても、以下のページを見ると、たくさんのユーザーが実に様々な設定を行なっていることが分かります。 Karabiner-Elements complex_modifications rules 私が行っている設定のうち、主なものは以下のとおりです。\n IMEの切り替え方法の改善  全角/半角キーでIMEを切り替え 変換/かなキーでIMEオン 無変換キーでIMEオフ   ブラウザ（Safari, Chrome, Firefox）やターミナルのタブの移動をctrl-pageup(down)で行えるように設定 Windowsと同様の動作を実現  F5キーでブラウザの更新を行う Shift-F10やアプリケーションキーに右クリックを割り当て PrintScreenで画面全体のスクリーンショット撮影 Option-PrintScreenで指定したウィンドウのスクリーンショットを撮影 Finderでファイル(フォルダ)を選択してDeleteを押すとファイルをゴミ箱へ移動 Command-EでFinderを開く Control-EscapeでLaunchPad表示（スタートメニュー表示の代わり）   Windowsのキーボードユーティリティーソフトのenthumbleと同様の操作を実現  無変換/英数 + I, J, K, L -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + A, S, W, D -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + B, N, P, F -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + H, J, K, L -\u0026gt; 矢印キー（←, ↓, ↑, →）※この組み合わせを使用中 無変換/英数 + Space/かな -\u0026gt; Enter/Escape 無変換/英数 + N, M -\u0026gt; BackSpace 無変換/英数 + \u0026lsquo;,\u0026rsquo; \u0026lsquo;.\u0026rsquo; -\u0026gt; Delete 無変換/英数 + Y, U -\u0026gt; BackSpace 無変換/英数 + I, O -\u0026gt; Delete 無変換/英数 + 矢印キー（←, ↓, ↑, →）で「←, ↓, ↑, →」を入力   Windowsのキーボードユーティリティーソフトの秀Capsの「テンキーのピリオド２連打でコンマ入力」を実現  上記の他にも設定している項目はあります。設定ファイルは、GitHubで管理していますので、適宜開いて見てください。また、Karabiner-Elementsには、設定ファイルを自分で書かなくても、他の人の設定をインポートして使用可能にする機能があります。上記の設定を紹介しているページからも設定をインポートできますし、私の設定であれば、以下のリンクからインポートできます。 設定ファイル（JSONファイル）：KE-complex_modifications Karabiner-Elementsに読み込ませる設定ファイルは、docs/json/ディレクトリにあります。 設定のインポートページ：Karabiner-Elements complex_modifications rules by s-show 設定で工夫した点 Emacsの２ストロークキーや、一つのキーを押している間だけキーの変換を行いたい場合、Karabiner-Elementsには専用の設定がありません。そのため、キーを押しているか否かをアプリで判断するため、変数を使ってフラグを立てて判断したり、トリガーとなるキーを\u0026quot;fn\u0026quot;キーに一時的に変換し、\u0026ldquo;fn\u0026quot;と合わせて押した場合のみ変換を行う、などのテクニックが必要となります。\nEmacsの２ストロークキーの設定は、最初は非常に面倒な作業でした。割り当てたいキーを指定するだけなら簡単でしたが、キー入力を間違えた時に備えたエラー処理を全てのキーについて行う必要があり、設定を記述したJSONファイルが17,000行以上になったこともありました。その後、Karabiner-Elementsに新しい機能が追加され、その機能を利用したら設定ファイルが220行程度まで縮小できました。また、一つのキーを押している間だけキーの変換を行うという設定については、当初は変数を使ってフラグを立てる方法で実装していましたが、GitHubにある設定例を見て、トリガーとなるキーを一時的に\u0026quot;fn\u0026quot;キーに変換し、\u0026quot;fn\u0026quot;と合わせて押した場合のみキーの変換を行うという設定方法を知ってから、変数をチェックする処理や変数の初期化処理が不要となり、設定がシンプルに行えるようになりました。さらに、先日、開発者がリファレンスを作成してくれましたが、このリファレンスに掲載されていた例を参考にすることで、「テンキーのピリオド２連打でコンマ入力」を実現する方法が思いついたりもしました。\nあと、Karabiner-Elementsはキー変換とコマンド実行の機能しかないため、enthumbleの「\u0026ldquo;無変換/英数 ＋ カーソルキー\u0026rdquo; で \u0026ldquo;←↑↓→\u0026quot;を入力」という機能を実現するのには試行錯誤しました。最初は、\u0026quot;shell_command\u0026quot;: \u0026quot;echo '←' | pbcopy | pbpaste\u0026quot;で上手くいくかと思いましたが、よく考えると、pbcopyもpbpasteも標準入出力が対象になっているので、それ以外の場面で動くことはないことに気付きました。\n次に、\u0026ldquo;←\u0026quot;を一旦クリップボードにコピーして、それをペーストすれば文字入力と同じ結果が得られると考えて、以下の方法を試しました。しかし、クリップボードに\u0026quot;←\u0026quot;をコピーするところまではできましたが、クリップボードへのコピーより先に\u0026quot;command-v\u0026quot;が実行されてしまいました。\n{ \u0026quot;shell_command\u0026quot;: \u0026quot;osascript -e 'set the clipboard to \\\u0026quot;←\\\u0026quot;'\u0026quot; }, { \u0026quot;key_code\u0026quot;: \u0026quot;v\u0026quot;, \u0026quot;modifiers\u0026quot;: [\u0026quot;option\u0026quot;] } どうも、AppleScriptの動作が遅いことが原因で、\u0026quot;osascript -e 'set the clipboard to \\\u0026quot;←\\\u0026quot;'\u0026quot;の処理が終わる前に\u0026quot;command-V\u0026quot;の処理が行われたようでした。\u0026quot;osascript ~~~\u0026quot;の処理が終わるまで\u0026quot;command-V\u0026quot;を実行しないという処理を実現する方法は全く分かりませんでしたので、\u0026ldquo;←\u0026quot;のクリップボードへのコピーもペーストもAppleScriptで行うように設定したところ、動作は遅いものの、狙い通りの機能が実装できました。\n{ \u0026quot;shell_command\u0026quot;: \u0026quot;osascript -e 'set the clipboard to \\\u0026quot;←\\\u0026quot;'\u0026quot; }, { \u0026quot;shell_command\u0026quot;: \u0026quot;osascript -e 'tell application \\\u0026quot;System Events\\\u0026quot; to keystroke \\\u0026quot;v\\\u0026quot; using command down'\u0026quot; } カスタマイズの効果 自分が欲しい機能を順次実装しているので、Macの操作は随分と楽になっています。特に、Windowsでは可能なのにMacでは不可能な操作（全角/半角キーでのIME切り替えなど）が可能になり、２つのOSを使う際に戸惑うことが少なくなりました。\n今ではむしろ、\u0026ldquo;ctrl-h/d → Backspace/Delete\u0026quot;のように、Macでは可能だがWindowsではカスタマイズしないと実現できないキー操作を実現する方法が欲しくなっています。\nまた、「全角/半角キーでIMEを切り替え」や「Controlキー連打で特定の処理実行」といったカスタマイズは、Macのシステム環境での設定とKarabiner-Elementsを組み合わせたり、BetterTouchToolを使って実現したりしていましたが、そうした設定を全てKarabiner-Elementsだけで可能となり、設定の管理も非常に楽になりました。\n本記事の補足情報 QiitaでKarabiner-Elementsの設定項目の解説や設定例を掲載していますので、よろしければそちらも見てください。\n Karabiner-Elementsの各設定項目の内容について  Karabiner-Elementの設定例について - Qiita  Karabiner-Elementsを使ってJISキーボードの\u0026quot;全角/半角\u0026quot;でIMEを切り替える方法 - Qiita  Karabiner-Elementsの設定項目が増えてEmacsライクな設定が楽になった - Qiita  Karabiner-Elementsでenthumble(Windows App)のような操作を実現する方法 - Qiita  Karabiner-Elementsを使ってキーの２連打に処理を割り当てる方法 - Qiita  KE-complex_modificationsを使ってKarabiner-Elementsの設定を楽にする方法 - Qiita   ","date":"2017-11-25","img":"","permalink":"https://s-show.github.io/posts/2017-11-25/","series":null,"tags":["Karabiner-Elements","Mac","プログラミング"],"title":"Karabiner-Elementsを使ってMacのキーボード操作を快適にする方法"}]