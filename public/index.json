[{"body":"","link":"http://localhost:1313/","section":"","tags":null,"title":""},{"body":"","link":"http://localhost:1313/archives/2024/12/","section":"archives","tags":null,"title":"2024/12"},{"body":"","link":"http://localhost:1313/archives/","section":"archives","tags":null,"title":"Archives"},{"body":"前置き 拙作のプラグインである extend_word_motion.nvim を開発するため、ローカルにあるプラグインを lazy.nvim で読み込む必要がありましたので、そのための設定を備忘録として残します。\n環境 1❯ nvim --version 2NVIM v0.10.2 3Build type: Release 4LuaJIT 2.1.1713773202 5Run \u0026#34;nvim -V1 -v\u0026#34; for more info 1# lazy.nvim 2version 11.16.2 3tag v11.16.2 4branch main 5commit 7e6c863 1~/.config/nvim 2 ├── init.lua 3 ├── lazy-lock.json 4 ├── lua 5 │ ├── config 6 │ ├── plugins 7 │ │ ├── ... 8 │ │ ├── extend_word_motion-nvim.lua 9 │ │ └── ... 10 │ └── setting 必要な設定 ローカルプラグインを読み込むための設定は、公式リファレンスの configuration と Examples で以下のとおり提示されています。それぞれの設定の説明は、コメントに書かれています。\n1dev = { 2 -- Directory where you store your local plugin projects. If a function is used, 3 -- the plugin directory (e.g. `~/projects/plugin-name`) must be returned. 4 ---@type string | fun(plugin: LazyPlugin): string 5 path = \u0026#34;~/projects\u0026#34;, 6 -- （拙訳） 7 -- あなたがローカルプラグインのプロジェクトを保存したディレクトリ。function を使うのであれば、 8 -- プラグインのディレクトリ（例: `~/projects/plugin-name`）が返される必要がある。 9 ---@type string | fun(plugin: LazyPlugin): string 10 11 ---@type string[] plugins that match these patterns will use your local versions instead of being fetched from GitHub 12 patterns = {}, -- For example {\u0026#34;folke\u0026#34;} 13 -- （拙訳） 14 ---@type string[] これらのパターンにマッチするプラグインは、Github から取得してくる代わりにローカルにあるものを使います。 15 16 fallback = false, -- Fallback to git when local plugin doesn\u0026#39;t exist 17}, 1return { 2 -- local plugins need to be explicitly configured with dir 3 { dir = \u0026#34;~/projects/secret.nvim\u0026#34; }, 4 （拙訳） 5 -- ローカルプラグインは dir オプションを使って明示的に設定される必要があります。 6 7 -- local plugins can also be configured with the dev option. 8 -- This will use {config.dev.path}/noice.nvim/ instead of fetching it from GitHub 9 -- With the dev option, you can easily switch between the local and installed version of a plugin 10 { \u0026#34;folke/noice.nvim\u0026#34;, dev = true }, 11 （拙訳） 12 -- ローカルプラグインは、dev オプションを使うことでも設定されます。 13 -- GitHub からフェッチする代わりに {config.dev.path}/noice.nvim/ が使われます。 14 -- dev オプションを使うと、ローカル版とインストール版の間でプラグインのバージョンを簡単に切り替えられます。 15} この説明と、ローカルプラグインのファイル構造を踏まえて、init.lua と lua/plugin/extend_word_motion.lua を以下のとおり設定しました。\n1~/my_neovim_plugins 2 └── extend_word_motion.nvim 3 ├── doc 4 │ ├── extend_word_motion.txt 5 │ └── tags 6 ├── LICENSE 7 ├── lua 8 │ └── extend_word_motion 9 │ ├── init.lua 10 │ └── util.lua 11 ├── plugin 12 │ └── extend_word_motion.vim 13 └── README.md 1-- init.lua 2require(\u0026#34;lazy\u0026#34;).setup({ 3 dev = { 4 path = \u0026#34;~/my_neovim_plugins\u0026#34;, 5 }, 6 spec = { 7 import = \u0026#39;plugins\u0026#39;, 8 } 9}) 1-- lua/plugins/extend_word_motion.lua 2return { 3 dir = \u0026#39;~/my_neovim_plugins/extend_word_motion.nvim\u0026#39;, 4 opts = {}, 5 dependencies = { 6 \u0026#39;sirasagi62/tinysegmenter.nvim\u0026#39; 7 }, 8} この設定により、~/my_neovim_plugins/extend_word_motion.nvim で開発しているローカルプラグインを lazy.nvim で読み込むことができました。\nローカル版と GitHub 版の切り替え 開発が一段落すると GitHub にプッシュすると思いますが、init.lua と lua/plugins/extend_word_motion.lua を以下のとおり変更すると、GitHub 版とローカル版を簡単に切り替えられるようになります。\n1-- init.lua 2require(\u0026#34;lazy\u0026#34;).setup({ 3 dev = { 4 path = \u0026#34;~/my_neovim_plugins\u0026#34;, 5 patterns = { \u0026#39;extend_word_motion.nvim\u0026#39; }, 6 }, 7 spec = { 8 import = \u0026#39;plugins\u0026#39;, 9 } 10}) 1-- lua/plugins/extend_word_motion.lua 2return { 3 \u0026#39;s-show/extend_word_motion.nvim\u0026#39;, 4 dev = true, 5 opts = {}, 6 dependencies = { 7 \u0026#39;sirasagi62/tinysegmenter.nvim\u0026#39; 8 }, 9} dev を true にすればローカル版が読み込まれ、false にすると GitHub 版が読み込まれます。\n補足 もし、ローカルプラグインを追加する場合、そのプラグインの設定ファイルを lua/plugins に作成すればOKです。ここでは ~/my_neovim_plugins/test_plugin というプラグインを追加しています。\n1~/my_neovim_plugins 2 ├── extend_word_motion 3 │ ├── doc 4 │ │ ├── extend_word_motion.txt 5 │ │ └── tags 6 │ ├── LICENSE 7 │ ├── lua 8 │ │ └── extend_word_motion 9 │ │ ├── init.lua 10 │ │ └── util.lua 11 │ ├── plugin 12 │ │ └── extend_word_motion.vim 13 │ └── README.md 14 └── test_plugin 15 └── plugin 16 └── test_plugin.vim 1-- lua/plugins/test_plugin.lua 2return { 3 dir = \u0026#39;~/my_neovim_plugins/test_plugin\u0026#39;, 4} この設定で ~/my_neovim_plugins/testest_plugin が読み込まれます。\n","link":"http://localhost:1313/post/2024-12-27/","section":"post","tags":["neovim"],"title":"Lazy.nvim でローカルにあるプラグインを読み込む方法"},{"body":"","link":"http://localhost:1313/tags/neovim/","section":"tags","tags":null,"title":"Neovim"},{"body":"","link":"http://localhost:1313/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"http://localhost:1313/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"http://localhost:1313/tags/lua/","section":"tags","tags":null,"title":"Lua"},{"body":"前置き この記事はVim Advent Calendar 2024 の 16日目の記事です。本記事執筆時点で15日目の記事は登録されていないので、本記事の前の記事は、nil2 さんの Vimの:{range}!を通して任意の言語でテキストを処理する です。AWK でテキストを整形したりワンライナーのスクリプトのデバッグをするのに便利そうな手法ですね。\nVim/Neovim には単語単位で移動する Word Motion という機能があり、w, b, e, ge で単語単位の移動ができますが、スペースを単語の区切りとしていますので、日本語では使いにくい機能でした。\nそんな中、Vim Advent Calendar 2024 の 2日目の記事で tinysegmenter.nvim という日本語の分かち書きを実現する Neovim プラグインが紹介されていましたが、こちらを利用すると日本語の文章を単語単位で簡単に区切れますので、これを使って Word Motion を改造してみようと思いました。\nいざやってみると結構苦労しましたが、何とか形になりましたので、その成果を公表します。\n実際の動作 前提条件 1❯ nvim --version 2NVIM v0.10.1 3Build type: Release 4LuaJIT 2.1.1713773202 5Run \u0026#34;nvim -V1 -v\u0026#34; for more info tinysegmenter.nvim で日本語を分かち書きしますので、事前にインストールします。私は 🚀 Getting Started | lazy.nvim でプラグインを管理していますので、以下のコードを設定ファイルに追記して Lazy コマンドからインストールします。\n1return { 2 \u0026#34;sirasagi62/tinysegmenter.nvim\u0026#34;, 3} 本記事執筆時点で使っている tinysegmenter.nvim のバージョンは次のとおりです。\n1tinysegmenter.nvim -\u0026gt; commit 64ac8a1 実装 まず、tinysegmenter.nvim で文章を分かち書きした結果を示します。\n元の文章 今回は、2020年のアドベントカレンダーの記事で「設計中です」としていたキーボードについて、やっと自分なりに満足できる形になってきましたので、このキーボードの設計の意図なんかを書いていきます。\n変換後の文章 { \u0026quot;今回\u0026quot;, \u0026quot;は\u0026quot;, \u0026quot;、\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;年\u0026quot;, \u0026quot;の\u0026quot;, \u0026quot;アドベントカレンダー\u0026quot;, \u0026quot;の\u0026quot;, \u0026quot;記事\u0026quot;, \u0026quot;で\u0026quot;, \u0026quot;「\u0026quot;, \u0026quot;設計\u0026quot;, \u0026quot;中\u0026quot;, \u0026quot;です\u0026quot;, \u0026quot;」\u0026quot;, \u0026quot;と\u0026quot;, \u0026quot;し\u0026quot;, \u0026quot;て\u0026quot;, \u0026quot;い\u0026quot;, \u0026quot;た\u0026quot;, \u0026quot;キーボード\u0026quot;, \u0026quot;について\u0026quot;, \u0026quot;、\u0026quot;, \u0026quot;やっと\u0026quot;, \u0026quot;自分\u0026quot;, \u0026quot;なり\u0026quot;, \u0026quot;に\u0026quot;, \u0026quot;満足\u0026quot;, \u0026quot;できる\u0026quot;, \u0026quot;形\u0026quot;, \u0026quot;に\u0026quot;, \u0026quot;なっ\u0026quot;, \u0026quot;て\u0026quot;, \u0026quot;き\u0026quot;, \u0026quot;まし\u0026quot;, \u0026quot;た\u0026quot;, \u0026quot;の\u0026quot;, \u0026quot;で\u0026quot;, \u0026quot;、\u0026quot;, \u0026quot;この\u0026quot;, \u0026quot;キーボード\u0026quot;, \u0026quot;の\u0026quot;, \u0026quot;設計\u0026quot;, \u0026quot;の\u0026quot;, \u0026quot;意図\u0026quot;, \u0026quot;なんか\u0026quot;, \u0026quot;を\u0026quot;, \u0026quot;書い\u0026quot;, \u0026quot;て\u0026quot;, \u0026quot;いき\u0026quot;, \u0026quot;ます\u0026quot;, \u0026quot;。\u0026quot; }\nこの結果を見ながら Word Motion を改造します。改造は、以下の方針で実装しました。\nASCII 文字の上にカーソルがある場合は本来の Word Motion をそのまま実行し、カーソルが日本語の文字の上にある時だけ改造した Word Motion を実行する。 Word Motion が上手く動かないのは日本語の上にカーソルがある場合なので、ASCII 文字の上にカーソルがある場合は本来の動作を実行してもらう。 W, B, E, gE は改造しない。 これらは WORD 単位で動きますが、日本語における WORD 単位の挙動が思いつかなかったので、今回は改造を見送りました。 2w のように回数を指定した場合、きちんと回数分だけモーションを繰り返す また、実装を始めた時は、以下のようにコード中の変数と w, b, e, ge をタイプしたときに移動するべき場所を文字毎にまとめた表を作成して、正しく改造できているかすぐに確認できるようにしました。\n今 回 は 、 2 0 2 0 年 の ア ド ベ ン ト カ レ ン ダ ー の … い き ま す 。 length_up_to_cursor 2 2 3 4 5 6 7 8 9 10 20 20 20 20 20 20 20 20 20 20 21 … 93 93 95 95 96 cursor_position 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 … 92 93 94 95 96 w ● ● ● ● ● ● ● ● ● ● … ● ● ● b ● ● ● ● ● ● ● ● ● ● ● … ● ● e ● ● ● ● ● ● ● ● ● ● ● … ● ● ge ● ● ● ● ● ● ● ● ● ● ● … ● ● ここまで準備してから実装を始めましたが、カーソル位置と分かち書きの結果を対応させる必要がありましたので、試行錯誤の末、分かち書きの結果を以下のような多次元配列に格納しました。この多次元配列を for 文で順番に処理しつつ、getcursorcharpos() 関数で取得したカーソル位置と比較することで、カーソル位置と分かち書きの結果を対応させることにしました。\n1{ 2 { 3 [\u0026#39;text\u0026#39;] = \u0026#39;今回\u0026#39;, 4 [\u0026#39;start\u0026#39;] = 1, 5 [\u0026#39;end\u0026#39;] = 2 6 }, 7 { 8 [\u0026#39;text\u0026#39;] = \u0026#39;は\u0026#39;, 9 [\u0026#39;start\u0026#39;] = 3, 10 [\u0026#39;end\u0026#39;] = 3 11 }, 12 { 13 [\u0026#39;text\u0026#39;] = \u0026#39;、\u0026#39;, 14 [\u0026#39;start\u0026#39;] = 4, 15 [\u0026#39;end\u0026#39;] = 4 16 }, 17} また、本来の w, b, e, ge は行を跨いだ移動もできますので、以下のようにアルファベットだけの文章での w, b, e, ge の動きをチェックしてから、日本語の文章でも同様の動きになるよう調整しました（|はカーソル位置を示しています）。\n1-- アルファベットだけの文章 2if vim.fn.strcharlen(char) \u0026gt; 1 |then 3 return false 4end 5 6- `w` をタイプ 7if vim.fn.strcharlen(char) \u0026gt; 1 then 8 |return false 9end 10 11-- `b` をタイプ 12if vim.fn.strcharlen(char) \u0026gt; |1 then 13 return false 14end 15 16-- `e` をタイプ 17if vim.fn.strcharlen(char) \u0026gt; 1 the|n 18 return false 19end 20 21-- `ge` をタイプ 22if vim.fn.strcharlen(char) \u0026gt; |1 then 23 return false 24end 25 26-- 日本語の文章 27今回は、2020年のアドベントカレンダーの|記事 28 で設計中ですとしていたキーボードについて、 29 30- `w` をタイプ 31今回は、2020年のアドベントカレンダーの記事 32 |で設計中ですとしていたキーボードについて、 33 34- `b` をタイプ 35今回は、2020年のアドベントカレンダー|の記事 36 で設計中ですとしていたキーボードについて、 37 38-- `e` をタイプ 39今回は、2020年のアドベントカレンダーの記|事 40 で設計中ですとしていたキーボードについて、 41 42-- `ge` をタイプ 43今回は、2020年のアドベントカレンダー|の記事 44 で設計中ですとしていたキーボードについて、 実はこの行を跨いだ移動の実装が面倒だったところで、行頭・行末に空白文字がある場合の処理が難しかったです。試行錯誤の結果、分かち書きは行頭・行末の空白文字を除いた文章で実施し、同時に行頭で空白文字以外の文字が最初に登場する場所と、行末で空白文字以外の文字が最後に登場する場所を変数に格納して利用する形にしました。\n実際のコード 1local tinysegmenter = require(\u0026#34;tinysegmenter\u0026#34;) 2 3-- @desc: 引数で渡された文字が ASCII 文字かそうでないか判断する関数 4-- @param - string 5function IsASCIIChar(char) 6 if vim.fn.strcharlen(char) \u0026gt; 1 then 7 return false 8 end 9 local char_byte_count = string.len(char) 10 if char_byte_count == 1 then 11 return true 12 else 13 return false 14 end 15end 16 17function OverrideWordMotion(arg) 18 if IsASCIIChar(arg.under_cursor_char) then 19 -- `bang = true` とすると `normal!` と同じことになる 20 -- カーソルがASCII文字の上にあるときは、通常の `w`, `b`, `e`, `ge` を実行する。 21 vim.cmd.normal({ arg.motion, bang = true }) 22 else 23 local parsed_text_with_position = {} 24 local text_start_position = 1 25 for i, text in ipairs(arg.parsed_text) do 26 parsed_text_with_position[i] = {} 27 parsed_text_with_position[i][\u0026#39;text\u0026#39;] = text 28 parsed_text_with_position[i][\u0026#39;start\u0026#39;] = text_start_position 29 parsed_text_with_position[i][\u0026#39;end\u0026#39;] = text_start_position + vim.fn.strcharlen(text) - 1 30 text_start_position = text_start_position + vim.fn.strcharlen(text) 31 end 32 for i, text_with_position in ipairs(parsed_text_with_position) do 33 if arg.cursor_position[3] \u0026gt;= text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 and 34 arg.cursor_position[3] \u0026lt;= text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 then 35 if arg.motion == \u0026#39;w\u0026#39; then 36 -- カーソルが非空白文字の末尾 or 分かち書きした文字列の最後のノードにある 37 if arg.cursor_position[3] == arg.last_char_position or 38 text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 == arg.last_char_position then 39 local below_line_text = vim.fn.getline(arg.cursor_position[2] + 1) 40 local first_char_position = vim.fn.matchstrpos(below_line_text, \u0026#39;^\\\\s\\\\+\u0026#39;)[3] + 1 41 arg.cursor_position[3] = first_char_position 42 arg.cursor_position[2] = arg.cursor_position[2] + 1 43 elseif i ~= #parsed_text_with_position then 44 arg.cursor_position[3] = parsed_text_with_position[i + 1][\u0026#39;start\u0026#39;] + arg.first_char_position - 1 45 end 46 end 47 if arg.motion == \u0026#39;ge\u0026#39; then 48 -- カーソルが非空白文字の始め or 分かち書きした文字列の最初のノードにある 49 if arg.cursor_position[3] == arg.first_char_position or 50 text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 == arg.first_char_position then 51 local above_line_text = vim.fn.getline(arg.cursor_position[2] - 1) 52 local last_char_position = vim.fn.strcharlen(vim.fn.substitute(above_line_text, \u0026#39;\\\\s\\\\+\\\\_$\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;g\u0026#39;)) 53 arg.cursor_position[3] = last_char_position 54 arg.cursor_position[2] = arg.cursor_position[2] - 1 55 elseif i ~= 1 then 56 arg.cursor_position[3] = parsed_text_with_position[i - 1][\u0026#39;end\u0026#39;] + arg.first_char_position - 1 57 end 58 end 59 if arg.motion == \u0026#39;b\u0026#39; then 60 -- カーソルが非空白文字の始めにある 61 if arg.cursor_position[3] == arg.first_char_position then 62 local above_line_text = vim.fn.getline(arg.cursor_position[2] - 1) 63 local above_line_text_without_space = vim.fn.substitute(above_line_text, \u0026#39;\\\\s\\\\+\\\\_$\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;g\u0026#39;) 64 local above_line_text_without_space_length = vim.fn.strcharlen(above_line_text_without_space) 65 local parsed_above_line_text = tinysegmenter.segment(above_line_text_without_space) 66 arg.cursor_position[3] = above_line_text_without_space_length - vim.fnstrcharlen(parsed_above_line_text[#parsed_above_line_text]) + 1 67 arg.cursor_position[2] = arg.cursor_position[2] - 1 68 -- カーソルが分かち書きした文字列の最初のノードにある 69 elseif text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 == arg.first_char_position then 70 arg.cursor_position[3] = text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 71 elseif i ~= 1 then 72 -- カーソルが分かち書きした各ノードの1文字目にある 73 if arg.cursor_position[3] == text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 then 74 arg.cursor_position[3] = parsed_text_with_position[i - 1][\u0026#39;start\u0026#39;] + arg.first_char_position - 1 75 else 76 arg.cursor_position[3] = text_with_position[\u0026#39;start\u0026#39;] + arg.first_char_position - 1 77 end 78 end 79 end 80 if arg.motion == \u0026#39;e\u0026#39; then 81 -- カーソルが非空白文字の末尾にある 82 if arg.cursor_position[3] == arg.last_char_position then 83 local below_line_text = vim.fn.getline(arg.cursor_position[2] + 1) 84 local below_line_text_without_space = vim.fn.substitute(below_line_text, \u0026#39;^\\\\s\\\\+\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;g\u0026#39;) 85 local first_char_position = vim.fn.matchstrpos(below_line_text, \u0026#39;^\\\\s\\\\+\u0026#39;)[3] + 1 86 -- 行頭に空白が無いと first_char_position が 0 になるので、強制的に値を 1 にする 87 if first_char_position == 0 then 88 first_char_position = first_char_position + 1 89 end 90 local parsed_below_line_text = tinysegmenter.segment(below_line_text_without_space) 91 arg.cursor_position[3] = vim.fn.strcharlen(parsed_below_line_text[1]) + first_char_position - 1 92 arg.cursor_position[2] = arg.cursor_position[2] + 1 93 -- カーソルが分かち書きした文字列の最後のノードにある 94 elseif text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 == arg.last_char_position then 95 arg.cursor_position[3] = text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 96 elseif i ~= #parsed_text_with_position then 97 -- カーソルが分かち書きした各ノードの最後の文字にある 98 if arg.cursor_position[3] == text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 then 99 arg.cursor_position[3] = parsed_text_with_position[i + 1][\u0026#39;end\u0026#39;] + arg.first_char_position - 1 100 else 101 arg.cursor_position[3] = text_with_position[\u0026#39;end\u0026#39;] + arg.first_char_position - 1 102 end 103 end 104 end 105 vim.fn.setcursorcharpos(arg.cursor_position[2], arg.cursor_position[3]) 106 break 107 end 108 end 109 end 110end 111 112for _, motion in ipairs({\u0026#39;w\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;ge\u0026#39;}) do 113 vim.keymap.set(\u0026#39;n\u0026#39;, motion, function () 114 -- コマンドの指定回数を取得する。回数が指定されていない場合の値は 1 である。 115 local count1 = vim.v.count1 116 while count1 \u0026gt; 0 do 117 local cursor_line_text = vim.fn.getline(\u0026#39;.\u0026#39;) 118 -- 行末の空白文字を残して分かち書き処理すると後処理が面倒なので削除する 119 local cursor_line_text_without_eol_space = vim.fn.substitute(cursor_line_text, \u0026#39;\\\\s\\\\+\\\\_$\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;g\u0026#39;) 120 -- 行頭の空白文字も残すと後処理が面倒なので削除する 121 local cursor_line_text_without_space = vim.fn.substitute(cursor_line_text_without_eol_space, \u0026#39;^\\\\s\\\\+\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;g\u0026#39;) 122 -- `b`, `ge` はカーソルが非空白文字の始めにあれば処理を分岐するので、非空白文字の始めの位置を取得しておく。 123 -- matchstrpos はパターンが1文字目に見つかったらインデックスを `0` `と返す 124 local first_char_position = vim.fn.matchstrpos(cursor_line_text, \u0026#39;^\\\\s\\\\+\u0026#39;)[3] + 1 125 -- 行頭に空白が無いと first_char_position が 0 になるので、強制的に値を 1 にする 126 if first_char_position == 0 then 127 first_char_position = first_char_position + 1 128 end 129 -- `w`, `e` はカーソルが非空白文字の末尾にあれば処理を分岐するので、非空白文字の末尾の位置を取得しておく。 130 local last_char_position = vim.fn.strcharlen(cursor_line_text_without_eol_space) 131 local parsed_text = tinysegmenter.segment(cursor_line_text_without_space) 132 local under_cursor_char = vim.fn.matchstr(cursor_line_text, \u0026#39;.\u0026#39;, vim.fn.col(\u0026#39;.\u0026#39;)-1) 133 local cursor_position = vim.fn.getcursorcharpos() 134 OverrideWordMotion({ 135 motion = motion, 136 cursor_line_text = cursor_line_text, 137 parsed_text = parsed_text, 138 cursor_position = cursor_position, 139 under_cursor_char = under_cursor_char, 140 first_char_position = first_char_position, 141 last_char_position = last_char_position 142 }) 143 count1 = count1 - 1 144 end 145 end) 146end 実装中に知った機能など vim.cmd.normal で normal! と同じ動作を実現する方法 vim.cmd.normal の引数に bang = true を渡すと、normal ではなく normal! と同じ意味になります。\nこれを活用することで、vim.cmd[[normal! w]] としていた部分を vim.cmd.normal({motion_type_variable, bang = true}) に変更できました。\n2w のような回数指定の回数を取得する方法 回数を指定していたらその回数だけ処理を繰り返すという機能を実現したかったのですが、vim.v.count1 に指定された回数が保存されていることが分かりましたので、この変数を使いました。回数が指定されていない場合のデフォルト値は 1 です。\nテーブル型変数の最後の要素にアクセスする方法 Lua にはテーブルの末尾にアクセスするメソッドはないようですが、#変数名 とすればテーブルの配列数を取得できますので、hoge_table というテーブル型の変数の最後の要素にアクセスするには hoge_table[#hoge_table] とすれば良いことが分かりました。\n文字列の置き換え カーソル行の行末にある空白文字を削除する必要がありましたが、Lua の文字列置き換え関数では UTF-8 の文字列を適切に扱えないため、代わりに Vim/Neovim のビルトイン関数の substitute() を使うことにしました。\n行末の空白文字を削除するには vim.fn.substitute(vim.fn.getline('.'), '\\\\s\\\\+\\\\_$', 'g') とすればOKです。\nなお、行頭の空白文字を削除するには vim.fn.substitute(vim.fn.getline('.'), '^\\\\s\\\\+', '', 'g') とすればOKです。\n未実装の機能 行を跨ぐ「アルファベットから日本語」、「日本語からアルファベット」への移動について、前者は通常の w, b, e, ge で処理し、後者は tinysegment で分かち書きした結果に基づいて移動するため、あるべき移動からずれた移動になることがあります。\nこれに対応するのは難しそうなので、現時点では対応していません。\n","link":"http://localhost:1313/post/2024-12-16/","section":"post","tags":["neovim","lua"],"title":"日本語を分かち書きして Word Motion で移動できるようにしました"},{"body":" 2024年12月15日追記あり 前置き tinysegmenter.nvim という Lua で日本語の分かち書きを実現するソフトウェアが登場しましたので、これを利用して、Neovim の Word Motion をオーバーライドしようと思ったのですが、その処理で日本語を含む文字列の長さを取得する必要が生じました。\n最初は簡単にできるだろうと考えていたのですが、いざやってみるとハマってしまったので、失敗した方法と成功した方法を備忘録として残します。\n実装例 まず、失敗したコードを示します。いずれのコードでも日本語1文字が1文字とカウントされていません。\n1print(string.len(\u0026#39;ああ\u0026#39;)) 2-\u0026gt; 6 1local M = {} 2for char in string.gmatch(\u0026#39;ああ\u0026#39;, \u0026#39;.?\u0026#39;) do 3 table.insert(M, char) 4end 5print(#M) 6-\u0026gt; 6 1:echo strlen(\u0026#39;ああ\u0026#39;) 2-\u0026gt; 6 一方、処理する文字列が ASCII 文字だと、同じコードでも1文字が1文字とカウントされます。\n1print(string.len(\u0026#39;aa\u0026#39;)) 2-\u0026gt; 2 1local N = {} 2for char in string.gmatch(\u0026#39;aa\u0026#39;, \u0026#39;.?\u0026#39;) do 3 table.insert(N, char) 4end 5print(#N) 6-\u0026gt; 2 1:echo strlen(\u0026#39;aa\u0026#39;) 2-\u0026gt; 2 処理する文字列が ASCII 文字か否かで結果が変わってしまうのですが、日本語の文字の長さが ASCII 文字の3倍になっているので、文字コードが原因ではないかと仮定しました。\nそこで、この仮説を踏まえて以下のコードを実行したところ、\u0026lt;e3\u0026gt;、\u0026lt;81\u0026gt;、\u0026lt;82\u0026gt;、\u0026lt;e3\u0026gt;、\u0026lt;81\u0026gt;、\u0026lt;84\u0026gt; という結果が得られました。これは あ の utf8 コードの E38182 の 1バイト目・2バイト目・3バイト目、い の utf8 コードの E38184 1バイト目・2バイト目・3バイト目がそれぞれ取り出されていると思われます。つまり、string は文字列を ASCII 文字として取り扱っているものと思われます。\n1vim.notify(string.sub(\u0026#39;ああ\u0026#39;, 1, 1)) 2vim.notify(string.sub(\u0026#39;ああ\u0026#39;, 2, 2)) 3vim.notify(string.sub(\u0026#39;ああ\u0026#39;, 3, 3)) 4vim.notify(string.sub(\u0026#39;いい\u0026#39;, 1, 1)) 5vim.notify(string.sub(\u0026#39;いい\u0026#39;, 2, 2)) 6vim.notify(string.sub(\u0026#39;いい\u0026#39;, 3, 3)) さらに、string に代えて utf8 で文字列を処理すると日本語の文字列が正しく処理されましたので、string が文字列を一律に ASCII 文字として扱っているのは間違いなさそうです。\n1print(utf8.len(\u0026#39;ああ\u0026#39;)) 2-\u0026gt; 2 1local U = {} 2for code in utf8.codes(\u0026#39;ああ\u0026#39;) do 3 table.insert(U, code) 4end 5print(#U) 6-\u0026gt; 2 よって、string の代わりに utf8 で処理すれば日本語の文字も正しく処理できるのですが、utf8 はバージョン 5.3 で導入された機能であり、バージョン 5.1 の Lua を使う Neovim では使えません。\n（utf8 がバージョン 5.3 で導入されたことは Lua 5.3 readme で確認できます）\nそこで、文字列を1文字ずつ分解して配列に格納し、その配列の長さを取得すれば文字列の長さを正しく取得できるのはないかと考えました。幸い、Neovim のビルトイン関数の split() は日本語の文字であっても1文字ずつ分解した結果を返してくれますので、split() と同じ組込み関数である len() と組み合わせて正しい文字列の長さを得ることができました。\n1vim.fn.len(vim.fn.split(\u0026#39;ああ\u0026#39;, \u0026#39;\\\\zs\u0026#39;)) 2-\u0026gt; 2 これで日本語の文字列の長さを正しく取得することができるようになりましたので、tinysegmenter.nvim を使って Neovim の Word motion をオーバーライドする方法を次の記事で紹介します。\n追記（2024年12月15日） 本記事を公開した後、vim-jp で strcharlen() を使う方法を提案されましたので、以下のコードでテストしたら簡単に日本語の文字列の長さを取得できました。そのため、上記の vim.fn.len(vim.fn.split('ああ', '\\\\zs')) のようなコードを書かなくても、vim.fn.strcharlen('ああ') と書けば正しい文字列の長さを取得できます。\n1:echo strcharlen(\u0026#39;ああ\u0026#39;) 2-\u0026gt; 2 補足 print(string.len('ああ')) の結果が 6 になることを応用すると、カーソル下の文字が ASCII 文字か否かを判断できます。以下のユーザー関数は、カーソル下の文字が ASCII 文字であれば true を、それ以外の文字であれば false を返します。\n1function IsASCIIChar() 2 local char_byte_count = string.len(vim.fn.matchstr(vim.fn.getline(\u0026#39;.\u0026#39;), \u0026#39;.\u0026#39;, vim.fn.col(\u0026#39;.\u0026#39;)-1)) 3 if char_byte_count == 1 then 4 return true 5 else 6 return false 7 end 8end 関数の処理内容は、まず、vim.fn.matchstr(vim.fn.getline('.'), '.', vim.fn.col('.')-1) でカーソル下の文字を取得します。それから、取得した文字の長さを string.len() で取得して char_byte_count 変数に格納します。取得した文字が ASCII 文字であれば長さは 1 になり、ASCII 文字以外であれば長さは 1 より大きくなります。\nそして、char_byte_count 変数の値が 1 なら ASCII 文字と判定し、1 でなければ ASCII 文字ではないと判定します。\n蛇足 split('ああ', '\\\\zs') というコードですが、これは、vimrc - How should I split a string with no spaces in vim script? - Unix \u0026amp; Linux Stack Exchange というサイトで見つけました。\nまた、AI を活用した有料検索サイトの Kagi search で「vim string split」と検索して、ヒットしたページの要約を作成してくれる Quick Answer を使ったところ、上記のページの要約として同じコードが紹介されました。\nこの Quick Answer は便利なサービスで、これまでは Google 検索の結果がイマイチだったので DuckDuckGo を使っていたのですが、最近は Kagi search を使うことも増えてきました。最初は有料版の機能をお試しで使うこともできますので、一度使ってみることをオススメします。\n","link":"http://localhost:1313/post/2024-12-14/","section":"post","tags":["Neovim","Lua"],"title":"Neovim の Lua で文字列の長さを取得しようとしたら苦労した話"},{"body":"前置き この記事は、キーボード #1 Advent Calendar 202411日目の記事です。前日の記事は、ゆびながモンキーさんの気楽にキーボード設計して天キー持っていこうぜって話｡ でした。天キーのキーボードのレベルが高いというのは私も実感するところでして、2023年3月の天キーに参加したときもハイレベルなキーボードが多数展示されていて、自分のキーボードを展示するのが少々気後れしました。\nさて、私がキーボードの記事でアドベントカレンダー向けに執筆するのは2020年以来です。キーボードから離れていた訳ではありませんが、記事のネタが無かったので参加できていませんでした。\n今回は、2020年のアドベントカレンダーの記事で「設計中です」としていたキーボードについて、やっと自分なりに満足できる形になってきましたので、このキーボードの設計の意図なんかを書いていきます。\n設計したキーボード このリポジトリにある「Yamanami Keyboard」の Cherry MX 版のキーボードです。\nYamanami Keyboard Cherry MX 自作キーボードでしばしば見かける OLED を搭載した上で、QMK Firmware の機能として用意されているものの実例はほとんど見かけない DIP スイッチを搭載したキーボードです。また、これらの部品を使えるだけのピン数を賄うため、RP2040 搭載ボードで GPIO ピンが20ピンある WaveShare RP2040 を使っています。\nキーボードに求めた機能 このキーボードは、以下の要求を見たすために設計しました。\n配列はColumn Staggerd 形状は左右分離型 キー数は48 親指で『Space/BackSpace、Lower/Raise、Win/CMD、Alt』キーが押せる プレートとケースは3Dプリントで作る qmk flash コマンドを実行しなくてもファームウェアを更新できる OS のキーボード配列を US(JIS) から JIS(US) に変更しても DIP スイッチ1つで対応できる キーキャップを US(JIS) から JIS(US) に変更しても DIP スイッチ1つで対応できる 現在のレイヤー設定がターゲットとしている OS のキーボード配列とキーキャップ配列を OLED に表示する 右手側の OLED にロゴを表示する 可能な限り keyboard.json に設定を書く PCBA に挑戦する 各機能を求めた理由 各機能を求めた理由は以下のとおりです。\n配列を Column Staggerd にした理由は、これまで Row Starggerd、Ortho Linear と使ってきた経験から、私の手に一番合うと思える物理配列が Column Staggerd だからです。 私は手が大きくないため、ホームポジションから手を動かさなくても良いキー数は48キーが限界です。 両腕を適度に広げるため形状を左右分離型にしました。左右分離型に慣れると一体型キーボードは窮屈に感じてしまいます。 親指で『Space/BackSpace、Lower/Raise』が押せることについては、こういうキー操作を実現するためにキーボードを設計しているので、当然必要な機能です。 プレートとケースを3Dプリンタで作成することについては、自宅で試行錯誤できて金属切削より安く済みますので、自作の醍醐味として盛り込んでいます。 PicoMicro の「.uf2 ファイルをコピペすればファームウェアを更新できる」という簡単な方法に慣れたため、引き続き同様の取り扱いができるようにしました。 7 の機能は、テレワークで職場のPC（OS のキーボード配列は JIS で固定）を使う場合に備えて盛り込んだ機能です。8 は 7 に関連して盛り込んだ機能で、7 を実現するなら 8 も実現したいということで盛り込みました。 9 は 7 と 8 に関連した機能で、DIP スイッチを切り替えたら OLED の表示を変更することで、現在のキーマップがどの環境をターゲットにしているか手元で確認するために盛り込みました。 10 は PCB 基板の裏面に印刷したロゴを手元側でも見たいということで盛り込みました。 11 は QMK Firmware が推奨している Data Driven Configuration に合わせるべく導入しました。なお、QMK の公式リファレンスでは info.json となっていますが、keyboard.json でも問題ありません。 12 は 自分の手間を減らすことと、Self-Maid Keyboards in Japan の方々が結構頼んでいるみたいなので、自分もやってみることにしました。作業を頼んでもそこまで高くならないのは助かりました。 なお、以前はマイコン直付け方式で設計したいと考えていましたが、マイコン直付けだと故障時の復旧が至難の技になるため、マイコンはマイコンボードを使う方法にしました。\n3Dプリンタで、マザーボードに直付けされたモータードライバーの1つが数ヶ月で壊れてしまい、修理できなくてボードごと買い替えるという事態に2回襲われたため、マイコンは直付けより外付けの方が良いと思うようになりました。 各機能の実装方法 これらの機能のうち、1-5は今回作ったキーボードの試作品（Yamanami Keyboard choc）で実現していました。\n6は RP2040 マイコンを使ったマイコンボードのファームウェア更新方法なので、RP2040 を使えば自動的に実現可能です。RP2040 を使う場合、keyboard.json に以下の設定を追加します。\n1 \u0026#34;bootloader\u0026#34;: \u0026#34;rp2040\u0026#34;, 2 \u0026#34;processor\u0026#34;: \u0026#34;RP2040\u0026#34;, 7 については、OS のキーボード配列が JIS キーボードの時の QMK Firmware の設定について で紹介した QMK Firmware の Key Override 機能と、QMK Firmware で DIP スイッチを使う方法 で紹介した DIP スイッチを使う方法を組み合わせて実現しました。\n具体的な実装方法は、まず、Key Override 機能を使って OS のキーボード配列が US の場合のキーマップと JIS の場合のキーマップを作成します。そして、DIP スイッチを使うための下準備をしてから keymap.c に dip_switch_update_mask_user() 関数を追加して switch 文で DIP スイッチの状態に合わせて set_single_persistent_default_layer() でデフォルトレイヤーを US 向け or JIS 向けの間で切り替えます。また、US 向けのキーマップでは Key Override 機能は使わないため、key_override_off() 関数を実行して Key Override を無効化します。JIS 向けのキーマップを使う場合、デフォルトレイヤーを切り替えるとともに、key_override_on() 関数を実行して無効化していた Key OVerride を再度有効化します。\n8 については、キーキャップを見ながら調整しないと頭が混乱しそうなので、 JIS キーキャップを入手するか3Dプリンタで一部の JIS キーキャップを印刷してからキーマップを作成する予定です。キーマップができたら、上の7と同様に実装していきます。\n9 と 10 については、QMK Firmware の OLED 機能を活用して対応しています。ロゴの作成に少し手間どりましたが、何とか満足できるロゴができました。ロゴを表示させる方法は QMK Firmware でオリジナルロゴを表示する方法 のとおりです。\nまた、デフォルトレイヤーの切り替えに伴う表示の切り替えでは、QMK Firmware で DIP スイッチを使う方法 で紹介した機能も一部用いています。\n失敗談や工夫した点など 失敗については、まず、久しぶりに設計したため、左右通信のピンや OLED のピンは左右で同じにしなければならないことを忘れていました。また、SPLIT_HAND_PIN で左右判定するためにチップ抵抗を取り付ける設計にしたのですが、JLCPCB から「フットプリントが違うから PCBA できない」と断われてしまいました。1.6x0.8mmのフットプリントを選んだつもりが 0.6x0.3mmのフットプリントを選んでいて、その大きさで抵抗値が合うチップ抵抗がなかったため、抵抗のPCBAは諦めました。この間違いの原因は、インチ表記とmm表記の見間違いです。\n幸い、いずれの問題も追加で半田付けで解決できましたので、基板裏面の半田付けは少々汚ないですが問題なく使えています。\n半田付けで解決したところ ただ、左右判定は問題ないのですが、右手側に USB ケーブルを差すと DIP スイッチが反応しなくなります。自力では解決策が見つからなかったため、QMK Firmware の GitHub の Issues で尋ねたところ、これは現在の仕様ということで、右手側に USB ケーブルを差した状態で左手側の DIP スイッチを使いたければ DIP スイッチをキーマトリックスに組み込む必要があるとのことでした。これは基板設計から変える必要があるので、まずブレットボードでテストしてから設計を変えようと思っています。\n一方、PCBA は始めての挑戦でしたが、ウェブにある先人の知恵を拝借することであっさりできました（前述のチップ抵抗除く）。ダイオードの半田付けをしなくても済むのは非常に楽でした。\nまた、基板外形の設計には KiCad の PCB Layout ではなく建築用CADの Jw_cad を使いました。Jw_cad だと「長さと角度を指定して線を引く」、「スイッチ取り付け穴の線から10mmオフセットした場所に線を引く」といった作業が簡単に行なえますし、図面を .dxf ファイル形式でも保存できます。そのため、Jw_cad で基板の外形線を書いて KiCad にインポートしました。\nJw_cad での設計 その上で、ケースやプレートなどの設計では、KiCad からエクスポートした 3D モデルを Fusion360 にインポートして仮想的な現物合わせをしながら設計しました。そのおかげか、USB ケーブルや TRRS ケーブルの差し込み口は 3Dプリンタで印刷してからサイズを調整する必要がありましたが、その他の部分は微調整で済みました。\nキーボードのマウント方式については、最初は以下のようにスイッチプレートから支柱までネジで固定して一体化したものをケースに載せる形を考えていました。これは、住宅の床の組み方をヒントにしたもので、打鍵時の衝撃を支柱を経由してケースに逃がす想定で設計しました。スイッチプレートを2.6mm厚に、スイッチプレートと PCB の間の隙間を3mm厚のプレートにすることである程度重くして、打鍵時の衝撃をまずは PCB と一体化したプレートで受け止めつつ、支柱を経由してケースに衝撃を逃がすという設計です。\nJw_cad での設計 これは思ったより良い感じでしたが、せっかく 3D プリンタがあって試行錯誤できるので、さらに変わったマウント方式を試すべく PCB の外周に当たる場所に窪みを付けてOリングを埋め込んで打鍵時の衝撃を吸収するという方法を試してみました。\nJw_cad での設計 この方法は思ったより良い感じで、柔らかいΟリングの上に、ある程度の重量を確保しているプレート\u0026amp;PCBが乗っかることで、打鍵時の衝撃が上手く分散されている感じです。また、場所による打鍵感の違いも感じられません。まあ、数万円の高級キーボードには勝てるとは思っていないですが、自分なりの工夫で良い感じにできたことには満足しています。\nまとめ 久しぶりの設計で色々失敗しましたが、今回は自分なりに結構上手くいったと思っていますし、やっぱりキーボードを設計していくこと自体が楽しいので、引き続きオリジナルキーボードを設計していきたいと思います。\n現時点で考えているキーボードは、カラーLCDを使ったマクロパッドです。アプリ毎にレイヤーを用意してショートカットキーを登録し、DIP スイッチでレイヤーを切り替えたら LCD に該当するアプリのロゴを表示する、というキーボードを考えています。カラーLCDの使い方は QMK Firmware でカラー LCD に画像を表示する方法 で解説していますので、よろしければご覧ください。\n本記事は、Yamanami Keyboard の Cherry MX 版で書きました。\n","link":"http://localhost:1313/post/2024-12-11/","section":"post","tags":["自作キーボード"],"title":"久しぶりにキーボードを設計した話"},{"body":"","link":"http://localhost:1313/tags/%E8%87%AA%E4%BD%9C%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89/","section":"tags","tags":null,"title":"自作キーボード"},{"body":"前置き Neovim でコマンドを実行したとき、実行結果が1行の文字列ならコマンドラインに結果が表示されるのですが、結果が Table 型だと table 0x... と表示されて中身を確認できません。\nこれではデバッグなどに支障をきたしますので、試行錯誤してコマンドの実行結果をバッファに出力させることに成功しましたので、その方法を備忘録としてまとめます。\n実装方法 コマンドの実行結果が Table 型であっても、表示するだけなら print() と vim.inspect() を組み合わせれば表示させられます。以下のコードはその実例で、その下の画像は実行結果です。\n1lua print(vim.inspect(vim.api.nvim_get_autocmds({pattern={\u0026#39;Ddu:uiDone\u0026#39;}}))) 同じコマンドを vim.inspect() を使わずに実行した場合、実行結果はコマンドラインに table: 0x... と表示されます。\n1-- `vim.inspect()` を使わない場合の表示 2lua print(vim.api.nvim_get_autocmds({pattern={\u0026#39;Ddu:uiDone\u0026#39;}})) 3-\u0026gt; table: 0x7faa0fcb7978 ただ、この方法は、毎回 lua print(vim.inspect(~~~)) と入力しなければならない上、何らかのキーをタイプすると結果が消えてしまいます。そこで、コマンド実行結果をバッファに出力させる方法を調べている時に発見した先例に従って、nvim_create_user_command を使って独自コマンドの Redir を作成し、その引数としてコマンド文字列を渡すと実行結果が新しいバッファで開かれるという形にしました。\n最初に作った設定は以下のとおりです。\n1vim.api.nvim_create_user_command(\u0026#39;Redir\u0026#39;, function(ctx) 2 local lines = vim.split(vim.fn.execute(ctx.args), \u0026#39;\\n\u0026#39;, { plain = true })) 3 vim.cmd(\u0026#39;new\u0026#39;) 4 vim.api.nvim_buf_set_lines(0, 0, -1, false, lines) 5 vim.opt_local.modified = false 6end, { nargs = \u0026#39;+\u0026#39;, complete = \u0026#39;command\u0026#39; }) 引数で渡されたコマンド文字列を vim.fn.execute() に渡して実行し、その結果を vim.split() で nvim_buf_set_lines() で処理できる形式に変換し、それから vim.cmd('new') で新しいバッファを作成したら nvim_buf_set_lines() でそのバッファに実行結果をセットしていました。\nしかし、コマンド間違いなどで vim.fn.execute() の実行結果がエラーになると vim.split() に渡される値が nil になるようで、新しいバッファに何も表示されません。そこで、vim.fn.execute() の実行結果がエラーになったらエラーメッセージをバッファに表示させるため、以下のとおりコードを修正しました。\n1vim.api.nvim_create_user_command(\u0026#39;Redir\u0026#39;, function(ctx) 2 local pcall_result, function_return = pcall(vim.fn.execute, ctx.args) 3 vim.cmd(\u0026#39;new\u0026#39;) 4 vim.api.nvim_buf_set_lines(0, 0, -1, false, vim.split(function_return, \u0026#39;\\n\u0026#39;, { plain = true })) 5 vim.opt_local.modified = false 6end, { nargs = \u0026#39;+\u0026#39;, complete = \u0026#39;command\u0026#39; }) 最初の設定との違いは、pcall 関数を使ってエラーメッセージを function_return に格納するようにしたことです。こうすると vim.fn.execute() の実行結果がエラーになってもエラーメッセージが function_return に格納されて vim.split() で処理できますので、新しいバッファに何も表示されないという事態を避けられますし、エラーメッセージがバッファに出力されます。\n実行例 1Redir :=vim.api.nvim_get_autocmds({pattern={\u0026#39;Ddu:uiDone\u0026#39;}}) 1-- `}` を1つ減らしてエラーになるようにしています 2Redir :=vim.api.nvim_get_autocmds({pattern={\u0026#39;Ddu:uiDone\u0026#39;}) ","link":"http://localhost:1313/post/2024-12-09/","section":"post","tags":["Neovim"],"title":"Neovim でコマンドの実行結果をバッファに出力する方法"},{"body":"","link":"http://localhost:1313/archives/2024/11/","section":"archives","tags":null,"title":"2024/11"},{"body":"前置き ddu.vim をファイラーやバッファの切り替えやヘルプの検索などに活用していますが、日々使っているとちょっとした不満も出てきます。\nどういう不満かと言いますと、ddu#start() で表示したリストを絞り込むには、リスト表示後に \u0026lt;Cmd\u0026gt;call ddu#ui#do_action(\u0026quot;openFilterWindow\u0026quot;)\u0026lt;CR\u0026gt; を実行してコマンドラインに移動する必要があるという点です。このコマンドを割り当てた i をタイプすれば絞り込みを始められますが、ヘルプ検索のように絞り込み必須の場合、毎回毎回 i をタイプするのが面倒だと感じていました。\nそこで、特定のリストを表示した時だけ自動的に絞り込みが始まるという設定を行いましたので、その内容を備忘録として残します。\n環境 1$ nvim --version 2NVIM v0.10.1 3Build type: Release 4LuaJIT 2.1.1713773202 1ddu.vim: commit f6480d2 2ddu-ui-ff: commit c1a8644 設定方法 私と同じことを考える人が他にもいるようで、ddu-ui-ff の FAQ-25 にそのための設定が掲載されています。。\nQ: I want to start filter window when UI is initialized.\nA: It is not supported. Because it has too many problems. But you can use the function.\n1call ddu#start() 2autocmd User Ddu:uiDone ++nested 3 \\ call ddu#ui#async_action(\u0026#39;openFilterWindow\u0026#39;) 問題が多いからその機能はサポートしないと回答されていますが、試してみてダメなら止めれば良いだけだと考えて、一度試してみることにしました\nこの機能の実装ですが、単純に考えれば FAQ で示されている設定を追加するだけでよさそうです。しかし、この設定を追加するだけでは別の問題が発生します。なぜなら、この設定は「ddu.vim の UI に全てのアイテムが表示された時（Ddu:uiDone）に call ddu#ui#async_action('openFilterWindow') を実行して絞り込みを開始する」というものなので、どのリストを表示しても自動的に絞り込みが始まってしまい、今度は絞り込み不要のリストを開いたときに esc をタイプして絞り込みを中止する必要が生じてしまいます。\nよって、「特定のソースを開く場合のみ上記の設定を実行し、そのソースのリストを閉じたら autocmd User Ddu:uiDone で設定したオートコマンドを削除する」という処理を実装する必要があります。\n結論から言いますと、以下の設定で上記の処理を実現できます。なお、私は Lua で設定していますので、Lua のコードを示します。\n1-- バグがあったため修正（2024/11/26） 2 3-- オートコマンドを削除する時の目印となるグループを設定 4-- グループ名は任意の値に設定できる 5local ddu_vim_autocmd_group = vim.api.nvim_create_augroup(\u0026#39;ddu_vim\u0026#39;, {}) 6 7-- 自動的に絞り込みを開始するソースは、ヘルプとファイルとする。 8vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;;h\u0026#39;, function() Ddu_start_with_filter_window(\u0026#39;help\u0026#39;) end) 9vim.keymap.set(\u0026#39;n\u0026#39;, \u0026#39;;f\u0026#39;, function() Ddu_start_with_filter_window(\u0026#39;file_recursive\u0026#39;) end) 10 11-- リスト表示とリストにアイテムが表示されたら絞り込みを開始する設定を行う関数 12function Ddu_start_with_filter_window(source_name) 13 -- 引数で指示されたソースのアイテムリストを表示 14 vim.fn[\u0026#39;ddu#start\u0026#39;]({name = source_name}) 15 -- リストにアイテムが表示されたら絞り込みを開始するというオートコマンドを設定 16 return vim.api.nvim_create_autocmd(\u0026#34;User\u0026#34;, 17 { 18 -- リストにアイテムが表示された時点をオートコマンドのタイミングに設定 19 pattern = \u0026#39;Ddu:uiDone\u0026#39;, 20 -- 後でオートコマンドを削除するための目印としてグループを設定 21 group = ddu_vim_autocmd_group, 22 nested = true, 23 callback = function() 24 -- 絞り込みを開始する 25 vim.fn[\u0026#39;ddu#ui#async_action\u0026#39;](\u0026#39;openFilterWindow\u0026#39;) 26 end, 27 } 28 ) 29end 30 31-- 絞り込み終了時点で `Ddu_start_with_filter_window()` 関数で設定したオートコマンドを 32-- 削除するというオートコマンドを設定する 33vim.api.nvim_create_autocmd({\u0026#39;User\u0026#39;}, 34 { 35 -- 絞り込みウィンドウを抜けた時点を自動コマンド実行のタイミングに設定 36 pattern = \u0026#39;Ddu:ui:ff:closeFilterWindow\u0026#39;, 37 callback = function() 38 -- `Ddu_start_with_filter_window()` 関数で設定したオートコマンドの ID を取得 39 -- 引数を Table で渡すと名前付き引数のように扱える 40 local autocmd_id = Get_autocmd_id({group = ddu_vim_autocmd_group, pattern = \u0026#39;Ddu:uiDone\u0026#39;}) 41 42 if autocmd_id ~= 0 then 43 -- `Ddu_start_with_filter_window()` 関数で設定したオートコマンドを削除 44 -- これを忘れるとリストを表示するたびに絞り込みが始まってしまう 45 vim.api.nvim_del_autocmd(autocmd_id) 46 end 47 end 48 } 49) 50 51-- 引数に対応するオートコマンドの ID を返す関数 52-- 引数は Table で渡されているので `args.xx` の形で取り出す 53function Get_autocmd_id(args) 54 local pcall_result, function_return = pcall( 55 vim.api.nvim_get_autocmds, { group = args.group, pattern = { args.pattern } } 56 ) 57 if pcall_result then 58 return function_return[1].id -- lua の配列の添字は 1 から始まる 59 else 60 return 0 61 end 62end コメントに各コードの意味を記載していますが、Ddu_start_with_filter_window() で設定したオートコマンドを絞り込み終了時点で削除しなかった場合、それ以降はリストを表示すると自動的に絞り込み処理が始まります。そのため vim.api.nvim_del_autocmd(autocmd_id_openfilterwindow) でオートコマンドを削除しています。この設定で少々つまずきました。\nなお、このオートコマンドの削除は nvim_get_autocmds() の検索結果が1つだけということを前提にしていますので、group と pattern で検索してヒットするオートコマンドが2つ以上あると処理が破綻します。そのため、ddu_vim_autocmd_group = vim.api.nvim_create_augroup('ddu_vim', {}) で用意した目印をオートコマンド作成時の group に設定しています。\nこの設定により、ヘルプやファイルのリストを表示したら自動的に絞り込みを始められる一方、それ以外のリストを表示した時は必要な時だけ絞り込みを行うという動作を実現できるようになりました。\n補足 リストを表示したら自動的に絞り込みを開始するという設定は、以前は startFilter = true という設定を追加するだけで可能だったようです。しかし、この設定は、問題が多すぎるということで2024年3月11日に削除されています（該当のコミット）。\n","link":"http://localhost:1313/post/2024-11-24/","section":"post","tags":["vim","neovim"],"title":"Neovim + ddu.vim で自動的にフィルタを開く方法"},{"body":"","link":"http://localhost:1313/tags/vim/","section":"tags","tags":null,"title":"Vim"},{"body":"問題の内容 箇条書きの各行の末尾で改行したら自動的に - を追加して欲しいので、vim.keymap.set(\u0026quot;i\u0026quot;, \u0026quot;\u0026lt;S-CR\u0026gt;\u0026quot;, \u0026quot;\u0026lt;CR\u0026gt;\u0026lt;cmd\u0026gt;AutolistNewBullet\u0026lt;cr\u0026gt;\u0026quot;) というキーバインドを設定しましたが、Shift-Enter をタイプしても単なる改行になっていました。\n1// 期待する動作 2- hogehoge⏎ ← 末尾で改行したら 3- | ← 自動的に `- ` を挿入してカーソルの位置を整えて欲しい 4 5// 実際の動作 6- hogehoge⏎ ← 末尾で改行したら 7| ← 単なる改行になってカーソルが行頭に来る \u0026lt;S-CR\u0026gt; を別のキーバインドに変更すると期待通りの動作になる上、他の機能はキチンと動作することから、プラグインの設定は問題ないと思われるのですが、\u0026lt;S-CR\u0026gt; だけが上手く動かない状態でした。\n解決策 同様の問題が起きていないか調べたところ、Shift-Enter にキーバインドを割り当てても動かないという問題を複数見つけました。それらの問題への回答によると、この問題は Vim の問題ではなく、ターミナルが受け取ったキー入力をシェルに渡す部分での問題ということでした。そのため、ターミナルに対して、Shift-Enter を受け取ったらシェルに Shift-Enter を渡すよう設定する必要があるとのことでした。\n幸いなことに、回答の中にターミナル毎の設定例が記載されており、Windows Terminal の設定例もありましたので、そちらを拝借して設定ファイルの actions に次のとおり設定を追加しました。\n1{ 2 \u0026#34;actions\u0026#34;: 3 [ 4 { 5 \u0026#34;command\u0026#34;: 6 { 7 \u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, 8 \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;2u\u0026#34; 9 }, 10 \u0026#34;id\u0026#34;: \u0026#34;User.sendInput.8882FD6D\u0026#34; 11 }, 12 { 13 \u0026#34;command\u0026#34;: 14 { 15 \u0026#34;action\u0026#34;: \u0026#34;sendInput\u0026#34;, 16 \u0026#34;input\u0026#34;: \u0026#34;\\u001b[13;5u\u0026#34; 17 }, 18 \u0026#34;id\u0026#34;: \u0026#34;User.sendInput.F8A79DCB\u0026#34; 19 } 20 ], これで期待通りの動作を実現することができました。\n1// 実現できた動作 2- hogehoge⏎ ← 末尾で改行したら 3- ← 自動的に `- ` が挿入される なお、現在の設定は次のとおりです。lazy.nvim を使ってプラグインを管理しているので、/lua/plugin/autolist-nvim.lua という名前で設定ファイルを作成しています。\n1return { 2 { 3 \u0026#34;gaoDean/autolist.nvim\u0026#34;, 4 ft = { 5 \u0026#34;markdown\u0026#34;, 6 \u0026#34;text\u0026#34;, 7 \u0026#34;tex\u0026#34;, 8 \u0026#34;plaintex\u0026#34;, 9 \u0026#34;norg\u0026#34;, 10 }, 11 config = function() 12 require(\u0026#34;autolist\u0026#34;).setup() 13 14 vim.keymap.set(\u0026#34;i\u0026#34;, \u0026#34;\u0026lt;tab\u0026gt;\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;AutolistTab\u0026lt;cr\u0026gt;\u0026#34;) 15 vim.keymap.set(\u0026#34;i\u0026#34;, \u0026#34;\u0026lt;S-tab\u0026gt;\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;AutolistShiftTab\u0026lt;cr\u0026gt;\u0026#34;) 16 vim.keymap.set(\u0026#34;i\u0026#34;, \u0026#34;\u0026lt;C-t\u0026gt;\u0026#34;, \u0026#34;\u0026lt;c-t\u0026gt;\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) -- an example of using \u0026lt;c-t\u0026gt; to indent 17 vim.keymap.set(\u0026#34;i\u0026#34;, \u0026#34;\u0026lt;S-CR\u0026gt;\u0026#34;, \u0026#34;\u0026lt;CR\u0026gt;\u0026lt;cmd\u0026gt;AutolistNewBullet\u0026lt;cr\u0026gt;\u0026#34;) 18 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026lt;cmd\u0026gt;AutolistNewBullet\u0026lt;cr\u0026gt;\u0026#34;) 19 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;O\u0026lt;cmd\u0026gt;AutolistNewBulletBefore\u0026lt;cr\u0026gt;\u0026#34;) 20 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;CR\u0026gt;\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;AutolistToggleCheckbox\u0026lt;cr\u0026gt;\u0026lt;CR\u0026gt;\u0026#34;) 21 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;C-r\u0026gt;\u0026#34;, \u0026#34;\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) 22 23 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;leader\u0026gt;cn\u0026#34;, require(\u0026#34;autolist\u0026#34;).cycle_next_dr, { expr = true }) 24 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;leader\u0026gt;cp\u0026#34;, require(\u0026#34;autolist\u0026#34;).cycle_prev_dr, { expr = true }) 25 26 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026gt;\u0026gt;\u0026#34;, \u0026#34;\u0026gt;\u0026gt;\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) 27 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) 28 vim.keymap.set(\u0026#34;n\u0026#34;, \u0026#34;dd\u0026#34;, \u0026#34;dd\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) 29 vim.keymap.set(\u0026#34;v\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;d\u0026lt;cmd\u0026gt;AutolistRecalculate\u0026lt;cr\u0026gt;\u0026#34;) 30 end, 31 }, 32} 参考にしたサイト vim - How to map Shift-Enter - Stack Overflow\n","link":"http://localhost:1313/post/2024-11-07/","section":"post","tags":["neovim"],"title":"Windows Terminal + WSL2 + Neovim で Autolist.nvim を使う場合のメモ"},{"body":"前置き 2年ぶりに新しいキーボードを設計しましたが、今回は DIP スイッチや OLED を使うようにしたので、右手側の OLED にオリジナルロゴを表示したいと思いました。\n試行錯誤してオリジナルロゴを表示できるようになりましたので、オリジナルロゴを表示する方法を備忘録としてまとめます。\nロゴを表示する方法 ロゴの作成 オリジナルロゴを表示する方法は2通りありますが、まずはロゴを作成する必要があります。ロゴを作成するときは、自分が使う OLED の解像度に合わせたサイズにする必要があります。私が使っている OLED は 128x32 の解像度なので、ロゴも同じ大きさで以下のとおり作成しました。\n表示したいロゴ ロゴが完成したら、ロゴを QMK Firmware が扱える形式に変換して表示しますが、変換・表示の方法は2つあるため、それぞれの方法を紹介します。\n変換したロゴを keymap.c に追加して画像として表示 オリジナルロゴの画像データを OLED で扱えるバイト列に変換し、そのバイト列を keymap.c ファイルに追加して QMK Firmware の API を使って画像として OLED に表示するという方法です。変換した画像データを keymap.c に追加して API で表示するだけなので、作業としてはこちらの方が楽です。\nまず、オリジナルロゴを OLED で扱えるバイト列に変換する必要がありますが、変換には image2cpp を使います。\nimage2cpp を開いたら、「1. Select image」のファイル選択でオリジナルロゴの画像データをアップロードします。それから以下のスクリーンショットの通りパラメータを設定して「Generate code」ボタンをクリックします。するとテキストエリアに変換されたバイト列が表示されますので、それを OLED にロゴを表示する処理を行うユーザー関数（ここでは render_logo()）にセットします。\nimage2cpp のパラメータなど 1// keymap.c 2static void render_logo(void) { 3 static const unsigned char PROGMEM raw_logo[] = { 4 // 変換したデータを `raw_logo[]` の値にセットします 5 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 6 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x0c, 0x02, 0x03, 0x02, 0x0c, 0x30, 7 ... 8 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x10, 0x20, 0x20, 0x20, 0x10, 0x3f, 0x00, 0x00, 0x00, 0x00 9 }; 10 oled_write_raw_P((const char *)raw_logo, sizeof(raw_logo)); 11} そして OLED の制御を担当する oled_task_user() 関数から render_logo() 関数を呼び出します。ここでは is_keyboard_left() 関数を使って右手側の OLED にのみロゴを表示するようにしています。\n1// keymap.c 2bool oled_task_user(void) { 3 if (!is_keyboard_left()) { 4 render_logo(); 5 } else { 6 // 左手側の OLED の制御処理 7 } 8 return false; 9} これでソースコードの編集は完了しましたので、ファームウェアをビルドします。ビルドしたファームウェアは左右それぞれのマイコンに書き込みます。キーマップの変更とは異なり、OLED の表示を変更する場合、左右それぞれのマイコンに新しいファームウェアを書き込む必要があるようです。\nこれで以下の写真のようにオリジナルロゴが表示されます。\nOLED に表示されたロゴ glcdfont.c のロゴ画像の部分を差し替える方法 QMK Firmware がデフォルトで使っている glcdfont.c には「英数字・記号・ロゴ」の3つのデータが含まれていますが、このうち、ロゴの部分をオリジナルロゴに差し替えて表示するという方法です。\nもう少し具体的に説明しますと、QMK Firmware が OLED に文字列を表示する場合、glcdfont.c の中から1文字ずつ対応するデータを取り出して順番に OLED に表示しています。以下の画像は glcdfont.c のデータを画像化したものですが、例えば「QMK」という文字列を表示する場合、glcdfont.c の81番目・77番目・75番目の文字を順番に表示して「QMK」という文字列を表示しています。\nhttps://qiita.com/koktoh/items/3d057e747915aee814cd の画像を加工 そして、この画像の左下に QMK のロゴがありますが、glcdfont.c はロゴを文字の集合として表現しています。そのため、glcdfont.c からこの部分の文字を順番に表示すれば QMK のロゴを表示できます。\nhttps://qiita.com/koktoh/items/3d057e747915aee814cd の画像を加工 公式リファレンスでロゴの表示方法として紹介されているのはこの方法で、glcdfont.c のロゴの部分のデータを任意のデータに差し替えればオリジナルロゴを表示できます。この方法の大まかな流れは次のとおりです。\nglcdfont.c のデータを画像化したファイルを入手する のファイルを画像編集アプリで編集し、既存のロゴをオリジナルロゴに差し替える。 のファイルを QMK Logo Editor で変換する で変換したデータを使ってオリジナルの glcdfont.c を作成して適当な場所に保存する config.h で 4. の glcdfont.c を使うように設定する まず、glcdfont.c のデータを画像化した上記のファイルが必要ですが、QMK Logo Editor にアクセスして「Download Image」をクリックすれば以下の画像が入手できます（QMK Firmware に上記のファイルは含まれていないようです）。上の画像と少し異なりますが、今回の目的を果たす上では違いは無視できます（上の画像は説明のために文字の間に区切りを追加したものです）。\nQMK Logo Editor からダウンロードした画像 画像ファイルを入手したら、画像編集アプリを使って下の画像の赤枠の部分をオリジナルロゴに差し替えます。なお、この赤枠の部分のサイズは 125x24 ピクセルなので、最初に作ったロゴ（128x32）に差し替えるには画像を縮小する必要があります。\nオリジナルロゴに差し替える部分 差し替え後の画像は以下のとおりです。実際に編集するときは、赤枠内の差し替えた画像の線をもう少し修正する必要があると思います。\n編集後の画像 画像の編集が完了したら、QMK Logo Editor に再びアクセスして「Font」タブの「Upload Image」をクリックして編集後のファイルをアップロードします。すると、表示されている画像がアップロードしたものに変更され、テキストエリアにアップロードした画像をバイト列に変換した結果が表示されます。\nアップロード後の画面 変換結果が表示されたら、QMK Firmware の drivers/oled/glcdfont.c をロゴを表示したいキーボードのディレクトリ（ここでは keyboards/yamanami_cherry）にコピーして、static const unsigned char font[] PROGMEM = {} の中身を変換結果に置き換えます。\n1// glcdfont.c 2static const unsigned char font[] PROGMEM = { 3 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 4 0xC1, 0xA4, 0xB0, 0xA4, 0xC1, 0xFF, 5 ... 6 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 7}; それから、config.h に以下の設定を追加して、drivers/oled/glcdfont.c の代わりに keyboards/yamanami_cherry/glcdfont.c を使うよう設定します。\n1// config.h 2#define OLED_FONT_H \u0026#34;keyboards/yamanami_cherry/glcdfont.c\u0026#34; そして、keymap.c に以下のコードを追加します。\n1// keymap.c 2static void render_logo(void) { 3 static const char PROGMEM qmk_logo[] = { 4 // ロゴの部分のインデックスを指定しています 5 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 6 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 7 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0x00 8 }; 9 oled_write_P(qmk_logo, false); 10} 11 12bool oled_task_user(void) { 13 render_logo(); 14 return false; 15} あとはファームウェアをビルドして左右それぞれのマイコンに書き込めば、オリジナルロゴが OLED に表示されるはずです。glcdfont.c に合わせるため縮小したこともあり、先程のロゴと形が少し変わっています。\nOLED に表示されたロゴ なお、この方法は「glcdfont.c のロゴの部分を順番に取り出して表示する」という方法ですので、上記の qmk_logo[] の内容を変えるとロゴの表示が壊れます。試しに、上記のコードの 0xC0 の行を1行目に移動させて以下のコードのようにすると、写真のとおり OLED 下側の「Keyboard」という文字列のラインが上に移動して表示が壊れています。\n1// keymap.c 2static void render_logo(void) { 3 static const char PROGMEM qmk_logo[] = { 4 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 5 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 6 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0x00 7 }; 8 oled_write_P(qmk_logo, false); 9} // 以下同じ 表示が壊れたロゴ 補足 2つの方法の使い分け ロゴを表示する方法として2つの方法を紹介しましたが、この2つの方法を比較すると次のような感じになると思いますので、これを参考にしてどちらを採用するか検討すれば良いと思います。\n作業量 使える画像サイズ ロゴを画像として表示する方法 少ない OLED の解像度と同じ ロゴを文字列として表示する方法 多い 125x24 参考にしたサイト OLED Driver | QMK Firmware QMK の OLED 基礎知識 #oled - Qiita QMK FirmwareでOLEDに好きな画像を映す MakotoKurauchi/helix - Doc/firmware_jp.md ","link":"http://localhost:1313/post/2024-11-05/","section":"post","tags":["自作キーボード"],"title":"QMK Firmware でオリジナルロゴを表示する方法"},{"body":"","link":"http://localhost:1313/archives/2024/10/","section":"archives","tags":null,"title":"2024/10"},{"body":"前置き Neovim で C言語の LSP を設定した上で自作キーボードのファームウェアの QMK Firmware（大半のコードがC言語） を編集しているのですが、下のスクリーンショットのとおり大量の \u0026quot;unknown type name\u0026quot; とか \u0026quot;call to undeclare\u0026quot; エラー表示が出ていました。\nエラーが出ている様子 エラー表示はたくさん出ていますが、ファームウェアはコンパイルできますしキーボードもきちんと動作します。つまり、必要な型定義や関数定義はできており、問題はエディタにたくさんのエラーが出て精神衛生上よろしくないという問題に過ぎないのですが、思い切って対応することにしました。\n対応策 結論から言いますと、プロジェクトのルートディレクトリに compile_commands.json が存在しなかったのが原因でした。\nこの compile_commands.json を QMK Firmware の qmk generate-compilation-database コマンドで作成したところ、下のスクリーンショットのとおり \u0026quot;unknown type name\u0026quot; とか \u0026quot;call to undeclare\u0026quot; エラー表示が消えました。\nエラーを解消した様子 解決に至るまでの過程を説明しますと、まず、この問題を Slack の vim-JP で相談したら LSP の clangd の設定の問題ではないかとアドバイスされました。そこで公式リファレンス を確認したところ、\u0026quot;Neovim built-in LSP client\u0026quot; を使っている場合の設定方法が以下のとおり記載されていましたので、まずその設定を追加しました。\n1local lspconfig = require(\u0026#39;lspconfig\u0026#39;) 2lspconfig.clangd.setup({ 3 cmd = {\u0026#39;clangd\u0026#39;, \u0026#39;--background-index\u0026#39;, \u0026#39;--clang-tidy\u0026#39;, \u0026#39;--log=verbose\u0026#39;}, 4 init_options = { 5 fallbackFlags = { \u0026#39;-std=c++17\u0026#39; }, 6 }, 7}) 次に、公式リファレンスでは clangd にソースコードを理解させるために compile_commands.json を作成するよう書かれていました。そこで compile_commands.json を作成しようとしたのですが、ここでちょっとしたトラブルに遭遇しました。\nというのも、QMK Firmware のビルドは qmk compile コマンドで実施しており、make コマンドなどは使わないのですが、そういう場合の対処方法として、公式リファレンスでは Bear というツールを使うよう指示されていたためです。ただ、この目的のためだけにツールをインストールするのは面倒ですし、このツールが qmk compile コマンドを受け付けるかも分からなかったためです。\nそこで色々調べていたのですが、ふと QMK Firmware の公式リファレンスの QMK CLI Commands を見たところ、qmk generate-compilation-database コマンドで compile_commands.json を作成できることが分かりました。そこでこのコマンドを実行したところ、問題なく compile_commands.json が作成できてエラー表示を解消することができました。\n大した話ではありませんが、誰かの参考になるかもしれませんので、備忘録として記事を作成しました。\n補足 私は clangd を mason.nvim でインストールし、mason-lspconfig.nvim 経由で nvim-lspconfig で設定していますが、nvim-lspconfig が用意しているデフォルト設定は clangd の公式リファレンスとある程度同じでした。後で上記の設定を削除してみましたがエラー表示の状況は同じでしたので、エラー表示の解消のためだけなら上記の設定は不要かもしれません。ただ、上記の設定はログのトレースや追加機能を使うための設定とのことなので、設定しても無駄にはならないかと思います。\n","link":"http://localhost:1313/post/2024-10-15/","section":"post","tags":["neovim","vim"],"title":"Neovim の LSP 設定を見直してエラー表示を解消した話"},{"body":"前置き 構想中の左手用キーボードでカラー LCD を使うためのテストとして Raspberry pi pico でカラー LCD を使ってみたのですが、使うためには公式リファレンスの Quantum Painter に加えて SPI Master Driver も確認する必要があり、色々苦労しましたので、使い方を忘れないうちに備忘録としてまとめます。\n環境 QMK Firmware 1❯ qmk --version 21.1.5 マイコン Raspberry Pi Pico を使います。\nカラーLCD Tztft-arduino用LCDディスプレイモジュール,ラウンド,rgb,240x240,gc9a01ドライバー,4ワイヤー,spiインターフェイス,240x240, PCB, 1.28インチ - AliExpress 502 を使っています。LCDドライバーが GC9A01 であれば同じ方法で使えると思います。\nなお、現在の QMK Firmware が対応している LCD ドライバは、公式リファレンスの \u0026quot;Supported devices\u0026quot; で確認できます。私は丸型のディスプレイを使ってみたかったので、上記の商品を選択しました。\n事前準備 ここから LCD に画像を表示するための事前準備について説明します。なお、本記事の執筆時点ではカラー LCD の設定は (keyboard_name).json に書けないため、config.h や rules.mk に設定します。\nまた、カラー LCD にはテキストや図形も描画できますが、私が描画したいのは画像なので、画像を描画するための設定を説明します。\nrules.mk rules.mk にカラー LCD のドライバに合わせた設定を書きます。今回使うドライバは GC9A01 なので、公式リファレンスに従って以下の設定を追加します。\n1# rules.mk 2QUANTUM_PAINTER_ENABLE = yes 3QUANTUM_PAINTER_DRIVERS += gc9a01_spi rules.mk には LCD に表示する画像ファイルの設定も書きますが、その点は後ほど説明します。\nconfig.h config.h に公式リファレンスの Quantum Painter と SPI Master Driver に従って LCD と SPI の設定を追加します。\nLCD の設定 LCD の設定は以下のとおりです。大まかな説明はコメントに書いていますので、細かい説明はコードの後に書きます。\n1/* config.h */ 2 3// マイコンと LCD の通信に使うピンを定義 4// Raspberry pi pico の SPI0 のピンの近くのピンを適当に選択 5#define LCD_RST_PIN GP4 6#define LCD_DC_PIN GP6 7#define LCD_CS_PIN GP5 8#define LCD_BLK_PIN GP10 9 10// マイコンの動作クロックを割り算するための値 11#define LCD_SPI_DIVISOR 2 12 13// 画像を回転させないので回転角度を 0°に設定 14#define LCD_ROTATION QP_ROTATION_0 15 16// 今回の LCD の解像度（240x240）を設定 17#define LCD_HEIGHT 240 18#define LCD_WIDTH 240 19 20// ドライバとディスプレイで原点にズレがないためオフセットは0に設定 21#define LCD_OFFSET_X 0 22#define LCD_OFFSET_Y 0 23 24// 今回の LCD では色を反転させる必要がないのでコメントアウト 25//#define LCD_INVERT_COLOR 26 27// 256色の画像を扱うための設定 28#define QUANTUM_PAINTER_SUPPORTS_256_PALETTE TRUE 29 30// LCD に表示させる画像の数を設定 31#define QUANTUM_PAINTER_NUM_IMAGES 9 32 33// 画面を常時点灯にするためタイムアウト時間を 0 に設定 34#define QUANTUM_PAINTER_DISPLAY_TIMEOUT 0 #define LCD_SPI_DIVISOR 4 マイコンの動作クロックを割り算して SPI デバイスの動作クロックに合わせるための設定のようです。Raspberry pi pico の RP2040 の動作クロックが 125MHz というのは分かるのですが、GC9A01 の動作クロックが分からなかったので、とりあえずデフォルト値の 2 にしています。\n#define LCD_ROTATION 画像を回転させる角度を指定します。回転は90°単位で、QP_ROTATION_0、QP_ROTATION_90、QP_ROTATION_180、QP_ROTATION_270 の中から選択します。\n#define QUANTUM_PAINTER_SUPPORTS_256_PALETTE 256色のカラー画像またはモノクロ画像を扱う時に必要な設定です。もし、65536色の画像を扱う時は QUANTUM_PAINTER_SUPPORTS_NATIVE_COLORS を TRUE に、16777216色の画像を扱う時は QUANTUM_PAINTER_SUPPORTS_NATIVE_COLORS を TRUE に設定します。\n#define QUANTUM_PAINTER_NUM_IMAGES LCD に表示させる画像の数を設定するものですが、デフォルト値が 8 なので大抵の場合は設定不要ではないかと思います。今回はテストなのでデフォルト値を越えた数の画像を扱う設定にしています。\n#define QUANTUM_PAINTER_DISPLAY_TIMEOUT デフォルト値の 30000 だと画面が30秒で暗転するので、0 を設定して常時点灯にしています。\nSPI の設定 SPI は以下のとおり設定しています。大まかな説明はコメントに書いていますので、細かい説明はコードの後に書きます。\n1/* config.h */ 2 3// マイコンと LCD の通信に使うピンを定義 4// Raspberry pi pico の SPI0 のピンから適当に選択 5#define SPI_SCK_PIN GP2 6#define SPI_MOSI_PIN GP3 7 8// LCD にMISO ピンに当たる端子が無いので `NO_PIN` を設定 9#define SPI_MISO_PIN NO_PIN 10 11#define SPI_DRIVER SPID0 12#define SPI_MODE 0 #define SPI_MOSI_PIN この設定には苦労しました。というのも、商品ページでは SPI 通信対応と書いてあるのに、実際の商品に書かれているピンの名称は I2C 通信で使う \u0026quot;SDA\u0026quot; や \u0026quot;SCL\u0026quot; なので、どう対応するかが分かりませんでした。参考にしたサイトで「SCL ⇔ SCK」、「SDA ⇔ TX ⇔ MOSI」という対応が書かれているのを見つけられたので何とか設定できました。\n#define SPI_DRIVER SPI_DRIVER はデフォルトで \u0026quot;SPI2\u0026quot; を使う設定になっていますが、Raspberry pi pico に \u0026quot;SPI2\u0026quot; はありませんので、\u0026quot;SPI0\u0026quot; を使う設定にしています。\n#define SPI_MODE SPI_MODE には 0 - 3 の値が設定可能で、手元の LCD が動いたのは 0, 1, 3 なので、参考にしたサイトと同じ 0 を選択しています。ドライバによっては 3 でないと動かないものもあるみたいです。\nここまでの設定のうち、Raspberry pi pico と LCD の通信にかかるピンの設定を抜粋すると次表のとおりとなります。Raspberry pi pico と LCD を結線するときの参考になります。\nconfig.h Raspberry pi pico GPIO Pin LCD Pin LCD_RST_PIN GP4 RES LCD_DC_PIN GP6 DC LCD_CS_PIN GP5 CS LCD_BLK_PIN GP10 BLK SPI_SCK_PIN GP2 SCL SPI_MOSI_PIN GP3 SDA mcuconf.h 参考にしたサイトでは mcuconf.h を config.h と同じ場所に作成して以下の設定を書くよう示されていますが、私が試した限りでは mcuconf.h が無くても大丈夫みたいです。なお、以下の設定は参考にしたサイトのコードをそのままコピペしていますので、上の設定を踏まえるなら \u0026quot;SPI1\u0026quot; は \u0026quot;SPI0\u0026quot; になります。\n1/* mcuconf.h */ 2 3#pragma once 4 5#include_next \u0026lt;mcuconf.h\u0026gt; 6 7#undef RP_SPI_USE_SPI1 8#define RP_SPI_USE_SPI1 TRUE 9 10#undef RP_PWM_USE_PWM3 11#define RP_PWM_USE_PWM3 TRUE halconf.h SPI 通信を使うため、halconf.h を config.h と同じ場所に作成して以下の設定を追加します（公式リファレンスの ChibiOS/ARM Configuration 参照）。\n1/* halconf.h */ 2 3#define HAL_USE_SPI TRUE 4#define SPI_USE_WAIT TRUE 5#define SPI_SELECT_MODE SPI_SELECT_MODE_PAD これはマイコンが ARM の場合の設定ですので、マイコンが AVR の場合の設定は公式リファレンスの AVR Configuration で確認してください。\nLCD に表示する画像の作成 次は LCD に表示する画像を作成します。大まかな手順は次のとおりです。\n画像を保存するディレクトリを作成します。 表示したい画像をディレクトリに保存します 画像のサイズを LCD の解像度に合わせて 240x240 にします qmk painter-convert-graphics コマンドで画像を QMK 対応形式（.qgf）に変換します。 rules.mk に変換した画像を使うための設定を追加します。 keyboards/test/images/icon.png を16色の .qgf ファイルに変換して同じディレクトリに保存するコマンドは次のとおりです。なお、256色とか65536色の画像にも変換できますが、試した限りでは、16色で必要充分かなと思います。高画質にするほどファームウェアの容量も大きくなりますので、適宜調整してください。\n1qmk painter-convert-graphics -f pal16 -v -i keyboards/test/images/icon.png このコマンドを実行すると images/ ディレクトリに icon.qgf.h と icon.qgf.c が生成されます。画像を変換したら、変換した .qgf ファイルを QMK で使うため rules.mk に設定します。\n1# rules.mk 2 3SRC += images/icon.qgf.c 使いたい画像が複数ある場合、上記の手順を必要なだけ繰り返します。\nなお、painter-convert-graphics コマンドのオプションは qmk painter-convert-graphics --help で確認できます。\nLCD に画像を表示するための設定 これでようやく事前準備ができましたので、実際に LCD に画像を表示する処理を書いていきます。\nLCD に画像を表示する処理は keymap.c に書けますが、keymap.c には本来のキーマップの処理だけを書きたいので、test_color_lcd.c ファイルを作成してそこに書くことにしました。なお、test_color_lcd.c というファイル名は、このカラー LCD のテストをするためのキーボード名を便宜的に \u0026quot;test_color_lcd\u0026quot; にしているためです。\n画像を表示するコードは以下のとおりです。簡単な説明はコメントに書いていますが、この後で細かい説明を追記します。なお、このコードは、9つの画像をキー操作に応じて切り替えるという動作を実現するためのものです。\n1/* test_color_lcd.c */ 2 3// LCD に表示するための API を使うためのインクルード 4#include \u0026lt;qp.h\u0026gt; 5 6// LCD に表示する画像のヘッダファイルをインクルードします 7#include \u0026#34;images/blender.qgf.h\u0026#34; 8#include \u0026#34;images/clipstudio.qgf.h\u0026#34; 9#include \u0026#34;images/excel.qgf.h\u0026#34; 10#include \u0026#34;images/fusion360.qgf.h\u0026#34; 11#include \u0026#34;images/illustrator.qgf.h\u0026#34; 12#include \u0026#34;images/kicad.qgf.h\u0026#34; 13#include \u0026#34;images/photoshop.qgf.h\u0026#34; 14#include \u0026#34;images/qmk.qgf.h\u0026#34; 15#include \u0026#34;images/steam.qgf.h\u0026#34; 16 17// コードから LCD を扱うための変数を用意します 18// この後の dip_switch_update_mask_kb() でも使うのでグローバル変数にしています 19painter_device_t lcd; 20 21// コードから LCD に表示する画像を扱うための変数を用意します 22// この後の dip_switch_update_mask_kb() でも使うのでグローバル変数にしています 23painter_image_handle_t blender_logo; 24painter_image_handle_t clipstudio_logo; 25painter_image_handle_t excel_logo; 26painter_image_handle_t fusion360_logo; 27painter_image_handle_t illustrator_logo; 28painter_image_handle_t kicad_logo; 29painter_image_handle_t photoshop_logo; 30painter_image_handle_t qmk_logo; 31painter_image_handle_t steam_logo; 32 33// キーボード初期化の最終処理の段階で LCD を描画する 34void keyboard_post_init_kb(void) { 35 // LCD を定義します 36 lcd = qp_gc9a01_make_spi_device( 37 LCD_HEIGHT, 38 LCD_WIDTH, 39 LCD_CS_PIN, 40 LCD_DC_PIN, 41 LCD_RST_PIN, 42 LCD_SPI_DIVISOR, 43 SPI_MODE 44 ); 45 46 // LCD を初期化します 47 qp_init(lcd, LCD_ROTATION); 48 49 // LCD のオフセット位置を指定します 50 qp_set_viewport_offsets(lcd, LCD_OFFSET_X, LCD_OFFSET_Y); 51 52 // LCD をオンにします 53 qp_power(lcd, true); 54 55 // .qgfファイルの画像を変数に格納します 56 blender_logo = qp_load_image_mem(gfx_blender); 57 clipstudio_logo = qp_load_image_mem(gfx_clipstudio); 58 excel_logo = qp_load_image_mem(gfx_excel); 59 fusion360_logo = qp_load_image_mem(gfx_fusion360); 60 illustrator_logo = qp_load_image_mem(gfx_illustrator); 61 kicad_logo = qp_load_image_mem(gfx_kicad); 62 photoshop_logo = qp_load_image_mem(gfx_photoshop); 63 qmk_logo = qp_load_image_mem(gfx_qmk); 64 steam_logo = qp_load_image_mem(gfx_steam); 65 66 // blender_logo を X=0 Y=0 の位置に描画します 67 qp_drawimage(lcd, 0, 0, blender_logo); 68 69 // LCD の表示を更新します 70 qp_flush(lcd); 71} 以下ではもう少し細かい説明を書いていきます。\n#include \u0026quot;images/blender.qgf.h\u0026quot; キーボードが起動した時点では表示しない画像までインクルードしているのは、キー操作に応じて画像を切り替える処理の中で画像を動的に読み込んだら LCD がフリーズしたためです。おそらく、メモリ容量の限界にぶつかったのではないかと思います。QMK の qp_close_image() 関数で読み込んだ画像を解放しながら動的に画像を読み込めばメモリの問題は回避できると思いますが、その処理を書くのが面倒だったので、最初の段階で全ての画像を読み込むようにしました。\nkeyboard_post_init_kb() キーボード初期化の最後の段階で LCD の設定をしていますが、初期化の最後の段階で何か処理するのであれば keyboard_post_init_user() に書いてもOKです。私は公式リファレンスが keyboard_post_init_kb に処理を書いていたので、同様にしています。\nqp_gc9a01_make_spi_device LCD を定義する関数で、この関数は GC9A01 用です。公式リファレンスに LCD のドライバ毎にどの関数を使うかが説明されていますので、自分が使うドライバに合った関数を使います。\nqp_load_image_mem() LCD に表示する画像を変数に格納する関数です。引数は、.qgf.c で定義されている画像データの定数です。\nqp_flush(lcd) qp_drawimage(lcd, 0, 0, blender_logo) で画像を描画しても、qp_flush() 関数を実行しないと LCD の表示が更新されません。そのため、qp_drawimage() と qp_flush() はセットで使う必要があります。\nキー操作に応じて画像を切り替える 上記の設定でキーボード起動後に LCD に画像が表示されるようになりますが、画像1枚を表示するだけでは面白くないので、キーを押す度に画像が切り替わる設定を keymap.c に追加します。上で説明した画像表示の応用なので、処理の説明はコメントを参照してください。\n実際の動作は次の動画のとおりです。\n1/* keymap.c */ 2 3#include QMK_KEYBOARD_H 4 5// test_color_lcd.c で定義したグローバル変数を利用します 6extern painter_device_t lcd; 7extern painter_image_handle_t blender_logo; 8extern painter_image_handle_t clipstudio_logo; 9extern painter_image_handle_t excel_logo; 10extern painter_image_handle_t fusion360_logo; 11extern painter_image_handle_t illustrator_logo; 12extern painter_image_handle_t kicad_logo; 13extern painter_image_handle_t photoshop_logo; 14extern painter_image_handle_t qmk_logo; 15extern painter_image_handle_t steam_logo; 16 17// 画像切り替え用のキーコードを定義します 18enum custom_keycodes { 19 QWERTY = SAFE_RANGE, 20 forward, 21 back 22}; 23 24const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { 25 [0] = LAYOUT( forward, back ) 26}; 27 28// キータイプ毎に実行される process_record_user() に画像切り替え処理を書きます 29bool process_record_user(uint16_t keycode, keyrecord_t *record) { 30 // キーを押した回数を保存する変数を静的変数として宣言 31 static uint16_t counter = 0; 32 switch (keycode) { 33 case forward: 34 // 画像切り替えをループさせるための条件分岐 35 if (record-\u0026gt;event.pressed) { 36 if (counter \u0026lt; 8) { 37 counter++; 38 } 39 else { 40 counter = 0; 41 } 42 switch (counter) { 43 case 0: 44 qp_drawimage(lcd, 0, 0, blender_logo); 45 qp_flush(lcd); 46 break; 47 case 1: 48 qp_drawimage(lcd, 0, 0, clipstudio_logo); 49 qp_flush(lcd); 50 break; 51 case 2: 52 qp_drawimage(lcd, 0, 0, excel_logo); 53 qp_flush(lcd); 54 break; 55 case 3: 56 qp_drawimage(lcd, 0, 0, fusion360_logo); 57 qp_flush(lcd); 58 break; 59 case 4: 60 qp_drawimage(lcd, 0, 0, illustrator_logo); 61 qp_flush(lcd); 62 break; 63 case 5: 64 qp_drawimage(lcd, 0, 0, kicad_logo); 65 qp_flush(lcd); 66 break; 67 case 6: 68 qp_drawimage(lcd, 0, 0, photoshop_logo); 69 qp_flush(lcd); 70 break; 71 case 7: 72 qp_drawimage(lcd, 0, 0, qmk_logo); 73 qp_flush(lcd); 74 break; 75 case 8: 76 qp_drawimage(lcd, 0, 0, steam_logo); 77 qp_flush(lcd); 78 break; 79 } 80 } 81 break; 82 case back: 83 if (record-\u0026gt;event.pressed) { 84 if (counter \u0026gt; 0) { 85 counter--; 86 } 87 else { 88 counter = 8; 89 } 90 switch (counter) { 91 case 0: 92 qp_drawimage(lcd, 0, 0, blender_logo); 93 qp_flush(lcd); 94 break; 95 case 1: 96 qp_drawimage(lcd, 0, 0, clipstudio_logo); 97 qp_flush(lcd); 98 break; 99 case 2: 100 qp_drawimage(lcd, 0, 0, excel_logo); 101 qp_flush(lcd); 102 break; 103 case 3: 104 qp_drawimage(lcd, 0, 0, fusion360_logo); 105 qp_flush(lcd); 106 break; 107 case 4: 108 qp_drawimage(lcd, 0, 0, illustrator_logo); 109 qp_flush(lcd); 110 break; 111 case 5: 112 qp_drawimage(lcd, 0, 0, kicad_logo); 113 qp_flush(lcd); 114 break; 115 case 6: 116 qp_drawimage(lcd, 0, 0, photoshop_logo); 117 qp_flush(lcd); 118 break; 119 case 7: 120 qp_drawimage(lcd, 0, 0, qmk_logo); 121 qp_flush(lcd); 122 break; 123 case 8: 124 qp_drawimage(lcd, 0, 0, steam_logo); 125 qp_flush(lcd); 126 break; 127 } 128 } 129 break; 130 return true; 131} 参考にしたサイト Quantum Painter | QMK Firmware SPI Master Driver | QMK Firmware [自作キーボード]QMKファームウェアでカラーLCDに対応する～基本編～ - QUEFRENCY Quantum Painter tutorial OakNinja - qmk_firmware ","link":"http://localhost:1313/post/2024-10-14/","section":"post","tags":["自作キーボード"],"title":"QMK Firmware でカラー LCD に画像を表示する方法"},{"body":"前置き 現在設計中のキーボードに DIP スイッチでデフォルトレイヤーを切り替える機能を登載するのですが、公式リファレンスの説明だけではつまずいてしまいそうなポイントもあったため、備忘録として使い方をまとめます。\n環境 QMK Firmware 1❯ qmk --version 21.1.5 マイコン RP2040 を登載しているボードを使います。なお、テストに使ったマイコンボードは以下の3つです。\nRaspberry Pi Pico RP2040-Zero XIAO RP2040 実装 ここから実装方法を書いていきますが、昨今の QMK Firmware の Data Driven Configuration | QMK Firmware の考え方に従って、可能な限り (keyboard_name).json に設定を記載する方法で進めていきます。なお、毎回 (keyboard_name).json とカッコ付きで書くのは面倒なので、以下では keyboard.json と書いていきます。\nkeyboard.json DIP スイッチを使う場合、keyboard.json に次の設定を追加します。ちなみに、DIP スイッチをキーマトリックスの中に組み込む方法もあるようですが、今回は試していません。\n1\u0026#34;dip_switch\u0026#34;: { 2 \u0026#34;enabled\u0026#34;: true, 3 \u0026#34;pins\u0026#34;: [ \u0026#34;GP26\u0026#34;, \u0026#34;GP27\u0026#34; ] 4}, \u0026quot;enabled: true\u0026quot; が DIP スイッチの機能をオンにする設定で、\u0026quot;pins: []\u0026quot; が DIP スイッチを接続するピンを指定する設定です。ここではスイッチが2つある DIP スイッチを使うため、ピンを2つ指定しています。\nなお、従来どおりの rules.mk と config.h で設定する場合、以下のとおり設定します。\n1# rules.mk 2DIP_SWITCH_ENABLE = yes 1// config.h 2#define DIP_SWITCH_PINS { GP26, GP27 } ハードウェアの設定 DIPスイッチの片側を keyboard.json に設定したピンに接続し、もう片方を GND に接続します。\nDIP スイッチの配線 DIP スイッチ自体はただのスイッチなので、DIP スイッチのどちらのピンを config.h に設定したピンに接続してもOKです。\nQMK Firmware の設定 これで DIP スイッチを使う準備ができましたので、DIP スイッチを切り替えた時の動作を設定します。\nDIP スイッチを切り替えた時の動作については、キーコードを送信するだけで足りる場合と、それだけでは足りない場合で設定が変わります。まず、キーコードを送信するだけで足りる場合の設定を解説します。\nキーコードを送信するだけで足りる場合 キーボードの keymaps/(keymap)/rules.mk に以下の設定を追加します。\n1DIP_SWITCH_MAP_ENABLE = yes それから keymap.c に以下の設定を追加します。ここでは、以下の2つの設定を行っています。\n1つ目の DIP スイッチをオンにした時に DF(1) を送信してレイヤー1をデフォルトレイヤーにし、オフにした時に DF(0) を送信してレイヤー0をデフォルトレイヤーにする。 2つ目の DIP スイッチをオンにした時に AG_LSWP を送信して LALT と LWIN を入れ替えて、オフにした時に AG_LNRM を送信して入れ替えを元に戻す。 1#if defined(DIP_SWITCH_MAP_ENABLE) 2const uint16_t PROGMEM dip_switch_map[NUM_DIP_SWITCHES][NUM_DIP_STATES] = { 3 DIP_SWITCH_OFF_ON(DF(0), DF(1)), 4 DIP_SWITCH_OFF_ON(AG_LNRM, AG_LSWP), 5}; 6#endif 複数の処理を実行する場合 スイッチを切り替えたら複数の処理を実行する、スイッチを切り替えたら OLED の表示を変更する、といった対応するキーコードが無い処理については、スイッチ切り替えに合わせてコールバック処理を実行することで対応します。コールバック処理を行う場合、各スイッチの状態を個別に管理して条件分岐する方法と、スイッチの状態をまとめて管理して条件分岐する方法の2通りの方法がありますので、それぞれ説明します。\nなお、いずれの場合であっても keymaps/(keymap)/rules.mk に DIP_SWITCH_MAP_ENABLE = yes を追加しているとコールバック処理が呼ばれませんので、この設定は削除してください。この点は本記事執筆時点の公式リファレンスでは明記されていませんので、注意してください。私はこの点になかなか気付かず苦労しました。\n各スイッチの状態を個別に管理する方法 keymap.c に dip_switch_update_user(uint8_t index, bool active) 関数を追加します。\n引数の index はスイッチの順番で、keyboard.json の dip_switch.pins で指定した順番になります。config.h で指定している場合は #define DIP_SWITCH_PINS {} で指定した順番になります。active はスイッチがオンなら true になります。\n上で紹介した処理をコールバック処理で実装した場合のコードは次のとおりとなります。なお、ここではデフォルトレイヤーを切り替える関数の set_single_persistent_default_layer と、LALT と LWIN を入れ替えるフラグの keymap_config.swap_lalt_lgui を利用しています。\n1bool dip_switch_update_user(uint8_t index, bool active) { 2 switch (index) { 3 # 1つ目のDIPスイッチのオン・オフでデフォルトレイヤーを切り替え 4 case 0: 5 if (active) { 6 set_single_persistent_default_layer(1); 7 } else { 8 set_single_persistent_default_layer(0); 9 } 10 break; 11 # 2つ目のDIPスイッチのオン・オフで LALT と LWIN を入れ替え 12 case 1: 13 keymap_config.raw = eeconfig_read_keymap(); 14 if (active) { 15 keymap_config.swap_lalt_lgui = true; 16 } else { 17 keymap_config.swap_lalt_lgui = false; 18 } 19 } 20 return true; 21} スイッチの状態をまとめて取り扱う方法 bool dip_switch_update_mask_user(uint32_t state) を使うと、各スイッチの状態をビット列とみなした上で、そのビット列が表す値が引数の state に格納されます。例えば、スイッチの状態が次表の場合の state は 1 となります。\nスイッチ番号 スイッチの状態 ビット値 スイッチ1 ON 1 スイッチ2 OFF 0 また、スイッチの状態が次表の場合 state は 3 となります。\nスイッチ番号 スイッチの状態 ビット値 スイッチ1 ON 1 スイッチ2 ON 1 このように state の値で各スイッチの状態を管理できますので、あとは switch 文で条件分岐して処理を指定します。\n1bool dip_switch_update_mask_user(uint32_t state) { 2 switch (state) { 3 case 0: 4 // 5 break; 6 case 1: 7 // 8 break; 9 case 2: 10 // 11 break; 12 // ... 13 } 14 return true; 15} なお、state の値を利用せずにスイッチの状態を直接ビット演算を使って管理する方法もあり、公式リファレンスで説明されています。\n1bool dip_switch_update_mask_user(uint32_t state) { 2 if (state \u0026amp; (1UL\u0026lt;\u0026lt;0) \u0026amp;\u0026amp; state \u0026amp; (1UL\u0026lt;\u0026lt;1)) { 3 layer_on(_ADJUST); // C on esc 4 } else { 5 layer_off(_ADJUST); 6 } 7 if (state \u0026amp; (1UL\u0026lt;\u0026lt;0)) { 8 layer_on(_TEST_A); // A on ESC 9 } else { 10 layer_off(_TEST_A); 11 } 12 if (state \u0026amp; (1UL\u0026lt;\u0026lt;1)) { 13 layer_on(_TEST_B); // B on esc 14 } else { 15 layer_off(_TEST_B); 16 } 17 return true; 18} 補足情報 分割型キーボードの右手側の DIP スイッチの管理 公式リファレンスでは分割型キーボードの右手側にある DIP スイッチを個別に管理する場合の設定も紹介されていますが、私が試したところ、右手側のスイッチを切り替えても dip_switch_update_user() と dip_switch_update_mask_user() 関数が実行されませんでした。\n試行錯誤の過程でマイコンボードを ProMicro に変更したり、左右判定の設定を変更したりしましたが、原因は突き止められませんでした。ただ、DIP スイッチは片方にあれば足りるので、左右に DIP スイッチを配置するのはあきらめました。\nデフォルトレイヤーを切り替える方法 デフォルトレイヤーの切り替えは DF(layer) キーを送信すれば可能ですが、このキーは tap_code() では送信できません。\nそのため、上記の dip_switch_update_user() を使う処理でのデフォルトレイヤーの切り替えは set_single_persistent_default_layer() 関数で処理しています。\nLALT と LWIN キーを入れ替える方法 LALT と LWIN キーは QK_MAGIC_SWAP_LALT_LGUI や AG_LSWP キーで入れ替えできます。また、QK_MAGIC_UNSWAP_LALT_LGUI や AG_LNRM キーで元に戻せますが、このキーも tap_code() では送信できません。\nそこでキーの送信以外で入れ替えを実現できないか調べたところ、QK_MAGIC_SWAP_LALT_LGUI は keymap_config.swap_lalt_lgui 変数を true/false にすることでキーの入れ替えを実現していることが判明しましたので、上記のコードでは keymap_config.swap_lalt_lgui 変数を true または false にして LALT と LWIN キーの入れ替えを実現しています。\nなお、QK_MAGIC_SWAP_LALT_LGUI は quantum/process_keycode/process_magic.c で以下のとおり定義されています。\n1// quantum/process_keycode/process_magic.c 2// 関係するコードのみ抜粋しています 3 4/** 5 * MAGIC actions (BOOTMAGIC without the boot) 6 */ 7bool process_magic(uint16_t keycode, keyrecord_t *record) { 8 // skip anything that isn\u0026#39;t a keyup 9 if (record-\u0026gt;event.pressed) { 10 if (IS_MAGIC_KEYCODE(keycode)) { 11 /* keymap config */ 12 keymap_config.raw = eeconfig_read_keymap(); 13 switch (keycode) { 14 case QK_MAGIC_SWAP_LALT_LGUI: 15 keymap_config.swap_lalt_lgui = true; 16 break; 17 case QK_MAGIC_UNSWAP_LALT_LGUI: 18 keymap_config.swap_lalt_lgui = false; 19 break; デフォルトレイヤーの確認方法 例えば、DIP スイッチのオン・オフでデフォルトレイヤーを切り替える（QWERTY 配列レイヤー ⇔ COLEMAK 配列レイヤー）場合、QMK の機能でデフォルトレイヤーのレイヤー番号が取得できると LED インジケータの変更などに利用できそうです。\nしかし、MO(layer) などによる一時的なレイヤーの切り替えでは get_highest_layer(layer_state) 関数で使用中のレイヤー番号を取得できますが、デフォルトレイヤーのレイヤー番号は常に 0 になるため、どのレイヤーをデフォルトレイヤーにしているか調べる方法は無い模様です。\nそのため、デフォルトレイヤーの切り替えで LED インジケータなどを変更する場合、デフォルトレイヤーの切り替え時に「どのレイヤーをデフォルトレイヤーに設定したか」という情報を保存し、インジケータの更新処理などでその変数を参照して対処するしかなさそうです。\nなお、デフォルトレイヤーのレイヤー番号が常に 0 になるという点については、QMK のコントリビュータの Drashna 氏が以下の Issues で発言しています。私の方でも QMK のデバッグ機能でデフォルトレイヤー切り替え時に get_highest_layer(layer_state) 関数が返す値を確認したところ、常に 0 になるのを確認しています。\n# [Bug] default_layer_state is 0 when the keyboard is powered up after flashing.\n","link":"http://localhost:1313/post/2024-10-13/","section":"post","tags":["自作キーボード"],"title":"QMK Firmware で DIP スイッチを使う方法"},{"body":"","link":"http://localhost:1313/archives/2024/09/","section":"archives","tags":null,"title":"2024/09"},{"body":"前置き 職場で REALFORCE R3S（フルサイズ・日本語配列） を使っていますが、ケーブルがキーボードから直接伸びる形で長過ぎるため、思い切ってキーボードに USB Type-C のコネクタを追加して好きなケーブルを使えるようにしました。\n出来上がりはかなり不恰好になりましたが、使える形になりましたので、備忘録として作業過程を残します。\nなお、本記事を真似して問題が発生しても、こちらでは責任は負えませんので、その点はご了承ください。\n使用した部品 以下の部品を使って USB Type-C のコネクタを作成しました。\nUSB Type-C レセプタクル Amazon | オーディオファン 組込み用 USBレセプタクル USB-C用 メス 固定プレート付き USBコネクタ Cタイプ PCBボード M2ネジ付き 【4極専用 USB3以降は対応しません】 ブラック 2点セット | オーディオファン | USBアダプタ 通販 コネクタハウジング PHコネクター ハウジング 5P PHR-5: ケーブル・コネクター 秋月電子通商-電子部品・ネット通販 コネクタコンタクト PHコネクター コンタクト SPH-002T-P0.5L: ケーブル・コネクター 秋月電子通商-電子部品・ネット通販 ケーブル 協和ハーモネット株式会社 耐熱ビニル絶縁電線 1007 AWG26 2mx7色 なお、上記の部品のうち、USB Type-C レセプタクル以外はカホパーツセンター 九州唯一の電子パーツ専門店というお店で購入しています。なので、お店の商品ページにリンクさせるべきとは思いますが、個別商品のページが用意されていないので、次善の策として秋月電子通商とメーカーのカタログにリンクしています。\n作業の概要 作業の主な流れは次のとおりです。\nキーキャップを全て外す キーボードのカバーを外す 既存のケーブルと交換するための新しいケーブルを作成する 既存のケーブルをキーボードから取り外す 新しいケーブルを USB Type-C レセプタクルに半田付けする USB Type-C レセプタクルをキーボードに取り付ける 実際の作業 キーキャップ取り外し 説明不要と思いますので手順は省略します。なお、外したキーキャップを洗浄してキーボードも掃除しておきましょう。\nカバー取り外し まず、写真の箇所にあるネジを外します。これでカバーと基板が外れました。\nカバーは写真の箇所にツメで固定されていますので、写真の箇所にマイナスドライバーなどを差し込んで隙間を空けるとツメが外れてカバーが外れるようになります。なお、カバーは上側（ファンクンションキー側）を外してから下側（モディファイヤキー側）を外します。\nハーネス作成 既存の直付け USB ケーブルは写真の箇所のコネクタに取り付けられていますので、まずこのコネクタを外して既存のケーブルをキーボードから取り出します。\nコネクタ取り付け場所 それから新しいケーブルを作成しますが、既存のケーブルの各色の役割は以下のとおりです。\n赤 5V 黒 GND 緑 D+ 白 D- 青 アース 新旧のケーブルで色を変える必要性は乏しいので「赤・黒・白・緑」のケーブルを必要な長さにカットします。青のケーブルについては、私が使った USB レセプタクルにアース端子が用意されていないため、今回は省略しました。\nワイヤーをカットしたら、先端の皮膜をはがして PH コネクタのコンタクトを圧着します。圧着には Amazon | ENGINEER エンジニア 精密圧着ペンチ PA-24 | 圧着ペンチ を利用しています。圧着したらハウジングにセットした上で、反対側の皮膜もはがしてテスターで導通を確認します。\nレセプタクルへの半田付け 導通を確認できたらコネクタと反対側をレセプタクルに半田付けします。半田付けが終ったらレセプタクルに USB Type-C \u0026amp; Type-A ケーブルを差した上で、Type-A コネクタの端子と PH コネクタ間の導通を確認します。\nケーブル半田付け後 レセプタクルのキーボードへの取り付け これが一番苦労した作業でした。最初はレセプタクルを現在のケーブル取り出し口の近くに取り付けようとしました（以下の写真の赤枠の部分）。\nケーブル取り出しを断念した場所 しかし、ケースを大幅に加工しないと基板に当たってしまいケースが閉まらなくなってしまうことが判明しました。そこで、ケースの左側からケーブルを取り出すべく左側に取り付けようとしましたが、ケーブルの長さが足りませんでした。そこで、やむを得ず右側に取り付けることにしました（以下の写真の赤丸の部分）。\nケーブル取り出し場所 レセプタクルを取り付けるには、ネジ穴をケースに空けた上で、USBケーブルの先端のカバーの大きさに合わせてケースを切り取る必要があります。ところが、ケーブルのカバーの大きさに合わせてケースを切り取ったらネジ穴を空けるスペースが無くなったーー正確にはネジ穴1つは空けられたものの、もう1つのネジ穴を空けるスペースが無くなったーーため、結局レセプタクルはネジと接着剤の併用で固定することになりました。\nレセプタクルを取り付けたら、次はキーボードケースのカバーにも同様に切り取る必要があります。こちらについては、レセプタクルを固定しているネジと干渉しないことが必要になりますので、カバーより広い範囲を切り取ることになります。そうやってキーボードケースのカバーも切り取った結果が、下の写真の状況です。\nケース加工後 まとめ 出来上がりはかなり不細工ですが、これで既存のケーブルの取り回しに苦労しなくて済むようになりました。また、こういう既存品のカスタマイズは始めての取り組みでしたので、上手く出来るか不安でしたが、無事に動かせてホッとしています。\n本記事が何かの参考になれば幸いです。\n（本記事は今回改造した REALFORCE R3S で執筆しました）\n","link":"http://localhost:1313/post/2024-09-09/","section":"post","tags":["備忘録","キーボード"],"title":"REALFORCE R3S に USB Type-C コネクタを追加した話"},{"body":"","link":"http://localhost:1313/tags/%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89/","section":"tags","tags":null,"title":"キーボード"},{"body":"","link":"http://localhost:1313/tags/%E5%82%99%E5%BF%98%E9%8C%B2/","section":"tags","tags":null,"title":"備忘録"},{"body":"","link":"http://localhost:1313/archives/2024/08/","section":"archives","tags":null,"title":"2024/08"},{"body":"前置き Neovim のプラグインの ddu.vim を導入してバッファ切り替えやコマンド履歴からのコマンド実行やファイラーとして便利に使っているのですが、ddu.vimのアクション周りを便利にしよう という記事を見てカスタムアクションを導入したいと思いました。\nただ、上記の記事は Vimscript を使って設定していますが、私は Lua で設定していますので、導入では少々苦労しました。\nネットで調べても Lua でカスタムアクションを導入している記事は見当りませんでしたので、備忘録として注意点をメモします。\n環境 OS 1エディション\tWindows 11 Pro 2バージョン\t23H2 3インストール日\t2022/07/11 4OS ビルド\t22631.4108 5エクスペリエンス\tWindows Feature Experience Pack 1000.22700.1034.0 Neovim 1❯ nvim --version 2NVIM v0.10.1 3Build type: Release 4LuaJIT 2.1.1713484068 5Run \u0026#34;nvim -V1 -v\u0026#34; for more info また、Neovim には ddu-source-action を追加しており、ddu.vim の UI で a を押せばi temAction として実行できるアクションをdduに表示して絞り込みができるようにしています。\n1-- 無関係の設定は省略しています 2vim.api.nvim_create_autocmd(\u0026#34;FileType\u0026#34;, { 3 pattern = \u0026#34;ddu-ff\u0026#34;, 4 callback = function() 5 vim.keymap.set({ \u0026#34;n\u0026#34;, \u0026#34;i\u0026#34; }, \u0026#34;a\u0026#34;, [[\u0026lt;Cmd\u0026gt;call ddu#ui#do_action(\u0026#39;chooseAction\u0026#39;)\u0026lt;CR\u0026gt;]], { noremap = true, silent = true, buffer = true }) 6 end, 7}) 実装 私が導入したいカスタムアクションは、ファイラーとして使っているときに、選択したファイルの相対パスをカーソル位置に挿入するというものです。\nそこで、まず前述の記事に「まず登録する関数の先頭で試しにechomsg a:args等を実行して、受け取る引数に何が入っているかを確かめてみると良い」とありましたので、関数と関数呼び出しを以下のとおり設定して受け取る引数の内容を確認しようとしました。\n1function InsertFilepath() 2 vim.cmd(\u0026#39;echomsg a:args\u0026#39;) 3 return 0 4end 5vim.fn[\u0026#39;ddu#custom#action\u0026#39;](\u0026#39;source\u0026#39;, \u0026#39;file_rec\u0026#39;, \u0026#39;insertPath\u0026#39;, \u0026#39;InsertFilepath\u0026#39;) これで chooseAction で呼び出したアクションの中に insertPath が登録されたのですが、アクションを実行しても「未知の関数です」というエラーになってしまいました。前述の記事と同様に VimScript で設定を書いて vim.cmd() で囲めばエラーにはならないのですが、設定は可能な限り Lua で書くようにしているので、他の方法も模索してみました。\nで、結論を書きますと、関数を別途定義して呼び出すのではなく、即時関数にすればきちんとアクションを実行できました。それを踏まえて書いた設定は以下のとおりです。\n1vim.fn[\u0026#39;ddu#custom#action\u0026#39;](\u0026#39;source\u0026#39;, \u0026#39;file_rec\u0026#39;, \u0026#39;insertPath\u0026#39;, function (args) 2 local selectedFilePath = vim.fn.substitute(\u0026#34;.\u0026#34;..args[\u0026#34;items\u0026#34;][1][\u0026#34;word\u0026#34;], \u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;, \u0026#39;g\u0026#39;) 3 local beforeCursor = vim.fn.strcharpart(vim.fn.getline(\u0026#39;.\u0026#39;), 0, vim.fn.getcharpos(\u0026#39;.\u0026#39;)[3]) 4 local afterCursor = vim.fn.strcharpart(vim.fn.getline(\u0026#39;.\u0026#39;), vim.fn.getcharpos(\u0026#39;.\u0026#39;)[3], vim.fn.strchars(vim.fn.getline(\u0026#39;.\u0026#39;))) 5 local newLine = beforeCursor..selectedFilePath..afterCursor 6 vim.fn.setline(\u0026#39;.\u0026#39;, newLine) 7 return 0 8end) 実際の動作は次のとおりです。\n補足 args の内容 chooseAction からカスタムアクションを呼び出したときに渡される引数の args について、以下のコードで内容をレジスタに登録してから別のバッファに貼り付けて確認したところ、以下の内容となっていました。\n1vim.fn[\u0026#39;ddu#custom#action\u0026#39;](\u0026#39;source\u0026#39;, \u0026#39;file_rec\u0026#39;, \u0026#39;insertPath\u0026#39;, function (args) 2 local selectedFilePath = vim.fn.substitute(\u0026#34;.\u0026#34;..args[\u0026#34;items\u0026#34;][1][\u0026#34;word\u0026#34;], \u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;, \u0026#39;g\u0026#39;) 3 local beforeCursor = vim.fn.strcharpart(vim.fn.getline(\u0026#39;.\u0026#39;), 0, vim.fn.getcharpos(\u0026#39;.\u0026#39;)[3]) 4 local afterCursor = vim.fn.strcharpart(vim.fn.getline(\u0026#39;.\u0026#39;), vim.fn.getcharpos(\u0026#39;.\u0026#39;)[3], vim.fn.strchars(vim.fn.getline(\u0026#39;.\u0026#39;))) 5 local newLine = beforeCursor..selectedFilePath..afterCursor 6 vim.fn.setline(\u0026#39;.\u0026#39;, newLine) 7 vim.fn.setreg(\u0026#39;a\u0026#39;, vim.inspect(args)) -- 確認のために追加したコード 8 return 0 9end) 1{ 2 actionParams = vim.empty_dict(), 3 context = { 4 bufName = \u0026#34;C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\nvim\\\\init.lua\u0026#34;, 5 bufNr = 3, 6 cwd = \u0026#34;C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\nvim\u0026#34;, 7 done = true, 8 doneUi = true, 9 input = \u0026#34;\u0026#34;, 10 maxItems = 111, 11 mode = \u0026#34;n\u0026#34;, 12 path = \u0026#34;C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\nvim\u0026#34;, 13 pathHistories = {}, 14 winId = 1000 15 }, 16 items = { { 17 __columnTexts = vim.empty_dict(), 18 __expanded = false, 19 __groupedPath = \u0026#34;\u0026#34;, 20 __level = 0, 21 __sourceIndex = 0, 22 __sourceName = { \u0026#34;file_rec\u0026#34; }, 23 action = { 24 isDirectory = false, 25 path = \u0026#34;C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\nvim\\\\lua\\\\plugins\\\\cmp-path.lua\u0026#34; 26 }, 27 display = \u0026#34; lua\\\\plugins\\\\cmp-path.lua\u0026#34;, 28 highlights = { { 29 col = 1, 30 hl_group = \u0026#34;DduDevIconLua\u0026#34;, 31 name = \u0026#34;ddu_devicon\u0026#34;, 32 width = 3 33 } }, 34 kind = \u0026#34;file\u0026#34;, 35 matcherKey = \u0026#34;lua\\\\plugins\\\\cmp-path.lua\u0026#34;, 36 word = \u0026#34;lua\\\\plugins\\\\cmp-path.lua\u0026#34; 37 } }, 38 options = { 39 actionOptions = vim.empty_dict(), 40 actionParams = vim.empty_dict(), 41 actions = {}, 42 columnOptions = vim.empty_dict(), 43 columnParams = vim.empty_dict(), 44 expandInput = false, 45 filterOptions = vim.empty_dict(), 46 filterParams = vim.empty_dict(), 47 input = \u0026#34;\u0026#34;, 48 kindOptions = { 49 action = { 50 defaultAction = \u0026#34;do\u0026#34; 51 }, 52 file = { 53 defaultAction = \u0026#34;open\u0026#34; 54 } 55 }, 56 kindParams = vim.empty_dict(), 57 name = \u0026#34;file_recursive\u0026#34;, 58 postFilters = {}, 59 profile = false, 60 push = false, 61 refresh = false, 62 resume = false, 63 searchPath = \u0026#34;\u0026#34;, 64 sourceOptions = { 65 _ = { 66 ignoreCase = true, 67 matchers = { \u0026#34;matcher_substring\u0026#34; } 68 }, 69 file_rec = { 70 actions = { 71 insertPath = \u0026#34;e91b97c2196bc99e62c0f12111750920802d8bf4aea17d68a81a85fb5ffef268\u0026#34; 72 } 73 } 74 }, 75 sourceParams = vim.empty_dict(), 76 sources = { { 77 name = { \u0026#34;file_rec\u0026#34; }, 78 options = { 79 converters = { \u0026#34;converter_devicon\u0026#34; } 80 }, 81 params = { 82 ignoredDirectories = { \u0026#34;node_modules\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;.vscode\u0026#34; } 83 } 84 } }, 85 sync = false, 86 ui = \u0026#34;ff\u0026#34;, 87 uiOptions = vim.empty_dict(), 88 uiParams = { 89 ff = { 90 floatingBorder = \u0026#34;rounded\u0026#34;, 91 previewFloating = true, 92 previewFloatingBorder = \u0026#34;rounded\u0026#34;, 93 previewFloatingTitle = \u0026#34;Preview\u0026#34;, 94 previewSplit = \u0026#34;vertical\u0026#34;, 95 prompt = \u0026#34;\u0026gt; \u0026#34;, 96 split = \u0026#34;floating\u0026#34; 97 } 98 }, 99 unique = false 100 } 101} カスタムアクションを追加したかった理由 ddc.vim を導入して LSP やコマンドやファイルパスの補完を実現していますが、ファイルパスの補完だけちょっと動作にもたつきがあるのと、ディレクトリ構造を順番に入力するのがちょっと面倒だったためです。\nそれでも他に方法がなければ ddc.vim の補完を使うのですが、ddu.vim もファイルパスを使っている以上、カスタムアクションが導入できればファイルパスを一発で書けるのではないかと思い、カスタムアクションの導入に挑戦しました。\n結果的に希望どおりの動作が実現できたので良かったです。\n","link":"http://localhost:1313/post/2024-08-26/","section":"post","tags":["vim","neovim"],"title":"Lua で ddu.vim のカスタムアクションを実装する"},{"body":"前置き ターミナルアプリに Alacritty - A cross-platform, OpenGL terminal emulator を使っているのですが、テンキーの Enter キーが ctrl-j と認識されてしまうという不具合？ に悩まされていました。\nしばらく見て見ぬふりをしていたのですが、地味に不便なので対応しました。\nただ、見つけた対応策はしばらくすると忘れてしまいそうなので、備忘録としてメモします。\n環境 OS 1エディション\tWindows 11 Pro 2バージョン\t23H2 3インストール日\t2022/07/11 4OS ビルド\t22631.4108 5エクスペリエンス\tWindows Feature Experience Pack 1000.22700.1034.0 Alacritty 1❯ alacritty.exe --version 2alacritty 0.13.2 (bb8ea18) 対応策 %APPDATA%\\alacritty\\alacritty.toml を開いて、以下のキーバインディングの設定を追加します。\n1[keyboard] 2bindings = [ 3 { key = \u0026#34;NumpadEnter\u0026#34;, mods = \u0026#39;None\u0026#39;, action = \u0026#34;ReceiveChar\u0026#34; }, 4] その他 テンキーからの入力については Enter キーに限らず問題があるようで、こんな Issue も投稿されています。\nCan't enable application keypad mode #3720\n上記の解決策は、この Issue のスレッドにあるこの投稿 をコピペしたものです。\n","link":"http://localhost:1313/post/2024-08-19/","section":"post","tags":["備忘録"],"title":"Alacritty でテンキーの Enter キーを Enter キーと認識させる方法について"},{"body":"","link":"http://localhost:1313/tags/3d%E3%83%97%E3%83%AA%E3%83%B3%E3%82%BF/","section":"tags","tags":null,"title":"3Dプリンタ"},{"body":"前置き 現在オープンベータ中の Fraxinus3e を組み立てて印刷を重ねていますが、操作のために毎回タブレットを使うのが若干面倒なので、KlipperScreen を導入することにしました。\nnote の KlipperScreen を Raspberry Pi Zero 2W で使う方法 という記事を基にすればそんなに苦労しないかなと思って挑戦したのですが、実際には試行錯誤を重ねてやっと使えるようになりましたので、設定内容と試行錯誤の経緯を備忘録としてメモします。\n環境 Raspberry Pi モデル Raspberry Pi 4 Model B Rev 1.2 OS Debian GNU/Linux 11 (bullseye) 1.3.2 Klipper v0.12.0-192-gb7f7b8a3 KlipperScreen v0.4.3-49-g8e915764 Moonraker v0.8.0-359-g73df63db Raspberry Pi と SKR Pico の接続 UART（Raspberry Pi の電源供給含む） ディスプレイ OSOYOO RPi用3.5インチSPIタッチディスプレイ ディスプレイが前述の note の記事のものと違いますが、Discord の Fraxinus3e のサーバーでこのディスプレイを使って KlipperScreen を導入できたという投稿がありましたので、大丈夫だろうと思って購入しました。\n設定内容の先取り 試行錯誤の過程はそこそこ長い話になっていますので、Raspberry Pi と SKR Pico を UART で接続しつつ、OSOYOO の 3.5inch ディスプレイに KlipperScreen の画面を表示させるために必要な作業をまず示します。\nUART2 を使用可能にする Raspberry Pi と SKR Pico の接続で使う TX のピンを GPIO14 から GPIO0 に、RX のピンを GPIO15 から GPIO1 にそれぞれ変更。 printer.cfg の [mcu] の serial: を ttyAMA0 から ttyAMA1 に変更 raspi-config で Linuxコンソール が UART にアクセスできるように設定 Bluetooth を UART に接続させないために Bluetooth を無効化する（省略可） 試行錯誤 何とか成功させるまでに取り組んだことをこれから説明していきます。\nディスプレイ導入 Raspberry Pi との接続 このディスプレイは、1枚目の写真のように Raspberry Pi にかぶせる形で取り付ける想定になっていますが、私の場合、もう1枚の写真のように Raspberry Pi の GPIO ピンの一部を SKR Pico との UART 接続で使っていますので、同じ接続方法は不可能でした。\nhttps://osoyoo.com/ja/2022/12/15/osoyoo-3-5-inch-spi-touch-display-for-rpi/ より https://github.com/bigtreetech/SKR-Pico/blob/master/Klipper/Images/wiring_uart.png より そのため、ディスプレイの説明書で信号の送受信に使われているピンを確認し、それが Raspberry Pi のどのピンに対応しているか突合した上で、Qi コネクタを自作してディスプレイと Raspberry Pi を接続しました。なお、5V と GND については、SKR Pico の E0-STOP コネクタの 5V ピンと GND ピンを利用しています。\nピン番号 Rpi GPIO GPIO機能 ディスプレイ機能 SKR Pico 4(5V) 5V 6(GND) GND 11 GPIO17 TP_IRQ 18 GPIO24 LCD_RS 19 GPIO10 MOSI LCD_SI/TP_SI 21 GPIO9 MISO TP_SO 22 GPIO25 RST 23 GPIO11 SCLK LCD_SCK/TP_SCK 24 GPIO8 CE0 LCD_CS 26 GPIO7 CE1 TP_CS https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio の画像を加工 https://osoyoo.com/ja/2022/12/15/osoyoo-3-5-inch-spi-touch-display-for-rpi/ より Raspberry Pi とディスプレイを接続したときの配線 ドライバ導入 メーカーの説明書に従って以下の作業を実施しました。\nSSH で Raspberry Pi に接続 git clone https://github.com/osoyoo/LCD-show.git コマンドで必要なファイルをクローン cd LCD-show/ でクローンしたディレクトリに移動します。 chmod +x lcd35b-show コマンドでドライバインストールのファイルに実行権限を付与 ./lcd35b-show コマンドを実行 これでドライバがインストールされ、設定も変更されて自動的に Raspberry Pi が再起動します。\nKlipperScreen 導入 公式サイトでは KIAUH を使ってインストールすることが推奨されていますので、それに従います。\n./kiauh/kiauh.sh コマンドで KIAUH を起動したら、「1) [Install] -\u0026gt; 5) [KlipperScreen]」の順に選択して、KlipperScreen をインストールしました。\nKlipper に接続できなくなる 上記の作業だけでディスプレイに KlipperScreen の画面が表示されたのですが、ディスプレイに以下のエラーメッセージが表示されていました。\n1mcu \u0026#39;mcu\u0026#39;: Unable to connect 2Once the underlying issue is corrected, use the 3\u0026#34;FIRMWARE_RESTART\u0026#34; command to reset the firmware, reload the 4config, and restart the host software. 5Error configuring printer エラーメッセージが表示されている様子 仕方がないのでファームウェアを再起動したのですが、以下のメッセージがしばらく表示された後、同じエラーメッセージが表示されました。\n1Printer is not ready 2The klippy host software is attempting to connect. Please 3retry in a few moments. これでは印刷できませんので同様の事例がないか検索したものの、私の事例に当てはまりそうなものはありませんでした。\nディスプレイの設定変更 検索で解決に繋がりそうな情報を見つけられなかったため、Discord の Fraxinus サーバーで状況を報告して相談を求めました。\nすると KlipperScreen を Raspberry Pi Zero 2W で使う方法 の執筆者の緋村さんから設定方法をアドバイスしていただきました。それを踏まえて、以下のとおり設定しました。\nconfig.txt の編集 以下の設定を [all] セクションに追加して再起動しました。\n1dtoverlay=spi1-1cs,cs0_pin=16 2dtoverlay=fbtft35,spi0-0,generic35,bgr,reset_pin=25,dc_pin=24,ledn_pin=18,rotate=270 3dtoverlay=ads7846,cs=1,penirq=17,speed=10000,penirq_pull=2,xohms=155 Raspberry Pi 再起動後に以下のコマンドを実行 1cd ~ 2mkdir dts 3cd ~/dts 4wget \u0026#34;https://drive.google.com/uc?export=download\u0026amp;id=1Eqbaq-SzO_6EFwNgEmxIW_iwfv7_77XB\u0026#34; -O fbtft35-overlay.dts 5dtc -@ -I dts -O dtb -o fbtft35.dtbo fbtft35-overlay.dts 6sudo cp fbtft35.dtbo /boot/overlays/ 7sudo reboot この設定を行ったところ、ディスプレイに KlipperScreen の画面は表示されましたが、上記と同じ mcu 'mcu': Unable to connect ... というエラーは続いていました。\nLinux コンソールの設定変更 エラーの解消方法を探るために klippy.log を確認したところ、以下のログが複数出力されていましたので、エラーの原因はシリアル接続ではないかと当たりをつけました。\n1serialhdl.error: mcu \u0026#39;mcu\u0026#39;: Serial connection closed 2mcu \u0026#39;mcu\u0026#39;: Timeout on connect 3MCU error during connect 4Traceback (most recent call last): 5 File \u0026#34;/home/pi/klipper/klippy/mcu.py\u0026#34;, line 791, in _mcu_identify 6 self._serial.connect_uart(self._serialport, self._baud, rts) 7 File \u0026#34;/home/pi/klipper/klippy/serialhdl.py\u0026#34;, line 183, in connect_uart 8 self._error(\u0026#34;Unable to connect\u0026#34;) 9 File \u0026#34;/home/pi/klipper/klippy/serialhdl.py\u0026#34;, line 61, in _error 10 raise error(self.warn_prefix + (msg % params)) 試しに、printer.cfg の [mcu] の serial: セクションに設定する接続先を ttyAMA0 から ttyS0 に変更してみました。すると、mcu 'mcu': Unable to connect ... エラーは引き続き発生していましたが、klippy.log に permission denied というエラーログが出ていました。permission denied は接続拒否なので、Klipper が接続しようとする前に別のプロセスがシリアル接続を押さえてしまっているのではないかと予想しました。\nそこで Raspberry Pi のシリアル接続に関する情報を調べたところ、Raspberry Pi ではデフォルトで Linux コンソールがプライマリ UART に存在していることが分かりました1。これがエラーの原因ではないかと考えて、Linux コンソールが UART にアクセスできないように設定を変更しました。設定変更は、sudo raspi-config を実行して「3 Interface Options -\u0026gt; I6 Serial Port」の順番でメニューを開き、「Would you like a login shell to be accessible over serial?」という質問に「No」を選択すれば OK です。\nKlipper の接続が復活 上記の設定変更後に Raspberry Pi を再起動したところ、Klipper の接続が復活して、Fluidd の画面が正常に戻りました。\nしかし、ディスプレイには KlipperScreen の画面ではなく Linux 起動時のコンソールの内容が出力されていたため、次はこの問題の解消に取り組みました。\nディスプレイに KlipperScreen の画面を表示させる ディスプレイを初めて接続した時は KlipperScreen の画面が表示されており、そのときは Linux コンソールが UART に存在していたので、KlipperScreen の画面を表示させるには Linux コンソールが UART に存在している必要があると予想しました。しかし、Linux コンソールが UART に存在していると Klipper が接続できなくなってしまいます。\nただ、シリアル接続について調べていたときに、Raspberry Pi 4 では最大で UART を6つまで使えることが判明していました2。そのため、Linux コンソールが UART に存在できるよう設定を戻した上で、使える UART を1つ増やしてそこに SKR Pico を接続すればよいのではと考えました。\nUART2 を使用可能にする Raspberry Pi 4 では、デフォルトで UART0 と UART1 の2つの UART が使用可能になっており、このうち、UART1 がプライマリ UART になっています。一方、UART0 はセカンダリ UART になっていますが、通常は GPIO コネクタではなく Bluetooth コントローラーに接続されています。なお、UART1 と UART0 のどちらがプライマリになるかはモデルによって異なります。各モデルの設定は、Raspberry Pi の公式ガイドからコピーした下表のとおりです。\nModel Primary/console Secondary/Bluetooth Raspberry Pi Zero UART0 UART1 Raspberry Pi Zero W / Raspberry Pi Zero 2 W UART1 UART0 Raspberry Pi 1 UART0 UART1 Raspberry Pi 2 UART0 UART1 Raspberry Pi 3 UART1 UART0 Compute Module 3 \u0026amp; 3+ UART0 UART1 Raspberry Pi 4 UART1 UART0 Raspberry Pi 5 UART10 \u0026lt;dedicated UART\u0026gt; プライマリ UART とセカンダリ UART で UART1 と UART0 が使われていますので、/boot/config.txt に次の設定を追加して UART2 を使えるようにしました。3\n1enable_uart=1 2dtoverlay=uart2 3dtoverlay=disable-bt 設定の内容を説明しますと、enable_uart=1 は UART を有効化するための設定で、dtoverlay=uart2 は UART2 を使えるようにするための設定です。dtoverlay=disable-bt は Bluetooth デバイスを無効化するための設定で必須ではありませんが、Bluetooth を使う予定はないのでついでに設定しました。ファイルの編集が終わったら、Raspberry Pi を再起動します。\n再起動後に raspi-gpio get 0-15 コマンドで GPIO ピンに割り当てられた機能を確認しますと、GPIO0 と GPIO1 のピンの機能が TXD2 と RXD2 となっており、この2つのピンが UART2 のためのピンとなっていることが確認できます。\n1GPIO 0: level=1 fsel=3 alt=4 func=TXD2 pull=NONE 2GPIO 1: level=1 fsel=3 alt=4 func=RXD2 pull=UP 3GPIO 2: level=1 fsel=4 alt=0 func=SDA1 pull=UP 4GPIO 3: level=1 fsel=4 alt=0 func=SCL1 pull=UP 5GPIO 4: level=1 fsel=0 func=INPUT pull=UP 6GPIO 5: level=1 fsel=0 func=INPUT pull=UP 7GPIO 6: level=1 fsel=0 func=INPUT pull=UP 8GPIO 7: level=1 fsel=1 func=OUTPUT pull=UP 9GPIO 8: level=0 fsel=1 func=OUTPUT pull=UP 10GPIO 9: level=0 fsel=4 alt=0 func=SPI0_MISO pull=DOWN 11GPIO 10: level=0 fsel=4 alt=0 func=SPI0_MOSI pull=DOWN 12GPIO 11: level=1 fsel=4 alt=0 func=SPI0_SCLK pull=DOWN 13GPIO 12: level=0 fsel=0 func=INPUT pull=DOWN 14GPIO 13: level=0 fsel=0 func=INPUT pull=DOWN 15GPIO 14: level=1 fsel=2 alt=5 func=TXD1 pull=NONE 16GPIO 15: level=1 fsel=2 alt=5 func=RXD1 pull=UP また、ls -la /dev/tty* コマンドで UART のデバイスを確認したところ、以下のとおり /dev/ttyAMA1 が追加されていました。\n1.. 2crw--w---- 1 root tty 204, 64 Aug 18 14:02 /dev/ttyAMA0 3crw-rw---- 1 root dialout 204, 65 Aug 18 17:38 /dev/ttyAMA1 4... 5crw-rw---- 1 root dialout 4, 64 Aug 18 13:17 /dev/ttyS0 なお、dtoverlay=disable-bt で Bluetooth デバイスを無効化した場合、Raspberry Pi 再起動後に sudo systemctl disable hciuart を実行して Bluetooth のシステムサービスを停止する必要があるようです。4\nRaspberry Pi と SKR Pico の接続を変更する UART2 が使えるようになりましたので、プリンタの電源をオフにしてから Raspberry Pi と SKR Pico の接続を変更します。具体的には、GPIO14 に接続されているケーブルを GPIO0 に、GPIO15 に接続されているケーブルを GPIO1 に繋ぎ変えました。\nprinter.cfg を修正する printer.cfg の [mcu] の serial: を次のとおり変更しました。\n1- /dev/ttyAMA0 2+ /dev/ttyAMA1 Linux コンソールを変更 sudo raspi-config を実行してLinux コンソールが UART にアクセスできるように設定を戻して、Raspberry Pi を再起動しました。\nKlipperScreen の画面が表示される 以上の作業を経て、ディスプレイに KlipperScreen の画面を表示させつながら印刷もできるようになりました。\n参考にした情報 この一連の作業で参考にしたサイトは次のとおりです。サイトの執筆者の方々には感謝申し上げます。\nKlipperScreen を Raspberry Pi Zero 2W で使う方法 Raspberry Piのシリアルポート設定（UART）を理解する - Toki Blog（トキブログ） Raspberry Pi GPIOを使用したシリアル通信 | Ingenious Configuration - Raspberry Pi Documentation https://www.raspberrypi.com/documentation/computers/configuration.html#primary-uart\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.raspberrypi.com/documentation/computers/configuration.html#raspberry-pi-4-and-400\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nなお、3Dプリンタ制御で Bluetooth は使わないはずなので、Bluetooth をオフにして UART0 に SKR Pico を繋げる方法もありそうですが、やり方が分からなかったのでこの方法は採用しませんでした。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.raspberrypi.com/documentation/computers/configuration.html#uarts-and-device-tree 参照\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"http://localhost:1313/post/2024-08-18/","section":"post","tags":["3Dプリンタ","RaspberryPi"],"title":"Raspberry Pi と SKR Pico を UART で接続しながら KlipperScreen を使う方法"},{"body":"","link":"http://localhost:1313/tags/raspberrypi/","section":"tags","tags":null,"title":"RaspberryPi"},{"body":"","link":"http://localhost:1313/archives/2024/06/","section":"archives","tags":null,"title":"2024/06"},{"body":"前置き この記事に続く Neovim の設定に関する記事です。今回は、Vim/Neovim 専用の日本語入力プラグインである vim-skk/skkeleton: SKK implements for Vim/Neovim with denops.vim の設定に関する情報を備忘録としてまとめます。\n環境 OS 1エディション\tWindows 11 Pro 2バージョン\t23H2 3インストール日\t2022/07/11 4OS ビルド\t22631.3807 5エクスペリエンス\tWindows Feature Experience Pack 1000.22700.1020.0 Neovim 1❯ nvim --version 2NVIM v0.9.4 3Build type: RelWithDebInfo 4LuaJIT 2.1.1696883897 5Compilation: C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe /MD /Zi /O2 /Ob1 -W3 -wd4311 -wd4146 -DUNIT_TESTING -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE -D_WIN32_WINNT=0x0602 -DMSWIN -DINCLUDE_GENERATED_DECLARATIONS -ID:/a/neovim/neovim/.deps/usr/include/luajit-2.1 -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/build/src/nvim/auto -ID:/a/neovim/neovim/build/include -ID:/a/neovim/neovim/build/cmake.config -ID:/a/neovim/neovim/src -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include 6 7 システム vimrc: \u0026#34;$VIM\\sysinit.vim\u0026#34; 8 省略時の $VIM: \u0026#34;C:/Program Files (x86)/nvim/share/nvim\u0026#34; 9 10Run :checkhealth for more info プラグイン管理 プラグインは folke/lazy.nvim: 💤 A modern plugin manager for Neovim で管理しており、lazy.nvim にかかる init.lua の設定は次のとおりです。プラグインごとに設定ファイルを分割したいので、プラグインの設定ファイルは 'C:\\Users\\(username)\\AppData\\Local\\nvim\\lua\\plugins\\' ディレクトリに保存しています。\n1local lazypath = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/lazy/lazy.nvim\u0026#34; 2if not (vim.uv or vim.loop).fs_stat(lazypath) then 3 vim.fn.system({ 4 \u0026#34;git\u0026#34;, 5 \u0026#34;clone\u0026#34;, 6 \u0026#34;--filter=blob:none\u0026#34;, 7 \u0026#34;https://github.com/folke/lazy.nvim.git\u0026#34;, 8 \u0026#34;--branch=stable\u0026#34;, -- latest stable release 9 lazypath, 10 }) 11end 12vim.opt.rtp:prepend(lazypath) 13require(\u0026#34;lazy\u0026#34;).setup(\u0026#34;plugins\u0026#34;) 準備 関連するランタイムなどのインストール skkeleton は Javascript/Typescript ランタイムの1つである Deno に依存していますので、まず Deno をインストールします。\n公式サイトに記載されているインストール方法（Windows版）は、コマンドプロンプトで irm https://deno.land/install.ps1 | iex コマンドを実行するという方法ですが、私は Github の Releases で配布されている .msi をダウンロードしてインストールしました。\nこの方法にした理由は、後述するエラー対応の際、インストールの問題でエラーが起きているのかと思ったため、インストーラーを使ってインストールした方が良いだろうと思ったためです。 これで Deno をインストールできましたが、skkeleton は、Deno を利用して Vim/Neovim 双方で動くプラグインを作るためのエコシステムである denops.vim を利用して作成されていますので、denops.vim もインストールします。\ndenops.vim は、'C:\\Users\\(username)\\AppData\\Local\\nvim\\lua\\plugins\\denops.lua' ファイルを作成して以下の設定を追記し、:Lazy コマンドを実行してインストールします。\n1return { 2 \u0026#34;vim-denops/denops.vim\u0026#34;, 3 lazy = false, 4 priority = 500, 5 --config = true, 6} 辞書のインストール SKK の変換に必要な辞書を SKK dictionary files gh-pages | dict からダウンロードします。保存場所は自由に決められます。私は C:\\skk ディレクトリに以下の辞書を保存しました。\nSKK-JISYO.L SKK-JISYO.jinmei SKK-JISYO.geo SKK-JISYO.propernoun SKK-JISYO.law 設定 これで必要なランタイムや辞書はインストールできましたので、init.lua に設定を追加します。\n1vim.api.nvim_set_keymap(\u0026#39;i\u0026#39;, \u0026#39;\u0026lt;C-j\u0026gt;\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(skkeleton-enable)\u0026#39;, {noremap = true}) 2vim.api.nvim_set_keymap(\u0026#39;c\u0026#39;, \u0026#39;\u0026lt;C-j\u0026gt;\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(skkeleton-enable)\u0026#39;, {noremap = true}) 3vim.api.nvim_set_keymap(\u0026#39;i\u0026#39;, \u0026#39;\u0026lt;C-l\u0026gt;\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(skkeleton-disable)\u0026#39;, {noremap = true}) 4vim.api.nvim_set_keymap(\u0026#39;c\u0026#39;, \u0026#39;\u0026lt;C-l\u0026gt;\u0026#39;, \u0026#39;\u0026lt;Plug\u0026gt;(skkeleton-disable)\u0026#39;, {noremap = true}) 5vim.fn[\u0026#39;skkeleton#config\u0026#39;]({ 6 globalDictionaries = { 7 \u0026#34;C:/skk/SKK-JISYO.L\u0026#34;, 8 \u0026#34;C:/skk/SKK-JISYO.geo\u0026#34;, 9 \u0026#34;C:/skk/SKK-JISYO.jinmei\u0026#34;, 10 \u0026#34;C:/skk/SKK-JISYO.lisp\u0026#34;, 11 \u0026#34;C:/skk/SKK-JISYO.law\u0026#34;, 12 }, 13 eggLikeNewline = true, 14 keepState = true, 15 showCandidatesCount = 2, 16 registerConvertResult = true, 17}) 18vim.fn[\u0026#39;skkeleton#register_keymap\u0026#39;](\u0026#39;input\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;abbrev\u0026#39;) 上の設定は、以下の動作を実現するための設定です。\nvim.api.nvim_set_keymap( ~~~ ) ctrl-j で skkeleton を有効化する（かな入力をオンにする） ctrl-l で skkeleton を無効化する（かな入力をオフにする） globalDictionaries = { ~~~ } 辞書は C:/skk ディレクトリに保存しているものを使う（フルパスで指定する） eggLikeNewLine = true 変換候補を選んで Enter キーをタイプしたときに確定のみ行う（false にすると改行される） keepState = true Insert Mode を抜けても skkeleton の有効/無効の状態を保持する showCandidatesCount = 2 2回目までの変換では複数の変換候補を表示しない registerConvertResult = 2 カタカナ変換等の結果を辞書に登録する vim.fn['skkeleton#register_keymap']('input', '/', 'abbrev') / で abbrev モードに入る 追記1\n上記の registerConvertResult = 2 は、正しくは registerConvertResult = true です。\nまた、上記で設定した vim.fn['skkeleton#register_keymap']('input', '/', 'abbrev') については、あまり使い道がなかったので、2024年7月時点では設定を削除しています。\nさらに、辞書の保存場所を C:\\Users\\(username)\\AppData\\Local\\nvim\\skk_dict\\ に変えましたが、globalDictionaries に辞書のパスをハードコードするのはイマイチだと感じましたので、Vim の expand() 関数を使ってパスを展開することにしました。\n1 vim.fn[\u0026#34;expand\u0026#34;](\u0026#39;~/AppData/Local/nvim/skk_dict/SKK-JISYO.L\u0026#39;), 2 vim.fn[\u0026#34;expand\u0026#34;](\u0026#39;~/AppData/Local/nvim/skk_dict/SKK-JISYO.geo\u0026#39;), 3 vim.fn[\u0026#34;expand\u0026#34;](\u0026#39;~/AppData/Local/nvim/skk_dict/SKK-JISYO.jinmei\u0026#39;), 4 vim.fn[\u0026#34;expand\u0026#34;](\u0026#39;~/AppData/Local/nvim/skk_dict/SKK-JISYO.law\u0026#39;), 補足 skkeleton の導入の説明は以上のとおりですが、動かせるようになるまでかなり苦戦しました。\nと言いますのも、ctrl-j で skkeleton を有効化しようとするとエラーが発生して有効化できないという状態が続いたためです。\nエラーの様子は以下のスクリーンショットのとおりで、エラーメッセージで検索しても類似の事案が見当たらず、公式リポジトリの Issues にもそれらしい症状がありませんでした。なお、Neovim 起動時にもエラーが表示されていました。\nctrl-j を押した時のエラー Neovim 起動時のエラー 起動時のエラーから denops のトラブルだと当たりを付けて :checkhealth で問題の有無を調べましたが、問題はなさそうでした。そこでDeno を再インストールしたり、Deno のモジュールの @std/path - JSR をインストールしたり、さらにNeovim のバージョンを変えたりしたのですが解決できなかったので、Slack に用意された Vim-jp のチャットルームで相談しました。\nすると :mes コマンドで表示されるエラーメッセージの全文を見せて欲しいと言われましたので、Neovim を再起動して :mes を実行してエラーメッセージの全文を確認したところ、「Deno のキャッシュに問題があるから call denops#cache#update(#{reload: v:true}) を実行して Neovim を再起動せよ」と書いてありました。\n1[denops] ******************************************************************************** 2[denops] Deno module cache issue is detected. 3[denops] Execute \u0026#39;call denops#cache#update(#{reload: v:true})\u0026#39; and restart Vim/Neovim. 4[denops] See https://github.com/vim-denops/denops.vim/issues/358 for more detail. 5[denops] ******************************************************************************** 6[denops] Failed to load plugin \u0026#39;skkeleton\u0026#39;: TypeError: Could not find constraint in the list of versions: @std/assert@^0.226.0 7[denops] Specifier: jsr:/@std/assert@^0.226.0/assert 8[denops] at https://jsr.io/@std/path/0.225.2/windows/join.ts:4:24 そこで call denops#cache#update(#{reload: v:true}) を実行して Neovim を再起動したところ、見事にエラーが発生しなくなりました。エラーの原因は Deno のキャッシュだったようですが、Slack の Vim-jp のチャットルームでも Deno のキャッシュ周りで色々トラブルが起きているという発言がありましたので、同じトラブルに巻き込まれてしまったようです。\n追記2\nこのトラブルですが、WindowsTerminal + NuShell ではトラブルが続いているのに対し、WindowsTerminal + PowerShell では全く発生しません。原因は不明です。\nSKK を使う理由 わざわざ SKK を使っている理由ですが、まず、文節区切りをユーザーが指定するという一手間が必要なものの、変換不要な平仮名入力では確定作業が不要なため、慣れればサクサク入力できるところに魅力を感じて使っています。文節区切りをユーザーが指定する手間についても、結局「漢字から平仮名に移り変わる部分を指定するだけ」と考えれば大した手間ではありません。\nとはいえ、これだけならプラグインを導入しなくても Windows で動く SKK の corvusskk を導入すれば良い話で、Neovim 以外のアプリでは corvusskk を使っています。それでも skkeleton を使うのは、Vim/Neovim と IME の相性問題を解消するためです。\nプラグインを使わなくても IME の状態を取得・変更できる外部アプリを使えば Vim/Neovim と IME の相性問題は解消できます。実際、以前 Vim を使っていたときはそうしたアプリを Vim から呼び出して IME のオン・オフを制御していました。\nしかし、MS-IME を使う場合はこの方法で対応できますが、corvusskk を使う場合はダメでした。理由は、MS-IME だと「Normal Mode に入ったら IME オフ、Insert Mode に入ったら前回の Insert Mode での IME のオン・オフの状態を復元する」という制御で足りるのに対し、corvusskk では Insert Mode に入ったときに IME のオン・オフに加えて入力モードも復元する必要があり、その方法を見つけられなかったためです。\nそのため、Vim/Neovim のプラグインとして提供されている SKK なら IME との相性問題を解決できるだろうと思い skkeleton を使うことにしました。\n","link":"http://localhost:1313/post/2024-06-30/","section":"post","tags":["vim","neovim"],"title":"Neovim で skkeleton を使う方法"},{"body":"前置き 私のエディタ遍歴（というほどでもないですが）は、Sublime Text、Atom、Vim、VSCode という感じで、最近は VSCode を使っていました。\nしかし、VSCode は多機能で便利な反面、サクラエディタのような高速に起動するものではないため、編集したいと思ったらすぐ起動するエディタを使いたくなってきました。\nそこで Neovim を使ってみたところ、起動が早い上、Neovim 専用の SKK プラグインを導入したら日本語編集も簡単になりましたので、しばらく Neovim を使ってみようと思うようになりました。\nNeovim を快適に使うためのプラグインの導入や設定変更は現在進行中で進めていますが、完了したものから順次備忘録代わりにメモしていこうと思います。\nなお、プラグインは folke/lazy.nvim: 💤 A modern plugin manager for Neovim で管理しており、lazy.nvim に関する init.lua の設定は次のとおりです。プラグインごとに設定ファイルを分割したいので、プラグインの設定ファイルは 'C:\\Users\\(username)\\AppData\\Local\\nvim\\lua\\plugins\\' ディレクトリに保存しています。\n1local lazypath = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/lazy/lazy.nvim\u0026#34; 2if not (vim.uv or vim.loop).fs_stat(lazypath) then 3 vim.fn.system({ 4 \u0026#34;git\u0026#34;, 5 \u0026#34;clone\u0026#34;, 6 \u0026#34;--filter=blob:none\u0026#34;, 7 \u0026#34;https://github.com/folke/lazy.nvim.git\u0026#34;, 8 \u0026#34;--branch=stable\u0026#34;, -- latest stable release 9 lazypath, 10 }) 11end 12vim.opt.rtp:prepend(lazypath) 13require(\u0026#34;lazy\u0026#34;).setup(\u0026#34;plugins\u0026#34;) 環境 OS 1エディション\tWindows 11 Pro 2バージョン\t23H2 3インストール日\t‎2022/‎07/‎11 4OS ビルド\t22631.3807 5エクスペリエンス\tWindows Feature Experience Pack 1000.22700.1020.0 Neovim 1❯ nvim --version 2NVIM v0.9.4 3Build type: RelWithDebInfo 4LuaJIT 2.1.1696883897 5Compilation: C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe /MD /Zi /O2 /Ob1 -W3 -wd4311 -wd4146 -DUNIT_TESTING -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE -D_WIN32_WINNT=0x0602 -DMSWIN -DINCLUDE_GENERATED_DECLARATIONS -ID:/a/neovim/neovim/.deps/usr/include/luajit-2.1 -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/build/src/nvim/auto -ID:/a/neovim/neovim/build/include -ID:/a/neovim/neovim/build/cmake.config -ID:/a/neovim/neovim/src -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include -ID:/a/neovim/neovim/.deps/usr/include 6 7 システム vimrc: \u0026#34;$VIM\\sysinit.vim\u0026#34; 8 省略時の $VIM: \u0026#34;C:/Program Files (x86)/nvim/share/nvim\u0026#34; 9 10Run :checkhealth for more info プラグイン管理 プラグインは folke/lazy.nvim: 💤 A modern plugin manager for Neovim で管理しており、lazy.nvim にかかる init.lua の設定は次のとおりです。プラグインごとに設定ファイルを分割したいので、プラグインの設定ファイルは 'C:\\Users\\(username)\\AppData\\Local\\nvim\\lua\\plugins\\' ディレクトリに保存しています。\n1local lazypath = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/lazy/lazy.nvim\u0026#34; 2if not (vim.uv or vim.loop).fs_stat(lazypath) then 3 vim.fn.system({ 4 \u0026#34;git\u0026#34;, 5 \u0026#34;clone\u0026#34;, 6 \u0026#34;--filter=blob:none\u0026#34;, 7 \u0026#34;https://github.com/folke/lazy.nvim.git\u0026#34;, 8 \u0026#34;--branch=stable\u0026#34;, -- latest stable release 9 lazypath, 10 }) 11end 12vim.opt.rtp:prepend(lazypath) 13require(\u0026#34;lazy\u0026#34;).setup(\u0026#34;plugins\u0026#34;) ヘルプを日本語化する方法 まず、vim-jp/vimdoc-ja: A project which translate Vim documents into Japanese. で配布されている日本語のヘルプファイルを導入します。このヘルプファイルはプラグインとして導入できますので、'C:\\Users\\(username)\\AppData\\Local\\nvim\\lua\\plugins\\vimdoc-ja.lua' ファイルを用意して以下の設定を追加します。\n1return { 2 { 3 \u0026#34;vim-jp/vimdoc-ja\u0026#34;, 4 }, 5} それから :Lazy コマンドを実行して日本語ヘルプファイルをインストールします。\n日本語のヘルプファイルがインストールできましたら、init.lua に次の設定を追加して Neovim を再起動します。\n1vim.opt.helplang = \u0026#39;ja\u0026#39; これで :h hogehoge とした場合に表示されるヘルプが日本語版になります。\n1:h helplang 2 3\t*\u0026#39;helplang\u0026#39;* *\u0026#39;hlg\u0026#39;* 4\u0026#39;helplang\u0026#39; \u0026#39;hlg\u0026#39;\t文字列\t(既定では: メッセージ言語または空) 5\tグローバル 6\t{|+multi_lang| 機能つきでコンパイルされたときのみ有効} 7\tコンマ区切りの言語のリスト。これらの言語の中から、探しているヘルプが見 8\tつかった最初の言語を使う。英語のヘルプは常に優先度が最後になる。英語の 9\t優先度を上げるために \u0026#34;en\u0026#34; を追加することはできるが、そうしても、その言 10\t語に存在し、英語のヘルプに存在しないタグを見つけるだけである。 11\t{訳注: 上の文よくわからない。} 12\t例: \u0026gt; 13\t:set helplang=de,it 14\u0026lt;\tこうすると最初にドイツ語を検索し、次にイタリア語、そして最後に英語のヘ 15\tルプファイルを検索する。 16\t|CTRL-]| や英語でないヘルプファイル中で \u0026#34;:help!\u0026#34; を使ったときは、この 17\tオプションより先に現在の言語からタグを検索する。|help-translated| を参 18\t照。 ","link":"http://localhost:1313/post/2024-06-29/","section":"post","tags":["vim","neovim"],"title":"Neovim のヘルプを日本語化する"},{"body":"","link":"http://localhost:1313/archives/2024/03/","section":"archives","tags":null,"title":"2024/03"},{"body":"前置き 3Dプリンタの Voron Trident を Raspberry pi4 で制御していますが、OS をインストールしている USBメモリの調子が悪くなってきたので、先日、キオクシアの USBメモリにシステムをインストールしました。\nシステムインストール後、これまでどおり Raspberry pi4 を Voron Trident の底面に設置したところ、Wifi 接続のネットワークが不調で、SSH はしょっちゅう切れるかそもそも繋がらない、ブラウザで操作画面を開こうとしても開けないという事態になりました。\nこれでは印刷ができないので、原因を究明することにしました。\n調査 Raspberry pi4 は Voron Trident の底面に設置していますので、障害物で電波が弱まっているのかと思い、Voron Trident の底面から取り外して有線で接続して調査しました。\nまず、Wifi が壊れていないか調べるため、uoaerg/wavemon: wavemon is an ncurses-based monitoring application for wireless network devices on Linux. をインストールして確認しました。その結果ですが、間に障害物が無ければ link quiality は 100％、signal level は -20dBm 程度と全く問題ありませんでした。つまり、Wifi 機能には問題が無いということになりました。\nそこで、先人の知恵を借りるべく調査したところ、Wifi の Power Management が ONになっていると一定時間経過後に Wifi がサスペンドされてしまうので、不安定なネットワーク接続は Power Management を OFF にすれば解決できるという記事が複数見つかりました。\nOS 再インストール前から SSH 接続しているときにプチフリーズすることがよくありましたので、この解決策は効果がありそうに見えました。そこで、この解決策を採用してみることにしました。\nまずは Wifi の Power Management が ON になっているか調べるため、iwconfig wlan0 wlan0 コマンドを実行して現在の設定を確認しました。すると、以下のとおり Power Management が ON になっていました。\n1iwconfig wlan0 wlan0 2 IEEE 802.11 ESSID:\u0026#34;xxx\u0026#34; 3 〜省略〜 4 Power Management:on 対処 Wifi の Power Management を OFF にする方法は、sudo iwconfig wlan0 power off コマンドを実行することですが、この方法では Raspberry pi を再起動したときに再び Power Management が ON になってしまいます。Raspberry pi を再起動しても Power Management を OFF にしたままにするためには、**/etc/rc.local に iwconfig wlan0 power off を追加する必要があります。\n1#!/bin/sh -e 2# 3# rc.local 4（略） 5 6iwconfig wlan0 power off \u0026lt;- 追記箇所 7 8exit 0 これで Raspberry pi を再起動しても Wifi の Power Management が OFF になったままになります。\n結果 この処置を行ったところ、Raspberry pi を Voron Trident の底面に設置した状態でも SSH がきちんと繋がり、また、ブラウザの操作画面も問題なく開けるようになりました。\nまた、wavemon コマンドで電波の強度を確認したところ、さすがに障害物が全く無い状態よりは弱くなっていますが、実用上は問題ない電波強度があることが確認できました。\nwavemon の結果 参考情報 この問題の解決にあたって参考にした情報は以下のとおりです。\nRaspberry Pi4B WiFi調査メモ #RaspberryPi4 - Qiita Raspberry PiのWi-Fi接続が不安定なのをPower Management設定変更で解決した - スズハドットコム Raspberry Pi Zero WHが定期的にネットワークに繋がらなくなるので対策 | A Journey of English Study 無線状況が良好なRSSI（電波強度）はどの程度ですか | バッファロー ","link":"http://localhost:1313/post/2024-03-11/","section":"post","tags":["3Dプリンタ","RaspberryPi"],"title":"Raspberry pi のネットワークの改善"},{"body":"","link":"http://localhost:1313/archives/2024/02/","section":"archives","tags":null,"title":"2024/02"},{"body":"","link":"http://localhost:1313/tags/klipper/","section":"tags","tags":null,"title":"Klipper"},{"body":"どんな機能？ Klipper に備わっている Adaptive Meshes 機能を活用することで、印刷前のベッドメッシュレベリングの実施範囲をベッド全体から印刷範囲に限定するという機能です。\n印刷範囲に限定してレベリングを実施することでレベリングに要する時間が短くなり、また、測定ポイントが密になってレベリングの精度も上がります。\n導入方法 前提条件 この機能を使うには、Klipper の Exclude Objects 機能のメモ で紹介した Exclude Objects 機能を有効にしておく必要があります。Exclude Objects 機能を有効化していない方は、まずそちらを設定してください。\nまた、2024年03月09日時点で、この機能は公式ガイドの Installation and Configuration で解説されていますが Releases には登場していませんので、まだ正式版にはなっていないようです。なお、コミット履歴を見ますと、この機能は 2024年1月27日の コミット で追加されたようです。そのため、Klipper のバージョンは、このコミットを反映したバージョン以降とする必要があります。\nツールのインストール この機能は、印刷のたびに印刷物に合わせて printer.cfg の [bed_mesh] セクションの mesh_min や mesh_max や probe_count を調整しても実現できますが、そんな面倒くさいことは事実上不可能です。また、印刷物に合わせて Klipper オリジナルの G-Code の BED_MESH_CALIBRATE の mesh_min、mesh_max、ALGORITHM、PROBE_COUNT オプションに必要な値を渡しても実現できますが、これも相当面倒な作業になります。\nそのため、印刷する G-Code を解析してレベリングの実施範囲を算出してくれる kyleisah/Klipper-Adaptive-Meshing-Purging: A unique leveling solution for Klipper-enabled 3D printers! をインストールします。このツールは、G-Code を解析してレベリングすべき範囲とその範囲に合わせた測定ポイントの箇所数の計算して、BED_MESH_CALIBRATE の mesh_min、mesh_max、ALGORITHM、PROBE_COUNT オプションに必要な値を渡してくれます（BED_MESH_CALIBRATE コマンドの上書きもします ）。\nこのツールをインストールするには、Raspberry pi に SSH で接続して次のコマンドを実行します。\n1 cd 2 git clone https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging.git 3 ln -s ~/Klipper-Adaptive-Meshing-Purging/Configuration printer_data/config/KAMP 4 cp ~/Klipper-Adaptive-Meshing-Purging/Configuration/KAMP_Settings.cfg ~/printer_data/config/KAMP_Settings.cfg これでインストールできましたので、次は KAMP_Settings.cfg ファイルを編集して設定します。\n最低限必要な設定項目は、以下の include の中から有効化したい機能を選んでコメントアウトすることです。ひとまず、#[include ./KAMP/Adaptive_Meshing.cfg] をコメントアウトすればOKです。\n1#[include ./KAMP/Adaptive_Meshing.cfg] 2#[include ./KAMP/Line_Purge.cfg] 3#[include ./KAMP/Voron_Purge.cfg] 4#[include ./KAMP/Smart_Park.cfg] それから、variable_mesh_margin: 0 の値を変更して、レベリングする範囲を印刷物から何ミリ離した場所にするか決定します。私は印刷物から 5mm 離すことにしましたので、variable_mesh_margin: 5 としています。\nもし、jlas1/Klicky-Probe: Microswitch probe with magnetic attachement, primarily aimed at CoreXY 3d printers のようにプローブの取り付け・取り外しが必要なプローブを使っている場合、以下の variable_probe_dock_enable を true にするとともに、取り付け・取り外しのマクロの名前を指定する必要があるようです。私は誘導プローブを使っていますので、この点についてはデフォルトのまま（以下のコードのとおり）としています。\n1variable_probe_dock_enable: False 2variable_attach_macro: \u0026#39;Attach_Probe\u0026#39; 3variable_detach_macro: \u0026#39;Dock_Probe\u0026#39; あとは、printer.cfg に [include KAMP_Settings.cfg] を追加するとともに、Start G-Code に BED_MESH_CALIBRATE=default と BED_MESH_PROFILE LOAD=default を追加して通常どおり印刷すればOKのはずです。\n実際の動作 実際の動作は次のとおりです。レベリングする範囲がベッド全体ではなく印刷する範囲に限定されているのが分かると思います。\nThere should have been a video here but your browser does not seem to support it. 補足 レベリングの範囲は、印刷する G-Code をアップロードした際に Klipper が自動で追加する EXCLUDE_OBJECT_DEFINE NAME=hoge CENTER=xxx.xx,yyy.yy POLYGON=[[xx1.x,yy1.y],[xx2.x,yy2.y],[xx3.x,yy3.y],[xx4.x,yy4.y]] というコードから印刷物の範囲を割り出して、そこに variable_mesh_margin: x で設定したマージンを追加した値になるようです。\nまた、測定箇所数は、ベッド全体を測定する際の測定数 * 測定範囲の距離 / ベッド全体を測定する際の測定範囲の距離 + 1 としているようです。ただし、ソースコードを見ますと、最低でも 3x3 箇所は測定する設定になっています。\n","link":"http://localhost:1313/post/2024-03-10/","section":"post","tags":["3Dプリンタ","klipper"],"title":"Klipper の Adaptive Meshes 機能の紹介"},{"body":"前置き 自作のWebアプリで使っている The javascript spreadsheet について、備忘録としｔ\nどんなライブラリなのか？ Excel のようなスプレッドシートを Web 上に作成できる Javascript ライブラリです。Excel から直接値を貼り付けることもできますし、JSON からテーブルを作成することも可能です。また、入力値を制限することや、貼り付け前に貼り付けデータをチェックして不適切な値を除外することも可能な多機能なライブラリです。\n導入方法 NPM 以下のコマンドでインストールできます。\n1npm install jspreadsheet-ce インストールしたら、.js ファイルの先頭に以下のコードを追加してモジュールを呼び出します。\n1import jspreadsheet from \u0026#39;jspreadsheet-ce\u0026#39;; CDN HTML ファイルの \u0026lt;head\u0026gt; タグに以下のコードを追加します。\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/jspreadsheet-ce/dist/jspreadsheet.min.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; 2\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/jspreadsheet-ce/dist/index.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使い方 HTML ファイルにスプレッドシートを表示する \u0026lt;div\u0026gt; タグを追加します。\n1# index.html 2\u0026lt;div id=\u0026#34;sourceDataTable\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; それから .js ファイルで上記のタグの DOM 要素を使って表を初期化します。このとき、スプレッドシートに表示するデータを指定し、各種設定を行います。\n1// 設定例 2jspreadsheet(document.getElementById(\u0026#39;convertedDataTable\u0026#39;), { 3 data: initTableData, 4 columns: columnsConfig, 5 onbeforechange: beforechangeSourceTableTest, 6 onbeforepaste: beforePasteConvertedTable, 7 contextMenu: convertedTableContextMenuItems, 8 onbeforedeletecolumn: beforeDeleteColumn, 9 onbeforeinsertcolumn: beforeInsertColumn, 10 text: text, 11 freezeColumns: 2, 12}); 基本的な使い方は公式サイトのGetting started with Jspreadsheet CEに掲載されていますので、本記事では、実際に使うにあたって色々調べた結果を備忘録としてまとめます。\nコンテキストメニューの設定 デフォルトの状態でコピー・貼り付けなどのメニューが用意されていますが、カスタマイズする場合、スプレッドシートのオプション項目の contextMenu で設定します。\n例えば、コンテキストメニューで表示される機能を「行削除・コピー・貼り付け」の3つに限定する場合、次のコードとなります。なお、インラインでも書けると思いますが、さすがにインラインで書くには長いコードなので、定数を使っています。\n1const sourceTableContextMenuItems = (obj, x, y, e) =\u0026gt; { 2 let items = []; 3 if (obj.options.allowDeleteRow == true) { 4 items.push({ 5 title: obj.options.text.deleteSelectedRows, 6 onclick: () =\u0026gt; { 7 obj.deleteRow(obj.getSelectedRows().length ? undefined : parseInt(y)); 8 }, 9 }); 10 items.push({ 11 title: obj.options.text.paste, 12 shortcut: \u0026#39;Ctrl + V\u0026#39;, 13 onclick: () =\u0026gt; { 14 if (obj.selectedCell) { 15 navigator.clipboard.readText().then((text) =\u0026gt; { 16 if (text) { 17 jspreadsheet.current.paste(obj.selectedCell[0], obj.selectedCell[1], text); 18 } 19 }); 20 } 21 }, 22 }); 23 items.push({ 24 title: obj.options.text.copy, 25 shortcut: \u0026#39;Ctrl + C\u0026#39;, 26 onclick: () =\u0026gt; { 27 obj.copy(); 28 }, 29 }); 30 } 31 return items; 32}; 33 34// コンテキストメニューの設定部分のみ表示しています（以下同様） 35jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 36 contextMenu: sourceTableContextMenuItems, 37}); 上のコードを解説しますと、コンテキストメニューに表示するメニューを格納する items 配列を用意し、そこにメニューを1つずつ格納していきます。各メニューをどうやって設定するかが問題になりますが、いくつかのメニューについては、公式サイトに設定が掲載されています。\nしかし、公式サイトに載っていないメニューを設定しようとすると途端に難しくなります。ネットで検索して事例が見つかれば良いのですが、自分の検索方法が悪いのか事例が見つけられなかったので、かなり困りました。\nではどうやって解決したかと言いますと、Github の公式リポジトリの ソースコードの中にあるコンテキストメニューのコードを探し出し、そこから該当するメニューのコードをコピペして対処しました。例えば、貼り付けのコードは以下のリンク先にあり、コードは次のとおりです。\nhttps://github.com/jspreadsheet/ce/blob/8e62e6016d364344aa5a735b918f155ad2afd10b/src/index.js#L7188-L7203\n1// Paste 2if (navigator \u0026amp;\u0026amp; navigator.clipboard) { 3 items.push({ 4 title: obj.options.text.paste, 5 shortcut: \u0026#39;Ctrl + V\u0026#39;, 6 onclick: function () { 7 if (obj.selectedCell) { 8 navigator.clipboard.readText().then(function (text) { 9 if (text) { 10 jexcel.current.paste( 11 obj.selectedCell[0], 12 obj.selectedCell[1], 13 text, 14 ); 15 } 16 }); 17 } 18 }, 19 }); 20} このコードを元にして、以下のとおりコンテキストメニュー用のコードを書きました。上のライブラリのコードとほぼ同じコードで、function をアロー関数に置き換えています。\n1items.push({ 2 title: obj.options.text.paste, 3 shortcut: \u0026#39;Ctrl + V\u0026#39;, 4 onclick: () =\u0026gt; { 5 if (obj.selectedCell) { 6 navigator.clipboard.readText().then((text) =\u0026gt; { 7 if (text) { 8 jspreadsheet.current.paste( 9 obj.selectedCell[0], 10 obj.selectedCell[1], 11 text, 12 ); 13 } 14 }); 15 } 16 }, 17}); コピーも貼り付けと同様に公式サイトに事例が掲載されていないため、貼り付けと同様に Github のコードを元に実装しました。\n1// Copy 2items.push({ 3 title: obj.options.text.copy, 4 shortcut: \u0026#39;Ctrl + C\u0026#39;, 5 onclick: function () { 6 obj.copy(true); 7 }, 8}); メニューの日本語化 以下のコードのようにオブジェクト形式で「英語→日本語」の対応関係を定義した定数を用意して、その定数を表の初期化の際に text キーの値に指定すればOKです。\n1const text = { 2 deleteSelectedRows: \u0026#39;選択した行を削除\u0026#39;, 3 copy: \u0026#39;表の値をコピー\u0026#39;, 4 paste: \u0026#39;表に値を貼り付け\u0026#39;, 5}; 6 7jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 8 ~~~ 9 text: text, 10 ~~~, 11}); テーブルのデータ削除 テーブルのデータを削除するには、テーブルのインスタンスから setData() メソッドを呼び出して空の配列を引数として渡します。\n1/* テーブルの構造 2| X | Y | 3|-------|------| 4| 110.1 | 51.1 | 5| 120.2 | 52.2 | 6| 130.3 | 53.3 | 7*/ 8const sourceTable = jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 9 ~~~ 10}); 11const tableData = [[,]]; 12sourceTable.setData(tableData); 入力規則の設定 Excel の入力規則と同様にセルに入力できる値を制限することができます。この実装方法は2つあります。\ncolumns オプションを利用する 1つ目の実装方法は、columns オプションの type キーに値の型を設定するという方法です。例えば、2つの列をいずれも数値のみ入力できる列とする場合、type に 'numeric' を設定します。\n1const columnsConfig = [ 2 { type: \u0026#39;numeric\u0026#39;, title: \u0026#39;X\u0026#39;, name: \u0026#39;x\u0026#39; }, 3 { type: \u0026#39;numeric\u0026#39;, title: \u0026#39;Y\u0026#39;, name: \u0026#39;y\u0026#39; }, 4]; 5 6jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 7 columns: columnsConfig, 8}); 同様に、任意の列をテキストのみ受け付ける列にしたり、日付のみ受け付ける列にしたりできます。列に設定できる入力値の型は、公式サイトの Column types に掲載されています。\nonbeforechange イベントを利用する 2つ目の実装方法は、onbeforechange イベントのコールバック関数を使って入力しようとした値を入力前の段階でチェックして、入力して欲しくない値を入力させないという方法です。例えば、数値のみ入力させたいが、全角数値は半角数値に変換して受け入れるという条件にしたい場合、以下のように onbeforechange イベントのコールバック関数で入力値を処理することで、そうした複雑な条件の入力規則を設定できます。\n入力値は value という変数で取得できますので、この変数をチェックして、全角・半角数値が入力されたなら半角数値に変換して受け入れて、全角・半角数値以外が入力されたなら false を返すことで、全角・半角数値のみ受け入れるという入力規則を実現できます。\nなお、コールバック関数に渡す引数については、value しか利用しない場合でも instance、cell、x、y といった引数を渡す必要があるようです（渡さないとエラーになりました）。\n1const beforechangeSourceTable = (instance, cell, x, y, value) =\u0026gt; { 2 if (isValidNumber(zen2han(value))) { 3 return zen2han(value); 4 } else { 5 return \u0026#39;\u0026#39;; 6 } 7}; 8const sourceTable = jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 9 data: initTableData, 10 columns: columnsConfig, 11 onbeforechange: beforechangeSourceTable, 12 contextMenu: sourceTableContextMenuItems, 13 onbeforedeletecolumn: beforeDeleteColumn, 14 onbeforeinsertcolumn: beforeInsertColumn, 15 onpaste: afterPaste, 16 text: text, 17 freezeColumns: 2, 18}); info: なお、ここで登場する isValidNumber() と zen2han() 関数は自作関数で、前者は数値のように見える値は数値に変換して返すという関数で、後者は全角数値を半角数値に変換して返すという関数です。\n表の編集禁止 結果を表示するだけで編集を予定していない表を作成したい場合、表を読み取り専用にすることができます。\n方法は、表の初期化の際に設定する columns オプションに readOnly キーを追加して値を true にするというものです（公式サイトの実装例に掲載されています）。columns オプションで設定することから、読み取り専用にするか否か列単位で決めていきます。そのため、表全体を読み取り専用にする場合、全ての列を読み取り専用にする必要があります。\n1const columnsConfig = [ 2 { type: \u0026#39;numeric\u0026#39;, title: \u0026#39;X\u0026#39;, width: 180, name: \u0026#39;x\u0026#39;, readOnly: true }, 3 { type: \u0026#39;numeric\u0026#39;, title: \u0026#39;Y\u0026#39;, width: 180, name: \u0026#39;y\u0026#39;, readOnly: true }, 4]; 5jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 6 columns: columnsConfig, 7}); これで表が読み取り専用になるとともに、セルの値がグレーアウトして読み取り専用であることを示すようになります。\nまた、表の値を変更しても元に戻ってしまう状態にすることで、データの読み取りにしか使えない表を作ることもできます。\n方法は、表の初期化の際に設定する onbeforechange イベントにコールバック関数を設定し、変更前のセルの値をその関数の戻り値にするというものです。ここで使用している getValueFromCoords() メソッドは、XYで指定されたセルの値を返すメソッドです。\n1jspreadsheet(document.getElementById(\u0026#39;sourceDataTable\u0026#39;), { 2 onbeforechange: (instance, cell, x, y, value) =\u0026gt; { 3 return instance.jspreadsheet.getValueFromCoords(x, y); 4 }, 5}); 貼り付け無効化 表に値を貼り付けできないようにすることもできます。\n方法は、表の初期化の際に設定する onbeforepaste イベントにコールバック関数を設定して、そのコールバック関数の戻り値を false にするというものです。公式サイトのFAQに掲載されています。\n1jspreadsheet(document.getElementById(\u0026#39;spreadsheet\u0026#39;), { 2 onbeforepaste: (instance, data, x, y) =\u0026gt; { 3 return false; 4 } 5}); ","link":"http://localhost:1313/post/2024-03-03/","section":"post","tags":["プログラミング"],"title":"Jspreadsheet のメモ"},{"body":"","link":"http://localhost:1313/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/","section":"tags","tags":null,"title":"プログラミング"},{"body":"どんな機能なのか？ 複数の stl ファイルを同時に印刷している際に、途中で一部のファイルだけ印刷を中止できる機能です。具体的には、6つのファイルを同時に印刷していたら1つだけビルドプレートから剥がれてしまったという場合に、その1つだけ印刷を中止して残りの5つは最後まで印刷するという機能です。これにより、印刷に失敗したパーツの印刷を続けて思わぬトラブルを引き起こす心配がなくなりますし、無駄なフィラメントの消費も抑えられますので、非常に有用な機能です。\nこの機能を使うには、Klipper、Moonraker およびスライサーで所要の設定を行う必要がありますが、手順を紹介した日本語の記事が見当たらなかったので、備忘録代わりにメモします。\nなお、公式ガイドは Exclude Objects - Klipper documentation で、この記事は2024年2月12日時点の情報を元に書いています。\n対応バージョン Exclude Objects 機能を使うには、Klipper などのバージョンを以下のバージョン以上にアップデートする必要があります。\nKlipper v0.10.0-438 Moonraker v0.7.1-445 Mainsail v2.1.0 Fluidd v1.19.0 また、この処理は結構重い処理ということなので、Raspberry pi zero のような非力なシングルボードコンピュータでは厳しいようです。\nKlipper と Moonraker のバージョンについては Exclude Objects - Mainsail に記載された情報を元に記載していますが、公式情報で確認した範囲では、Klipper は v0.11.0 で正式に対応したようです。Moonraker については、CHANGELOG などで対応時期を確認することはできませんでしたが、公式ドキュメントの Github のコミット履歴を見ると、2021年12月5日のコミットでこの機能に関する説明が追加されていますので、この頃に対応したものと思われます。 必要な設定 この機能を使うための Klipper、Moonraker およびスライサーの設定は次のとおりです。\nKlipper の設定 printer.cfg に [exclude_object] セクションを追加するだけです。\n1# printer.cfg 2+ [exclude_object] Moonraker の設定 moonraker.conf の [file_manager] セクションに enable_object_processing: true を追加します。Moonraker のバージョンによっては、enable_object_processing: false という設定が最初から存在しているかもしれません。その場合、false を true に変えればOKです。\n1# moonraker.conf 2[file_manager] 3- enable_object_processing: false 4+ enable_object_processing: true Mainsail や Fluidd の設定 Klipper と Moonraker を設定すれば Mainsail や Fluidd の設定は不要です。\nスライサーの設定 PrusaSlicer の場合、「プリント設定 → 出力オプション → オブジェクトにラベルを付ける」と選択して、ドロップダウンメニューから「OctoPrint のコメント」を選択すればOKです。\nPrusaSlicerの設定 SuperSlicerの場合、「プリント設定 → 出力オプション」と選択して、「オブジェクトにラベルを付ける」というチェックボックスにチェックを付ければOKです。\nSuperSlicerの設定 それから、印刷したい stl ファイルをプレートに並べてスライスし、G-code をプリンタに送信します。スライスは普段どおり行なえばOKです。\nスライス画面 この機能の使い方 必要な設定が完了していれば、Mainsail や Fluidd の印刷状況を示すボックスにキャンセルするためのボタンが追加されているはずです（印刷前の時点では表示されていません）。ちなみに、この画面は Fluidd の場合のものです。\n個別キャンセルのボタン 印刷が始まって印刷を中止したいパーツが出てきましたら、上記のキャンセルボタンをクリックします。\nすると、現在印刷しているパーツのリストが表示されますので、印刷を中止したいパーツの右側にあるストップボタンをクリックします。\n印刷中のパーツリスト すると、印刷を中止するか尋ねられますので、Yes をクリックします。\n確認画面 これで、選択したパーツの印刷が中止されますので、あとは他のパーツの印刷が終わるのを待つだけです。\nキャンセル後の画面 実際の印刷の様子 この機能を使って3つのパーツのうち1つのパーツの印刷を中止した時の印刷の様子を撮影しましたので、参考までに掲載します。\nThere should have been a video here but your browser does not seem to support it. ","link":"http://localhost:1313/post/2024-02-12/","section":"post","tags":["3Dプリンタ","klipper"],"title":"Klipper の Exclude Objects 機能のメモ"},{"body":"","link":"http://localhost:1313/archives/2024/01/","section":"archives","tags":null,"title":"2024/01"},{"body":"前置き 我が家の Prusa MK3S+ は公式ファームウェアではなく Klipper 化して印刷していますが、年明けから印刷中に MCU ‘mcu’ shutdown: Timer too close エラーが毎回発生して印刷できない状態になってしまいました。\nこのエラーは以前からまれに発生していたのですが、そのときは Raspberry pi を再起動すれば印刷できていたのに、今回は Raspberry pi を再起動してもエラーが解消されない状態になっていました。\nそこでエラー解消のために色々取り組んで、やっとエラーが発生せずに印刷を完了させられるようになりましたので、取り組んできたことなどを備忘録としてまとめます。\nこのエラーの内容 このエラーがどういう場合に発生するのかについては、以下のサイトで次のように説明されています。\nTimer too close - Knowledge Base - Klipper\nThis error typically occurs when the host sends a message to the MCU, scheduling an event at a time that is in the past.\nこのエラーは、典型的には、ホストがMCUにメッセージを送信し、過去の時刻にイベントをスケジューリングした場合に発生する。（拙訳）\nこれだけだとよく分からないですが、エラー発生時に補足情報として表示される以下のメッセージと合わせて読むと、Raspberry pi がプリンタのマザーボード（Prusa MK3S+ であれば Einsy board）に命令を送る際に、何らかの原因で送信が滞って現在時刻より前の命令がスケジューリングされてしまった場合に発生するエラーだということが分かります。\n1This often indicates the host computer is overloaded. Check for other processes consuming excessive CPU time, high swap usage, disk errors, overheating, unstable voltage, or similar system problems on the host computer. 最初に実施した対応策 上記の補足情報で「This often indicates the host computer is overloaded.」とありますので、Raspberry pi の負荷を下げるため、カメラを使わない設定に変更して USBカメラを取り外しました。\nそのうえで、同じエラーが発生した時のシステム状況を確認するため、システムタブを録画しながら印刷しましたが、同じエラーが発生したうえ、使用率もエラーが発生する前に跳ね上がるようなことはありませんでした。\nただ、エラーが起きると少しの間だけ画面更新が止まってしまってエラー発生直後の状況が分からなかったため、今度は印刷前に SSH でRaspberry pi にアクセスして、印刷中の負荷を dmstat コマンドで確認するという方法を採りました。すると再びエラーになりましたが、エラー発生前に負荷が上昇するということはありませんでした。むしろ、エラーが発生した後に負荷が上昇していました。これは、エラー発生に伴う後始末を行っているためと思われます。\n解決に至った対応策 カメラを外す以外に Raspberry pi の負荷を下げる方法が思いつかず行き詰まっていましたが、上記で紹介した解説ページで挙げられていた原因の中に「Disk errors / dying SD card」があったのを思いだしたので、Raspberry pi OS をインストールしている USBメモリを確認することにしました。\n確認方法ですが、Check Flash というソフトで USBメモリの全セクタについてチェックするという方法を採用しました。\nソフトダウンロード先（ソフト作者のウェブサイトが消滅していますので Internet Archive をリンク先にしています） https://web.archive.org/web/20220103143823/http://mikelab.kiev.ua/index_en.php?page=PROGRAMS%2Fchkflsh_en\nこのチェックは USBメモリのデータを全て削除するため、設定ファイルを手元の PC にダウンロードしてからチェックしました。すると、書き込み不可などのエラーが 1,000近くあることが判明しました。そのため、この USBメモリの不具合が Timer too close エラーの原因ではないかと仮定しました。\nそこで、同様にエラーチェックしてもエラーが出ない USBメモリにシステム一式をインストールして必要な設定も行い、プリンタのマザーボードに新しいファームウェアを書き込みました。そして、エラーが発生していた時に印刷しようとしていたモデルを、同じ設定でスライスして印刷したところ、Timer too close エラーが発生することなく印刷が完了しました。\nそれから他のモデルも印刷していますが、Timer too close エラーは発生していないので、Timer too close エラーの原因は壊れ始めていた USBメモリだったようです。\nこの記事が同じエラーに悩まされている方にとって何かの参考になれば幸いです。\n補足 USBメモリの更新に伴って Klipper のバージョンも新しくなっていますが、Timer too close エラーで印刷できなかったときと同じバージョンで昨年末までは印刷できていましたので、Klipper のバージョンアップはエラーの原因とは考えにくいところです。\n","link":"http://localhost:1313/post/2024-01-18/","section":"post","tags":["3Dプリンタ"],"title":"Klipper の Timer too close エラーを解消した話"},{"body":"前置き 新しいフィラメントを使うときは、そのフィラメントに適した温度・Pressure Advance・射出率・リトラクション長を見つけ出すために色々とテストしますが、テスト印刷した造形物を顕微鏡で観察してみたくなりましたので、観察結果を紹介します。\nちなみに、テストしたフィラメントは次の2つです。\nAmazon.co.jp: GratKit PLAフィラメント 3Dプリンター フィラメント 1.75mm 寸法精度+/-0.03mm ほとんどのFDM式プリンターに対応 1KG/ロール オレンジ : 産業・研究開発用品 Amazon.co.jp: GratKit PLAフィラメント 3Dプリンター フィラメント 1.75mm 寸法精度+/-0.03mm ほとんどのFDM式プリンターに対応 1KG/ロール グレー : 産業・研究開発用品 また、使用した顕微鏡はこちらの商品です。\nAmazon.co.jp: Andonstar AD207 USBデジタル顕微鏡 AD207 7インチLCDディスプレイと3Dビジュアルエフェクト付き 回路基板修理サービングツール : おもちゃ\n射出率調整の造形物の観察結果 私は、射出率を Extrusion Multiplier | Ellis’ Print Tuning Guide で紹介されている方法で調整しています。この方法を簡単に紹介すると、300x300x30mm のキューブを射出率を変えながら印刷し、その結果を目視で見比べて適切な射出率を選び出すというものです。\nそこで、以下のとおりキューブを5つ並べて各キューブの射出率を90%・92%・94%・96%・98%・100%に設定し、その結果を顕微鏡と手触りで確認しました。\nスライサーの画面 顕微鏡で印刷物の上面を撮影した結果は次のとおりです。写真だと分かりにくいですが、射出率が増えるに従って表面がデコボコしてくる感じになります。また、射出率を80%まで下げると、肉眼で分かる穴が空くようになります（矢印で示した場所）。\n射出率90% 射出率92% 射出率94% 射出率96% 射出率98% 射出率100% 射出率80% 顕微鏡写真で見れば肉眼より正確に判断できるかと思ったのですが、肉眼で虫眼鏡で向きを変えながら見る方法でも顕微鏡と同じ結果になりましたので、キャリブレーションのたびに顕微鏡を取り出してくる必要はなさそうです。ちなみに、今回のキャリブレーションの結果、射出率は96%とすることにしました。\nPressure Advance の調整の観察結果 Pressure Advance の調整は、Ellis' Pressure Advance / Linear Advance Calibration Tool で G-code を生成して印刷する方法で調整しています。Klipper 公式の方法より短時間かつ結果が読み取りやすいので、このサイトを見つけてからずっとこの方法で調整しています。\n生成した G-Code を印刷した結果は次のとおりです。射出率のときは違いが分かりにくかったですが、こちらは違いがよく分かります。\n結果1 結果2 結果3 結果4 結果5 写真を見ると分かりますが、Pressure Advance が 0.000-0.025 の間だと角の外側が膨らんでしまい、0.045 を越えると角の手前で押し出し不足が発生してしまいます。そのため、0.030-0.040 の間に最適値があることになりますが、0.040 は角の外側が膨らまない一方で角の内側の直角がなまってしまっています。そのため、その直前の 0.035 を Pressure Advance として採用することにしました。とはいえ、肉眼で確認したときも同じ結果でしたので、顕微鏡を取り出さないと正確な判断ができないということはなさそうです。\nまとめ 顕微鏡を使えば肉眼で確認するときより簡単に判別できるようになるかと思ったのですが、結果的に肉眼で見たときと同じ結果になりました。\nそのため、顕微鏡を取り出してくる手間を考えると、肉眼＆虫眼鏡という組み合わせで確認する方法で必要十分な結果が得られるという結論が出たところで、本記事を終りたいと思います。\n","link":"http://localhost:1313/post/2024-01-05/","section":"post","tags":["3Dプリンタ"],"title":"3Dプリンタの造形物を顕微鏡で観察した結果"},{"body":"前置き 1キーで Alt-Tab の動作を実現したいと以前から思っていましたが、上手い実装方法が見つからず断念していました。ところが、先日あらためて実装方法を探してみるとあっさり実装方法が見つかりましたので、早速導入してみました。\nこの方法は癖が強いものの慣れれば結構快適な動作なので、その方法を備忘録代わりにまとめます。\n必要なコード まずはこの処理の実装コードを掲載します。処理の流れなどはコードの後に説明します。\n1bool is_alt_tab_active = false; // ADD this near the begining of keymap.c 2uint16_t alt_tab_timer = 0; // we will be using them soon. 3 4enum custom_keycodes { 5 QWERTY = SAFE_RANGE, 6 ALT_TAB 7}; 8 9// ALT_TAB キーのキーマップへの割り当てコードは省略 10 11bool process_record_user(uint16_t keycode, keyrecord_t *record) { 12 switch (keycode) { 13 case ALT_TAB: 14 if (record-\u0026gt;event.pressed) { 15 if (!is_alt_tab_active) { 16 is_alt_tab_active = true; 17 register_code(KC_LALT); 18 } 19 alt_tab_timer = timer_read(); 20 register_code(KC_TAB); 21 } else { 22 unregister_code(KC_TAB); 23 } 24 break; 25 case KC_RIGHT: case KC_LEFT: case KC_DOWN: case KC_UP: case KC_TAB: 26 if (is_alt_tab_active) { 27 alt_tab_timer = timer_read(); 28 } 29 break; 30 default: 31 if (is_alt_tab_active) { 32 unregister_code(KC_LALT); 33 is_alt_tab_active = false; 34 } 35 break; 36 } 37 return true; 38} 39 40void matrix_scan_user(void) { 41 if (is_alt_tab_active \u0026amp;\u0026amp; timer_elapsed(alt_tab_timer) \u0026gt; 1000) { 42 unregister_code(KC_LALT); 43 is_alt_tab_active = false; 44 } 45} 動作の流れ 動作の流れは次のとおりです。コードを見れば分かる方は無視してください。\nkeymap.c に bool is_alt_tab_active = false 変数を定義して、Alt-tab 処理を実現している最中か判別するためのフラグを用意する keymap.c に uint16_t alt_tab_timer = 0 変数を定義して、Alt-tab 処理を開始した時間を記録できるようにする キーマップに専用のキー（ここでは ALT-TAB ）を割り当てる process_record_user 内の switch 文に ALT-TAB に対応する case 文を追加する ALT-TAB が押されて、かつ is_alt_tab_active 変数が false であれば、is_alt_tab_active 変数を true にする register_code(KC_LALT) で Alt キーを押した状態を実現する alt_tab_timer = timer_read() で ALT-TAB キーを押した時間を記録する register_code(KC_TAB) で Tab キーを押した状態を実現する ALT-TAB キーが離されたら、unregister_code(KC_TAB) で Tab キーを離した状態にする matrix_scan_user で is_alt_tab_active 変数が true かつ ALT-TAB キーを押してから 1000ミリ秒が経過（timer_elapsed(alt_tab_timer) \u0026gt; 1000 を満たす場合）していた場合、unregister_code(KC_LALT) で Alt キーを離した状態にするとともに、is_alt_tab_active = false でフラグを下ろす。 もし、is_alt_tab_active 変数が true のときに上下左右の矢印キーが押された場合、alt_tab_timer をその時点の時間に置き換えてウィンドウ選択の時間を確保できるようにする。 もし、is_alt_tab_active 変数が true のときに上下左右の矢印キー以外が押された場合、unregister_code(KC_LALT) で Alt キーを離した状態にするとともに、is_alt_tab_active = false でフラグを下ろす（Enterキーでウィンドウを選択した場合を想定した設定）。 補足 1キーで Alt-Tab を実現している以上、Alt キーを押しながらのんびり Tab キーを押してウィンドウを選択するという処理はできません。そのため、一回該当するキーを押したら、速やかにカーソルキーで移動先のウィンドウを選択する必要があります。\n私の場合、ホームポジションから手を動かさずにレイヤー移動でカーソルキーにアクセスできるので上記の制限は問題にならないのですが、手を動かさないとカーソルキーにアクセスできない場合はちょっと問題になるかもしれません。\n参考資料 上記のコードの元ネタのファイルは https://github.com/qmk/qmk_firmware/pull/22695 のプルリクで削除されているので、削除前のファイルへのリンクを掲載 https://github.com/qmk/qmk_firmware/blob/d235352504f82eae5dedc399bae36c65f1348fa8/keyboards/dz60/keymaps/_bonfire/not-in-use/super-alt-tab.c\n","link":"http://localhost:1313/post/2024-01-04/","section":"post","tags":["備忘録","自作キーボード"],"title":"QMK Firmware で Alt-tab を実現する方法"},{"body":"前置き 私が作成しているウェブアプリでは Bootstrap5 を使っていますが、ウィンドウ幅の変更に伴って横並びと縦並びを切替える際にボーダーの向きを変えたいと思い、以下のページの方法を使ってレスポンシブなボーダーを実現しました。\n実装自体は以下のページの方法を見ればあっさり出来ましたが、なぜこのコードで実現できるのか理解するため、コード中に出てくる変数などの調査結果を備忘録として残します。\nResponsive Border Utilities · Issue #23892 · twbs/bootstrap\n方法 私が実現したいボーダーは、Bootstrap5 のブレークポイントと同じウィンドウ幅・プレフィックスで切り替えられるボーダーです。を実装するにはウィンドウ幅にメディアクエリ方法は、border-lg-bottom のような既存のクラス (border-bottom) を拡張したクラスを用意するというものです。\n既存のクラスの拡張は手作業でもできますが、ボーダーの方向（全方向・上下・左右・上・下・左・右の7種類）とブレークポイント（sm・md・lg・xl・xxlの5種類）の組み合わせだけでも35種類になることから、手作業で設定するのは非現実です。そのため、SASS の @each メソッドと Bootstrap5 が用意している変数を利用して一気に作成します。ただし、Bootstrap5 が用意している変数を利用するには Bootstrap5 をローカルにインストールする必要がありますので、以下のコマンドでインストールします。\n1npm install bootstrap@5.3.2 Bootstrap5 をローカルにインストールしたら scss ファイルに次のコードを追加します。\n1@import \u0026#34;bootstrap/scss/bootstrap\u0026#34;; 2 3@each $breakpoint in map-keys($grid-breakpoints) { 4 @include media-breakpoint-up($breakpoint) { 5 $infix: breakpoint-infix($breakpoint, $grid-breakpoints); 6 7 .border#{$infix}-top { border-top: $border-width solid; } 8 .border#{$infix}-end { border-right: $border-width solid; } 9 .border#{$infix}-bottom { border-bottom: $border-width solid; } 10 .border#{$infix}-start { border-left: $border-width solid; } 11 12 .border#{$infix}-top-0 { border-top: 0 !important; } 13 .border#{$infix}-end-0 { border-right: 0 !important; } 14 .border#{$infix}-bottom-0 { border-bottom: 0 !important; } 15 .border#{$infix}-start-0 { border-left: 0 !important; } 16 17 .border#{$infix}-x { 18 border-left: $border-width solid $border-color ; 19 border-right: $border-width solid $border-color ; 20 } 21 22 .border#{$infix}-y { 23 border-top: $border-width solid $border-color ; 24 border-bottom: $border-width solid $border-color ; 25 } 26 } 27} $grid-breakpoints 変数は以下のとおり定義されたマップ型の変数で、ブレークポイントを示すプレフィックスとブレークポイントを適用するサイズが定義されています。\n1// scss/_variables.scss 2$grid-breakpoints: ( 3 xs: 0, 4 sm: 576px, 5 md: 768px, 6 lg: 992px, 7 xl: 1200px, 8 xxl: 1400px 9); この $grid-breakpoints 変数の全キーを map-keys 関数でまとめて取得し、それを @each メソッドに渡して順番に取り出して $breakpoint 変数に格納します。これで $grid-breakpoints 変数に定義されている各ブレークポイントのプレフィックスが順番に処理されることとなります。\nそれから $breakpoint 変数に格納されているブレークポイントのプレフィックスを media-breakpoint-up ミックスインに引数として渡します。media-breakpoint-up ミックスインの定義は以下のとおりで、渡されたプレフィックスに応じたブレークポイントの最小幅を min-width に設定し、@content の部分に呼び出し側の .border#{$infix}-top から .border#{$infix}-y までの部分を展開します。\n1// scss/mixins/_breakpoints.scss 2// Media of at least the minimum breakpoint width. No query for the smallest breakpoint. 3// Makes the @content apply to the given breakpoint and wider. 4@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) { 5 $min: breakpoint-min($name, $breakpoints); 6 @if $min { 7 @media (min-width: $min) { 8 @content; 9 } 10 } @else { 11 @content; 12 } 13} また、呼び出し側の3行目に出てくる breakpoint-infix 関数は、渡されたブレークポイントに - を追加して返す（xs の場合は \u0026quot;\u0026quot; を返す）関数です。関数の定義は以下のとおりです。\n1// scss/mixins/_breakpoints.scss 2// Returns a blank string if smallest breakpoint, otherwise returns the name with a dash in front. 3// Useful for making responsive utilities. 4// 5// \u0026gt;\u0026gt; breakpoint-infix(xs, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px, xxl: 1400px)) 6// \u0026#34;\u0026#34; (Returns a blank string) 7// \u0026gt;\u0026gt; breakpoint-infix(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px, xxl: 1400px)) 8// \u0026#34;-sm\u0026#34; 9@function breakpoint-infix($name, $breakpoints: $grid-breakpoints) { 10 @return if(breakpoint-min($name, $breakpoints) == null, \u0026#34;\u0026#34;, \u0026#34;-#{$name}\u0026#34;); 11} ","link":"http://localhost:1313/post/2023-11-05/","section":"post","tags":[],"title":"2023 11 05"},{"body":"このブログについて プログラミングや3Dプリンタや自作キーボードの話題を中心に、自分が学んだことを色々書いていくブログです。それ以外の時事ネタなども気が向いたら書きます。\nちなみに、以前はさくらサーバに WordPress をインストールしてブログを作っていましたが、更新の度に WordPress 特有の書き方に悩まされたりするのが嫌になったので、Hugo に切り替えました。\n管理人について 2019年に自作キーボードの Mint60 を組み立てて自作キーボードの面白さに目覚め、キーボードのパーツづくりのために導入した Anycubic Mega S で3Dプリンタの面白さにも目覚め、それ以来この2つについて色々と取り組んでいる公務員です。\n公務員として担当してきた業務は、国有財産の管理に関する業務が中心で、その他に会計業務も5年以上担当し、少しだけ経済調査業務も担当してきました。\nブログタイトルの意味 インターネットの片隅の閑古鳥が鳴いているような場所にあるブログ、という意味を込めています。\nリンク Github (s-show) Qiita (s-show) Reddit (s-show) E-Mail: kankodori.blog （この後ろは @gmail.com が続きます） ライセンス このブログの内容は、 クリエイティブ・コモンズ 表示 4.0 国際 ライセンスの下に提供されています。\n","link":"http://localhost:1313/about/","section":"","tags":null,"title":"自己紹介"},{"body":"","link":"http://localhost:1313/archives/2023/10/","section":"archives","tags":null,"title":"2023/10"},{"body":"前置き 我が家で稼働している Voron V0.0 で正方形の造形物を印刷したら、目で見て分かるレベルで歪みが出て平行四辺形になってしまいました。\nインストールするパッケージの選択 本来なら、分解して再度組み立てるべきなのですが、Voron V0.0 を組み立ては苦難の連続で再組み立ては非常に気が重いので、何とかしてソフトウェアベースで対応したいと思い、Klipper の機能である Skew correction - Klipper documentation を適用して、完全スコヤを使わなければ歪みを確認できない程度まで矯正することができました。\nインストールするパッケージの選択 ただ、Skew correction について解説した日本語記事が見当たらなかったので、備忘録代わりにまとめます。\nSkew correction の説明 まず、Skew correction について説明する必要がありますが、Klipper の公式リファレンスの冒頭に次の記載があります。簡単に言うと、可能な限り正確にプリンタを組み立てても生じる歪みをソフトウェアで補正するというものです。\nSoftware based skew correction can help resolve dimensional inaccuracies resulting from a printer assembly that is not perfectly square. Note that if your printer is significantly skewed it is strongly recommended to first use mechanical means to get your printer as square as possible prior to applying software based correction.\nソフトウェアベースの歪み訂正は、プリンタの組み立てが正確な四角形ではないことに由来する不正確な寸法を解決することを助けます。注意事項として、もし、あなたのプリンタが著しく歪んでいる場合、ソフトウェアベースの訂正を適用する前に、機械的な訂正、つまり、可能な限りプリンタを正確な四角形に組み立てることを強く勧めます。（拙訳）\nSkew correction の使い方 Skew correction を使うには、次の作業が必要です。\nprinter.cfg の編集 プリンタの歪みの計測 プリンタの歪みの計測値の保存 計測値を適用するための Start G-code の編集 printer.cfg の編集 Skew correction を使うには、まず printer.cfg に [skew_correction] セクションを追加します。\nプリンタの歪みの計測と計測値の保存 続いて、プリンタの歪みを計測して定量化します。歪みの計測と定量化する方法ですが、公式リファレンスで紹介されている方法は、計測のためのモデルを印刷して所定の3か所の距離を測り、その3か所の距離を専用の G-code の引数として与えて歪みを定量化するというものです。\n専用のモデルは YACS (Yet Another Calibration Square by Paciente8159 - Thingiverse で、これをプリンタのベッドの大きさに合わせて縦横比を保ったまま拡大縮小して印刷し、次の画像に示した箇所の距離を測ってメモしておきます。\nhttps://www.klipper3d.org/Skew_Correction.html より モデルをスライサーにセットしたところ 次は計測した距離と G-code を使って歪みを定量化します。例えば、3か所の距離が次の値だった場合の G-code は次のとおりとなりますので、この G-code を Console に入力して実行します。\n計測結果 AC間の距離: 63.97 BD間の距離: 63.70 AD間の距離: 50.22 G-code SET_SKEW XY=63.97,63.70,50.22 ( '=' 以降の数値部分に空白があるとエラーになります ) これで計測した距離に基づいてプリンタの歪みを定量化できましたので、SKEW_PROFILE SAVE=my_skew_profile コマンドで計算結果を my_skew_profile というプロファイル名で保存します。なお、プロファイル名は好きな名前に設定できます。\nそして、SAVE_CONFIG コマンドで計算結果を printer.cfg ファイルに保存します。これで計測値を適用する準備ができました。\n計測値の適用 定量化したプリンタの歪みは printer.cfg に保存されましたが、これを印刷に適用するには SKEW_PROFILE LOAD=my_skew_profile G-code でロードする必要があります。\nそのため、この G-code を Start G-code に登録して、印刷するたびに呼び出されるようにする必要があります。登録方法は、次の2つがあります。\nスライサーの Start G-code に登録する printer.cfg のスタートマクロに登録する 私の Start G-code は、ホットエンド加熱等の印刷準備の G-code をまとめた PRINT_START マクロを printer.cfg に追加し、このマクロをスライサーの Start G-code で呼び出す形にしていますので、2番目の方法を採用しました。\nではどのタイミングで SKEW_PROFILE LOAD=my_skew_profile G-code を使うかが問題になりますが、公式リファレンスの末尾の注意書き（caveats）に次の記述があります。\nDue to the nature of skew correction it is recommended to configure skew in your start gcode, after homing and any kind of movement that travels near the edge of the print area such as a purge or nozzle wipe. You may use use the SET_SKEW or SKEW_PROFILE gcodes to accomplish this. It is also recommended to issue a SET_SKEW CLEAR=1 in your end gcode. Keep in mind that it is possible for [skew_correction] to generate a correction that moves the tool beyond the printer's boundaries on the X and/or Y axes. It is recommended to arrange parts away from the edges when using [skew_correction].\nskew_correction の性質のために、Start G-code の中のホーミングに加えて、ノズルワイプまたはノズルパージのような造形エリアの端っこ付近での何らかの移動の後に Skew correction を設定することが推奨されています。Skew correction を達成するために SET_SKEW または SKEW_PROFILE G-code を使えます。End G-code の中で SET_SKEW CLEAR=1 を発行することも推奨されます。 [skew_correction] には、X 及び（または） Y 軸の境界を越えるツールの移動を補正として生成する可能性があることを念頭においてください。[skew_correction] を使う時は、造形物を印刷エリアの境界付近から遠ざける工夫を行うことが推奨されます。（拙訳）\nこの記述を踏まえて、私は次の箇所に SKEW_PROFILE LOAD=my_skew_profile と SET_SKEW CLEAR=1 を挿入しました。CLEAN_NOZZLE の前にいったん SET_SKEW CLEAR=1 で Skew correction をクリアしているのは、ノズルクリーニングがプリンタの可動範囲ギリギリで行う動作で、Skew correction を有効にして歪み補正を行うと移動先がプリンタの可動範囲の外になってエラーになるためです。\n1[gcode_macro PRINT_START] 2gcode: 3 SKEW_PROFILE LOAD=my_skew_profile 4 G28 5 {% set BED_TEMP = params.BED_TEMP|default(60)|float %} 6 {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(210)|float %} 7 M140 S{BED_TEMP} 8 M190 S{BED_TEMP} 9 M109 S{EXTRUDER_TEMP} 10 11 SET_SKEW CLEAR=1 12 CLEAN_NOZZLE 13 Z_TILT_ADJUST 14 G28 15 SKEW_PROFILE LOAD=my_skew_profile 16 17 M107 18 G21 ; set units to millimeters 19 G90 ; use absolute coordinates 20 M83 ; use relative distances for extrusion 21 22[gcode_macro CLEAN_NOZZLE] 23variable_start_x: 270 24variable_start_y: 345 25variable_start_z: 4 26variable_wipe_dist: -40 27variable_wipe_qty: 3 28variable_wipe_spd: 50 29variable_raise_distance: 30 30gcode: 31 {% if \u0026#34;xyz\u0026#34; not in printer.toolhead.homed_axes %} 32 G28 33 {% endif %} 34 35 ## Move nozzle to start position 36 G1 X{start_x} Y{start_y} F6000 37 G1 Z{start_z} F1500 38 39 ## Wipe nozzle 40 {% for wipes in range(1, (wipe_qty + 1)) %} 41 G1 X{start_x + wipe_dist} F{wipe_spd * 60} 42 G1 X{start_x} F{wipe_spd * 60} 43 {% endfor %} 44 45 ## Raise nozzle 46 G1 Z{raise_distance} これで Skew correction を適用してプリンタの歪みによって生じる印刷物の歪みを軽減できるようになりました。\n本記事が何かの参考になれば幸いです。不明な点等がありましたら、コメント欄でお尋ねください。\n","link":"http://localhost:1313/post/2023-10-08/","section":"post","tags":["備忘録","3Dプリンタ"],"title":"Klipper の Skew correction でプリンタの歪みによる問題を解消する"},{"body":"前置き 仕事で「XY座標を使ってオンライン地図に土地の境界点を示すアプリが欲しい」と思って自作したのですが、アプリ制作で使った Leaflet - a JavaScript library for interactive maps について、メモしておかないと忘れそうな点がありましたので、備忘録としてまとめます。\nなお、作成したアプリは 座標の地図表示と座標・緯度経度の変換 というものです。\n地図に追加したマーカーの削除 leaflet を使って地図にマーカーを追加する方法は検索すればいくつも見つかりますが、追加したマーカーをまとめて削除する方法が見つけられませんでした。\nそこで色々調べて、マーカーをまとめて削除する方法を何とか編み出しました。\nまず、leaflet では、追加したマーカーは layer として map インスタンスに追加されます。map インスタンスにはマーカー以外のレイヤーも存在していますが、どのレイヤーがマーカーのレイヤーなのかを特定できれば、そのレイヤーを削除することでマーカーを削除できます。\n私が調べた限りでは、マーカーのレイヤーのプロパティには _icon というキーが追加され、このキーに対応する値にマーカーとして使っている画像ファイルのパスが格納されるようです。そのため、マーカーをまとめて削除する場合、Map クラスの eachLayer() メソッドを使って map インスタンスに存在するレイヤーを順番に調べて、プロパティに _icon キーが存在していたら削除するという方法が使えるようです。\n具体的なコードは次のとおりです。マーカーを全削除するボタンをクリックするという前提です。\n1// マップの初期化コード（必要最低限の箇所だけ表示） 2// 緯度経度の場所は日本緯度経度原点 3let map = L.map(\u0026#39;map\u0026#39;, 4 { 5 renderer: L.canvas(), 6 preferCanvas: true 7 }).setView([35.6580992222, 139.7413574722], 15); 8 9// マーカー全削除のコード 10document.getElementById(\u0026#39;removeMarkerBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 11 map.eachLayer((layer) =\u0026gt; { 12 if (layer._icon != undefined) { 13 map.removeLayer(layer); 14 } 15 }) 16 e.preventDefault(); 17}) レイヤーを削除せずにマーカーを削除する方法 ちなみに、レイヤーを削除せずにマーカーを削除することも可能です。\n地図に追加したマーカーは、後述する線と異なりDOMツリーに追加されますので、マーカーに特徴的なセレクタと querySelectorAll() メソッドでまとめて取得できます。私が調べた限りでは、セレクタに '.leaflet-marker-pane\u0026gt;img' を指定すればOKのようですので、次のコードでマーカーをまとめて削除できます。\n1let markers = document.querySelectorAll(\u0026#39;.leaflet-marker-pane\u0026gt;img\u0026#39;); 2markers.forEach((marker) =\u0026gt; marker.remove()); 地図に追加した線の削除 次は地図に追加した線を削除する方法ですが、DOMツリーで線に該当するDOMを見つけられませんでしたので、線のレイヤーを削除する方法で対処しました。\n方法は前述のマーカーの一括削除と同じで、map インスタンスに存在するレイヤーを順番に調べて、線のレイヤーが見つかれば削除するという方法です。\n私が調べた限りでは、線のレイヤーのプロパティには options.color というキーが追加され、このキーの値に線の色が格納されるようですので、このキーを使って次のコードで処理するようにしました。\n1// 線の削除コード 2document.getElementById(\u0026#39;removeMarkerBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 3 map.eachLayer((layer) =\u0026gt; { 4 if (layer.options.color != undefined) { 5 map.removeLayer(layer); 6 } 7 }) 8 e.preventDefault(); 9}) 地図に追加した円の削除 (2023年11月2日追加)\n地図に追加した円を削除する方法ですが、こちらも線と同様にDOMツリーで該当するDOMを見つけられませんでしたので、線と同様にレイヤーを削除する方法で対処しました。\n私が調べた限りでは、線のレイヤーのプロパティには円の半径を格納する layer._mRadius というキーが追加されますので、このキーを使って次のコードで処理するようにしました。\n1// 円の削除コード 2document.getElementById(\u0026#39;removeMarkerBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 3 map.eachLayer((layer) =\u0026gt; { 4 if (layer._mRadius != undefined) { 5 map.removeLayer(layer); 6 } 7 }) 8 e.preventDefault(); 9}) 追加した図形をクリックして削除する設定 2023年11月2日追加\n地図に追加したアイコンや線について、クリックしたら削除されるという設定です。\n設定方法は、on() メソッドでアイコンや線にクリック時に実行されるイベントリスナーを登録するというものです。addEventListener() メソッドで DOM に処理を追加するのと同じ感覚で設定できます。具体的なコードは次のとおりです。\n1// マーカーを地図に追加するときにクリック時の処理を追加し、その中でそのマーカー自身を削除する処理を追加。 2L.marker([Number(data[0]), Number(data[1])], { icon: iconColor }).addTo(map).on(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 3 e.target.remove() 4}); 5// 線を地図に追加するときにクリック時の処理を追加し、その中でその線自身を削除する処理を追加。 6L.polyline(convertedData, { color: lineColor.value}).addTo(map).on(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 7 e.target.remove() 8}); 9// 円を地図に追加するときにクリック時の処理を追加し、その中でその円自身を削除する処理を追加。 10L.circle([Number(latitude), Number(longitude)], circleOption).addTo(map).on(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 11 e.target.remove(); 12}) 13// 地図に追加した円をいったん変数に格納し、その変数にクリック時の処理を追加する方法もOK。 14let circle = L.circle([Number(latitude), Number(longitude)], circleOption).addTo(map); 15circle.on(\u0026#39;click\u0026#39;, (e) =\u0026gt; { 16 e.target.remove(); 17}) 注意点は、マーカーや線はイベントバブリングがデフォルトでオフになっていますが、円はデフォルトでオンになっています。そのため、イベントがバブリングすると困る場合、円を追加するときに bubblingMouseEvents オプションを false にします。\n","link":"http://localhost:1313/post/2023-10-07/","section":"post","tags":["備忘録","プログラミング"],"title":"leaflet 覚書"},{"body":"","link":"http://localhost:1313/archives/2023/05/","section":"archives","tags":null,"title":"2023/05"},{"body":"前置き 先月、Google Colab で Whisper を動かして音声をテキストに変換してブログを書いてみるという記事を投稿しました。\nこの方法は Google Colab で実行するので、高性能の GPU が使えて環境構築の手間がかからないというメリットがある一方で、毎回ライブラリをインストールする必要があって初期セットアップに時間がかかるというデメリットがありました。そこで、ローカル環境で Whisper を動かせば初期セットアップの時間を節約できると思い、ローカル環境で Whisper を動かせるようにしました。\nWhisper を動かせるようにするまで色々と作業が必要だったため、備忘録として作業内容を記録します。\n環境 私のPC環境は次のとおりです。\nOS Windows 11 Pro 22H2 Python 3.10.6 グラフィックボード NVIDIA GeForce RTX 3060（メモリ12GB） NVIDIAドライバ バージョン535.50（執筆時点の最新版） 必要となるライブラリなど Whisper の Github リポジトリの README.md では、「Whisper は Python 3.9.9 と PyTorch 1.10.1 を使ってトレーニングとテストをしているが、ソースコードは Python 3.8-3.11 と最近の PyTorch にも対応していると期待される」とあります。一方、PyTorch の最新版がサポートする Python のバージョンは 3.8-3.11 で、CUDA のバージョンは 11.7 か 11.8 です。\nそのため、Python については元からインストールしている 3.10.6 を使い、PyTorch はバージョンが新しい方が使いまわしができるだろうと考えて最新版を使うことにしました。CUDA は参考にしたブログ記事では 11.7 を使っていましたので、それに倣うことにしました。\n以上を踏まえてインストールしたライブラリは次のとおりです。\nBuild Tools for Visual Studio2022 CUDA Toolkit 11.7 cuDNN (for CUDA 11.x) PyTorch (Stable (2.0.1)) それぞれのライブラリのインストール方法は次のとおりです。\nBuild Tools for Visual Studio2022のインストール Microsoft の配布サイトからインストーラーをダウンロードして実行します。\nインストーラーを実行すると何をインストールするか聞かれますので、「C++によるデスクトップ開発」を選択し、右側に表示されるメニューから「v143ビルドツール用C++/CLIサポート(最新)」を選択してインストールします。私の環境では、最初のインストールは失敗に終わりましたが、インストール済みの古い C++ の再配布パッケージをアンインストールして再度インストールを実行したら無事にインストールできました。\nインストールするパッケージの選択 CUDA Toolkit 11.7 NVIDIA の公式サイトからインストーラーをダウンロードして実行します。\n実行するとインストールオプションで「高速（推奨）」と「カスタム（詳細）」を選択するよう求められます。\nインストールオプションの選択 基本的には「高速（推奨）」を選べばよいと思うのですが、私の場合 nvidia nsight visual studio edition のインストールが失敗して全体のインストールも失敗しましたので、「カスタム（詳細）」を選択して nvidia nsight visual studio edition をインストール対象から除外してインストールしました。ちなみに、nvidia nsight visual studio edition は、Visual studio で GPU コンピューティングを開発する際にデバッグ等の機能を提供するツールのようです。\nnvidia nsight visual studio edition インストールが終わったら CUDA Toolkit 11.7 へのパスが通っているか確認します。Windows の設定画面を開いて左上の検索ボックスに「環境変数」と入力してから「システム環境変数」を選択し、出てきた画面の下側にある「環境変数」ボタンをクリックして設定画面を開きます。そして、システム環境変数の path に C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.7\\bin と C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.7\\libnvvp が設定されているか確認します。\nここでパスが通っていることを確認したら、追加の確認として、コマンドプロンプトか PowerShell を開いて nvcc -V コマンドを実行します。インストールに成功してパスが通っていれば、次のような結果が表示されます。\n1nvcc: NVIDIA (R) Cuda compiler driver 2Copyright (c) 2005-2022 NVIDIA Corporation 3Built on Tue_May__3_19:00:59_Pacific_Daylight_Time_2022 4Cuda compilation tools, release 11.7, V11.7.64 5Build cuda_11.7.r11.7/compiler.31294372_0 cuDNN cuDNN は「The NVIDIA CUDA® Deep Neural Network library」の略で、GPU を使ったディープニューラルネットワークのためのライブラリです。公式サイトにアクセスしてインストーラーをダウンロードしますが、ダウンロードするには NVIDIA Developer に登録する必要があります。色々聞かれますので必須事項を1つ1つ答えて登録します。登録が完了したらインストーラーをダウンロードしますが、上記の作業で CUDA Toolkit 11.7をインストールしていますので、「CUDA 12.x」ではなく「CUDA 11.x」を選択します。\ncuDNNのダウンロード インストーラー（ZIPファイル）をダウンロードしたら、ダウンロードした ZIP ファイルを解凍するか Explorer で開きます。ZIPファイルには bin include lib フォルダが入っていますので、これらのフォルダを先程 CUDA をインストールしたフォルダ（例えば、C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.7\\）の中にコピーします。\nそれから cuDNN へのパスを通します。こちらは CUDA Toolkit 11.7 とは違い自動的にパスが設定されませんので、先程と同様の手順でシステム環境変数の設定画面を開き、CUDA_PATH と同じ値を CUDNN_PATH として設定します。\nPython の仮想環境を構築 やっと PyTorch をインストールしますが、システム全体にインストールすると今後思わぬところで依存関係のトラブルが起きそうな気がしましたので、Whisper 専用の仮想環境を用意してそこにインストールすることにしました。\n仮想環境は venv を使って D:\\voice2text_with_whisper_fp16 に用意することにしましたので、PowerShell を開いてこのディレクトリに移動した後 python -m venv .venv コマンドを実行して仮想環境を作成し、.venv\\Scripts\\activate.ps1 コマンドを実行して仮想環境に切り替えました。\nPyTorch のインストール 公式サイトで PyTorch のバージョンや OS の種類などを選択することで表示されるインストールコマンド (pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu117) コマンドを実行して PyTorch をインストールします。\nPyTorchのインストールコマンド生成 Whisper のインストール ようやく下準備ができましたので、本命の Whisper をインストールします。公式リポジトリに掲載されている pip install git+https://github.com/openai/whisper.git コマンドを実行してインストールします。\n音声ファイルの変換 これで必要な準備はできたはずですので、以下のコードを適当なファイル名 (voice2text.py) で保存してから、PowerShell を開いて python3 voice2text.py \u0026quot;音声ファイルへのパス\u0026quot; コマンドを実行して音声をテキストに変換します。\nコードはWhisper + GPT-3 で会議音声からの議事録書き出し\u0026amp;サマリ自動生成をやってみる！ - Qiitaを参考にしています。\n1# 変換したテキストの保存場所とファイル名指定のためにインポート 2import datetime 3import os 4import sys 5sys.path.append(os.path.join(os.path.dirname(__file__), \u0026#39;.venv\\lib\\site-packages\u0026#39;)) 6 7# 入力音声の変換に必要なライブラリのインポート 8import librosa 9import soundfile as sf 10import whisper 11 12# 下準備 13voiceFile = sys.argv[1] 14def generate_transcribe(file_path): 15 # Whisper高速化テクニック 16 # https://qiita.com/halhorn/items/d2672eee452ba5eb6241 17 model = whisper.load_model(\u0026#34;large\u0026#34;, device=\u0026#34;cpu\u0026#34;) 18 _ = model.half() 19 _ = model.cuda() 20 21 # exception without following code 22 # reason : model.py -\u0026gt; line 31 -\u0026gt; super().forward(x.float()).type(x.dtype) 23 for m in model.modules(): 24 if isinstance(m, whisper.model.LayerNorm): 25 m.float() 26 result = model.transcribe(file_path) 27 return result 28 29# 音声ファイルのサンプリング 30y, sr = librosa.load(voiceFile) 31y_16k = librosa.resample(y, orig_sr=sr, target_sr=16000) 32n_samples = int(15 * 60 * 16000) 33 34# 音声ファイルを15分ごとに分割する 35segments = [y_16k[i:i+n_samples] for i in range(0, len(y_16k), n_samples)] 36 37# 分割した音声ファイルを保存する 38for i, segment in enumerate(segments): 39 sf.write(f\u0026#34;./splited_voice_file_{i}.wav\u0026#34;, segment, 16000, format=\u0026#34;WAV\u0026#34;) 40 41# 分割した音声ファイルを順番にテキストに変換 42transcript = \u0026#34;\u0026#34; 43for i in range(len(segments)): 44 # print(fc.selected_path) 45 file_path = f\u0026#34;./splited_voice_file_{i}.wav\u0026#34; 46 transcribe = generate_transcribe(file_path) 47 for seg in transcribe[\u0026#39;segments\u0026#39;]: 48 transcript += seg[\u0026#39;text\u0026#39;] + \u0026#34;\\n\u0026#34; 49 50# 変換したテキストをこのスクリプトと同じディレクトリに保存。 51# ファイル名は日付 + 時間 52now = datetime.datetime.now() 53filename = now.strftime(\u0026#39;%Y%m%d_%H%M\u0026#39;) 54f = open(filename + \u0026#39;.txt\u0026#39;, \u0026#39;w\u0026#39;) 55f.write(transcript) 56f.close() ちなみに、音声は Microsoft Store からインストールした Windows ボイスレコーダーで録音しています。\n参考にした記事等 Whisper + GPT-3 で会議音声からの議事録書き出し\u0026amp;サマリ自動生成をやってみる！ - Qiita OpenAIのWhisperをWindows環境で試す(CUDA環境有り) WindowsへのNVIDIA CUDAのGPU環境構築 | 鷹の目週末プログラマー ","link":"http://localhost:1313/post/2023-05-28/","section":"post","tags":["備忘録","プログラミング","機械学習"],"title":"Whisper を Windows ローカルで使うための作業"},{"body":"","link":"http://localhost:1313/tags/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/","section":"tags","tags":null,"title":"機械学習"},{"body":"","link":"http://localhost:1313/archives/2023/04/","section":"archives","tags":null,"title":"2023/04"},{"body":"前置き 私は現在3台の3Dプリンター（Prusa MK3S+、Ender 3 Pro、Voron V0.0）を使っており スライサーには SuperSlicer を使っています。\nSuperSlicer には Prusa MK3S+、Ender 3 Pro、Voron V0.0 のプロファイルとプリンタ毎の印刷速度等を登録しています。また、フィラメント送り出し方式が前者2つはダイレクトドライブなのに対し、Voron はボーデンのため、同じフィラメントでも設定を2種類用意しています。\nSTL ファイルは SuperSlicer でスライスしますが、プリンタ3台をフル稼働して印刷する時は、SuperSlicer のウィンドウ1つでモデル毎・フィラメント毎・プリンタ毎のパラメータ調整を行うのは至難の業となります。そのため、SuperSlicer のウィンドウを3つ立ち上げて各ウィンドウを Prusa MK3S+、Ender 3 Pro、Voron V0.0 に割り当てる形にしていました。\nプリンタ3台をフル稼働している時のイメージ これでモデル毎・フィラメント毎・プリンタ毎のパラメータ調整を問題なく実行できるのですが、ウィンドウを立ち上げると前回終了時の設定が読み込まれるため、例えば、前回終了時に Prusa MK3S+ の設定を表示していて、今回は Voron で印刷しようとした場合、SuperSlicer を立ち上げてから設定を Voron 用に変更する必要があります。ちょっとした手間ですが面倒くさい上、プリンタにセットしているフィラメントと異なるフィラメントの設定を呼び出して印刷しそうになったこともあり、何とかして起動した時点で望み通りのプリンタ設定が表示されるようにできないか調べていました。\nしかし、日本語でも英語でもそれらしい方法が見つからなかったため、Reddit で質問したところ解決に必要な情報を教えてもらえましたので、教えてもらった情報と合わせて具体的な手順を備忘録として残します。\nなお、SuperSlicer のバージョンは 2.5.59.0 です。SuperSlicer のフォーク元である PrusaSlicer のフォーク元である Slic3r の頃から備わっている機能を利用していますので、バージョンが変わっても大丈夫だと思いますが、念のため記載しておきます。\n手順 大まかな手順は次のとおりです。\n現在の印刷設定・フィラメント設定・プリンタ情報をエクスポートする プリンタ毎のショートカットを作成する プリンタ毎のショートカットから起動してエクスポートした設定をインポートする 不要な設定を削除する 現在の設定情報のエクスポート 現在の印刷設定・フィラメント設定・プリンタ情報をエクスポートする方法ですが、「ファイル」→「エクスポート」→「物理プリンター情報を含んだ構成セットのエクスポート」をクリックして設定ファイル（*.ini）をエクスポートします。後でこの設定ファイルをインポートしますので、保存場所を覚えておきます。\n設定ファイルのエクスポート 設定ファイルのエクスポート 設定ファイルをエクスポートしたら SuperSlicer をいったん閉じます。\nプリンタ毎のショートカットの作成 まず、普通のアプリのショートカット作成と同じ方法でショートカットを作成します。もし、SuperSlicer インストール時にデスクトップにショートカットを作成しているのであれば、それを必要数だけコピペして名称を変える方法でも OK です。\nショートカットを作成したら、ショートカットを右クリックして「プロパティ」を開き、リンク先を次のとおり修正します。ちなみに、このショートカットは Prusa MK3S+ 用のショートカットです。\n1- D:\\ダウンロード\\App\\SuperSlicer_2.5.59.0_win64_220811\\superslicer.exe 2+ D:\\ダウンロード\\App\\SuperSlicer_2.5.59.0_win64_220811\\superslicer.exe --datadir D:\\3D_Printer\\PrusaMK3S+_klipper ファイルのプロパティのリンク先 ここで指定した --datadir というオプションは、このショートカットから起動したときの設定ファイルの読み込み＆保存場所を指定するもので、引数として渡した D:\\3D_Printer\\PrusaMK3S+_klipper ディレクトリが、このショートカットから起動したときの設定ファイルの読み込み＆保存場所となります。\nオプション無しで起動するとデフォルトの保存場所にある設定ファイルを読み込みますが、オプションを指定することで特定のディレクトリにある設定ファイルのみ読み込むようになりますので、このディレクトリに必要な情報だけ記述した設定ファイルを保存することで、SuperSlicer 起動時に不要な情報が表示されなくなります。\n設定のインポート 上で作成したショートカットから SuperSlicer を起動しますとプリンタを登録する初期ウィザードが始まりますが、このウィザードはキャンセルします。\nこれだと必要な情報が登録されていない状態となりますので、「ファイル」→「インポート」→「構成バンドルのインポート」の順番でクリックして、最初にエクスポートした設定ファイルをインポートします。\n設定ファイルのインポート 設定ファイルのインポート これで印刷設定・フィラメント設定・プリンタ情報がインポートされますが、このままでは従来と同じ状態になりますので、不要なプリンタ情報やフィラメント情報等を削除します。\n不要な設定ファイルの削除 以上の作業により、プリンタ毎に特化した設定内容だけが表示される SuperSlicer を作成することができました。こうしておけば、プリンタに適合しない設定を間違って選ぶこともなくなると思います。\nプリンタ毎のショートカットを用意した様子 参考情報 How to start SuperSlicer by specifying presets, etc. : 3Dprinting Slic3r Manual – Configuration Organization ","link":"http://localhost:1313/post/2023-04-30/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"特定のプリンタの設定だけを有効化した SuperSlicer を起動する方法"},{"body":"","link":"http://localhost:1313/tags/chatgpt/","section":"tags","tags":null,"title":"ChatGPT"},{"body":"前置き 前々から ChatGPT を試してみようと思ってちょくちょく調べていたのですが、2つの実例で実感！GPT-4が導く技術ブログ文化の崩壊(プロンプト付き) という記事を見て、それならブログの執筆に使ってみてどれだけ使えるか試してみることにしました。\nまた、ChatGPT に加えて音声認識の Introducing Whisper も使うことで、先の記事で引用されている「喋った内容を文字起こしして ChatGPT に整形してもらって細かいところを修正してアップする」という一連の作業を自分でも実現できるか試してみたいと思いました。\nそこで、今回の記事は ChatGPT と Whisper を使って書いた記事となります。記事の内容は雑談レベルのものですが、記事の内容よりどの程度のことができるかの探索の方が重要かと思いますので、その点はご容赦ください。\nChatGPT が作った記事 まずは ChatGPT が作成した文章を紹介します。なお、タイトルは私が指定しています。また、商品リンクは私が追記しています（ChatGPTに）\nタイトル：雑感（QOLが向上した家電3つ）\nこんにちは！今日は私が購入して、生活の質(QOL)が向上した家電3つを紹介したいと思います。たくさんの商品を試してきた中で、特に効果があったと感じる3つの家電は、コードレス掃除機、超音波洗浄機、そしてシャープのホットクックです。それぞれの良い点を順番にご紹介します。\n1つ目のコードレス掃除機は、コンセントに繋げることなく、すぐに掃除が始められる点が便利です。吸引力はコード付き掃除機に比べて落ちるものの、手軽さが魅力です。PCとスマートフォンの関係に例えると、コードレス掃除機はすぐに取り出して使えるスマートフォンのような存在です。私もコードレス掃除機を導入してから、ほぼ毎日掃除をするようになりました。私が選んだのはアイリスオーヤマの掃除機で、次に買うならマキタのものを検討しています。\n充電式スティッククリーナー｜電動工具18Vシリーズ｜電動工具・ポータブル電源｜工具・DIY・資材・作業衣料｜商品情報｜アイリスオーヤマ\n2つ目の超音波洗浄機は、特にメガネの清掃に役立っています。これまで手洗いで面倒だったメガネの洗浄が、水と洗剤を入れてスイッチを押すだけで簡単にできるようになりました。私が購入したのはアズワンの洗浄機で、Amazonの評判も良かったため選びました。\nAmazon | アズワン 超音波洗浄器 水槽着脱タイプ タイマー機能 コンパクト MCC-40S メガネ 時計 入れ歯 貴金属 アクセサリー 水槽分離式 | 超音波洗浄機 | 産業・研究開発用品 通販\n3つ目のホットクックは、YouTubeなどで紹介されている便利な家電です。材料と調味料を鍋に入れてスイッチを押すだけで料理ができるため、夕食の準備が格段に楽になりました。また、煮込み料理も機械に任せられるため、これまで作らなかった料理にも挑戦できるようになりました。\nKN-HW16E | ヘルシオ ホットクック：シャープ\n【シャープ公式通販】 シャープ　ホットクック専用フッ素コート内鍋（1.6L用）｜TJ-KN1FB ｜OCORO STORE（ココロストア）\nいかがでしたか？私が感じたQOLの向上をもたらす家電3つをご紹介しました。これらの家電を試してみることで、あなたの生活もさらに快適になるかもしれません。それでは今日はこの辺りで失礼します。\n上記の結果に至るまでの過程 上記の文章は、次の作業を経て作成しています。\n記事にする内容を PC に録音 録音した内容を Whisper で文字起こし Whisper で文字起こしした文章を修正 誤字脱字を修正 冗長な言い回しや重複を修正 修正した文章を ChatGPT に渡してブログ記事の体裁に仕上げてもらう それでは、まずは Whisper の文字起こし直後の文章を掲載します。\n[00:00.000 --\u0026gt; 00:08.340] 今日は私が買って 旧オイルが好調した家電を紹介したいと思います\n[00:08.340 --\u0026gt; 00:12.840] 家電に限らずいろいろ物は買っているわけ なんですが\n[00:12.840 --\u0026gt; 00:17.720] その中でも特に効果があった物は 3つあるかなと思っております\n[00:17.720 --\u0026gt; 00:26.340] 1つ目はコードレス掃除機 2つ目は超音波洗浄機\n[00:27.100 --\u0026gt; 00:30.520] 3つ目はシャープが出している ホットクックです\n[00:30.520 --\u0026gt; 00:34.700] 何がいいかというところを順番に 説明しますと\n[00:34.700 --\u0026gt; 00:39.060] まず1つ目のコードレス掃除機 についてですが\n[00:39.060 --\u0026gt; 00:43.220] これの便利なところは 1コンセントにつながらなくても\n[00:43.220 --\u0026gt; 00:46.220] スイッチ一つですぐに掃除が始められる というところです\n[00:46.220 --\u0026gt; 00:53.220] コードの付いた掃除機に比べれば 吸引力は当然落ちるわけなんですが\n[00:54.180 --\u0026gt; 01:01.180] ただ使おうと思ったらすぐに使える その点が非常に便利です\n[01:03.820 --\u0026gt; 01:07.700] 少し見方を変えますとパソコンと スマートフォンみたいなもんでして\n[01:07.700 --\u0026gt; 01:10.740] パソコンは当然スマートフォン よりも処理能力が高いわけなんですが\n[01:10.740 --\u0026gt; 01:15.040] いちいち電源を入れなければいけない\n[01:15.040 --\u0026gt; 01:17.840] 一方スマートフォンはパソコンより は処理能力は落ちますが\n[01:18.180 --\u0026gt; 01:23.120] 手に取って画面をオンにすれば すぐに使うことができる\n[01:23.120 --\u0026gt; 01:27.180] なのでパソコンよりもスマートフォンを 入れるほうが時間が長かったり\n[01:27.180 --\u0026gt; 01:30.040] というのもそういったところが あるかなと思います\n[01:30.040 --\u0026gt; 01:32.520] それと同じような関係で\n[01:32.520 --\u0026gt; 01:37.520] コードレス掃除機を取り出せば すぐに使えます\n[01:37.520 --\u0026gt; 01:39.600] コード付きの掃除機ですと\n[01:39.600 --\u0026gt; 01:42.780] まず物入れから引っ張り出して\n[01:42.780 --\u0026gt; 01:46.600] コードを引っぱり出してそれから コンセントに挿してそれから掃除が\n[01:47.220 --\u0026gt; 01:51.560] 始まると 掃除を始めるまでにいく つかのステップがあるものですので\n[01:51.560 --\u0026gt; 01:54.820] どうしてもちょっと怠空になって しまうと\n[01:54.820 --\u0026gt; 01:58.700] なのでコードレス掃除機を買う前 というのは大体1週間に1回程度\n[01:58.700 --\u0026gt; 02:01.820] のペースでしか掃除はしておりませんでした\n[02:01.820 --\u0026gt; 02:06.820] でもコードレス掃除機が来てから は大体毎日のように掃除ができる\n[02:06.820 --\u0026gt; 02:12.420] ようになってますので実際毎日 掃除をしております\n[02:12.420 --\u0026gt; 02:15.940] マッテリーも2個買っています ので1つがダメになってももう1個\n[02:16.140 --\u0026gt; 02:21.260] 2個取り替えてすぐに掃除を再開 できるようにしております\n[02:21.260 --\u0026gt; 02:25.540] どこの掃除機を買ったかといいます とアイリス大山の掃除機を買っております\n[02:25.540 --\u0026gt; 02:31.540] アイリス大山にした理由ですが 安かったからというのが理由です\n[02:31.540 --\u0026gt; 02:36.820] 私が買ったやつはマキタよりも 数千円は安かったのでアイリス大山を買っております\n[02:36.820 --\u0026gt; 02:43.940] ただマキタのコードレス掃除機を 使ってから\n[02:44.120 --\u0026gt; 02:47.940] 次に買うならマキタの掃除機を買うかなとは思っております\n[02:47.940 --\u0026gt; 02:54.820] アイリス大山の方が良いところはないかなと。\n[02:54.820 --\u0026gt; 03:01.900] 2つ目の家電の超音波洗浄機ですが これはパラメガネの清掃に使っています\n[03:01.900 --\u0026gt; 03:08.340] それまではメガネの上に鋳性洗剤 ただして指でゴシゴシという感じで\n[03:08.380 --\u0026gt; 03:14.740] その都度その都度蛇口で洗っていましたが のこれ結構面倒ですね\n[03:14.740 --\u0026gt; 03:19.540] なかなかメガネも洗う回っ引度が 減っていたというところでしたが\n[03:19.540 --\u0026gt; 03:26.560] 超音波洗浄機を買ってからは水を入れて洗剤を入れて 速くスイッチを押せば自動的にキレイにしてくれます\n[03:26.560 --\u0026gt; 03:35.060] 日常に5分くらいですがその間に歯を磨いて時間を潰して\n[03:35.060 --\u0026gt; 03:42.480] 歯磨きが終わったらメガネもキレイになっていると そんな感じで使っております\n[03:42.480 --\u0026gt; 03:48.280] 実際指でやるときよりも細かいところまでキレイ になりますのでメガネが非常に使いや\n[03:48.280 --\u0026gt; 03:57.280] メガネが非常に綺麗になっております これもちょいちょいとすぐ使うことができますので便利に使っております\n[03:57.300 --\u0026gt; 04:02.340] 3番目最後の家電は 便利になった家電はホットクックですが\n[04:02.340 --\u0026gt; 04:09.900] これはもう youtube などで家電紹介などでも結構取り上げられている便利家電なんですが\n[04:09.900 --\u0026gt; 04:16.440] それを見て私も買ったわけなんですが非常に便利なものです なにしろ材料を用意して\n[04:16.440 --\u0026gt; 04:20.540] 炒り込んで調味料も放り込んでスイッチ押せばもう 出来上がる\n[04:20.700 --\u0026gt; 04:24.900] あとは完成を待つだけ と このあたりは非常に楽です\n[04:24.900 --\u0026gt; 04:31.020] 肉じゃがとかカレーとか通しても普通に作ろうとすると火のそばにずっと立っていなきゃいけないわけで\n[04:31.020 --\u0026gt; 04:35.680] 20分30分とどうしても時間は潰れてしまうんですが\n[04:35.680 --\u0026gt; 04:40.280] ホットクックであれば材料切る手間はさすがにかかるとしても\n[04:40.280 --\u0026gt; 04:44.960] 1回鍋に入れてスイッチ押してしまえばあとはほったらかしでokと\n[04:44.960 --\u0026gt; 04:46.860] その間色んなことができると\n[04:46.860 --\u0026gt; 04:49.300] そういった点で非常に便利になっておりますし\n[04:49.380 --\u0026gt; 04:57.840] 煮込み料理のような時間がかかるものでも機械におまかせで作ることができますので非常に楽意をしております\n[04:59.840 --\u0026gt; 05:03.840] ホットクックがきてから今まで作らなかった料理なんかも作るようになってまして\n[05:03.840 --\u0026gt; 05:10.080] そういったところでも非常に便利な家電でqolのアップにつながっていると思っております\n[05:10.620 --\u0026gt; 05:24.280] 以上3つがqolが向上した家電3つというところです\n[05:24.280 --\u0026gt; 05:27.820] では今日はこの辺りにしようと思います\nこの文章から時間の部分を削除した文章を ChatGPT に渡すとイマイチな文章になりましたので、次のとおり修正しました。修正に当たっては、自分で徹底的に修正したら意味が無いので、先述のとおり誤字脱字の修正と冗長な言い回しの修正にとどめています。文章を上からざっと読んで目についたところをパパっと直したという感じです。\n今日は私が買って QOLが好調した家電を紹介したいと思います\n家電に限らずいろいろ物は買っているんですが、その中でも特に効果があった物は3つあるかなと思っております\n1つ目はコードレス掃除機 2つ目は超音波洗浄機 3つ目はシャープが出している ホットクックで、何がいいかというところを順番に説明します。\nまず1つ目のコードレス掃除機 についてですが\nこれの便利なところは コンセントに繋げることなくスイッチ一つですぐに掃除が始められる というところです\nコードの付いた掃除機に比べれば 吸引力は当然落ちるわけなんですが、使おうと思ったらすぐに使える その点が非常に便利です\nこの違いを例えていうなら、PCとスマートフォンみたいなものかと思います。PCはスマートフォンよりも処理能力が高いですが、いちいち電源を入れなければいけないのに対し、スマートフォンはPCより処理能力は落ちますが手に取って画面をオンにすればすぐに使えます。そのため、PCよりもスマートフォンの方が使うが長くなって、なんでもスマホで済ませるようになってしまうと。\nそれと同じような関係で、吸引力は高いが、物入れから取り出してコードを引っ張り出してコンセントに繋がないと使えないコード付き掃除機に対し、吸引力は弱いがすぐに取り出して使えるコードレス掃除機は掃除に取り掛かるまでのちょっとした手間を省略してくれます。このちょっとした手間の削除が結構な違いを生み出していて、コードレス掃除機を買う前は大体1週間に1回程度のペースでしか掃除はしておりませんでしたが、コードレス掃除機が来てからは大体毎日のように掃除しています。\nまた、バッテリーは2個買っていますので、1つが電池切れになったらもう1個に交換してすぐに掃除が再開できるようにしております\nなお、どこの掃除機を買ったかといいます とアイリスオーヤマの掃除機を買っております。アイリスオーヤマにした理由は、マキタより 数千円は安かったためです。ただ職場でマキタのコードレス掃除機を使ってからは、次に買うならマキタの掃除機を買おうと思っております\n2つ目の家電の超音波洗浄機ですが これはもっぱらメガネの清掃に使っています\nそれまではメガネの上に中性洗剤を垂らして指で洗っていましたが これが結構面倒で、メガネはそんなに頻繁に洗っていませんでした。\n超音波洗浄機を買ってからは、水を入れて洗剤を入れてスイッチを押せば自動的にキレイにしてくれますので、その間に歯磨きなんかができるようになりました。\n実際、指でやるときよりも細かいところまでキレイになりますし、掃除も簡単になりましたので、メガネを洗う頻度が増えています。\nどこの洗浄機を買ったかですが、アズワンの洗浄機を買っています。アズワンは研究用機器材などを販売している会社で、Amazonの評判もよかったので、これにしました。\n3番目最後の家電はホットクックですが、これは youtube などで家電紹介などでも結構取り上げられている便利家電ですね。\nそれを見て私も買ったのですが、非常に便利なものです。\nなにしろ材料と調味料を鍋に入れてスイッチ押せば完成を待つだけなので、夕食の準備が楽になっています。\n肉じゃがやカレーを作ろうとすると、どうしても火のそばにいなければならないので20分30分とどうしても時間は潰れてしまうんですが\nホットクックであれば材料を切って用意すれば後はスイッチ押して待つだけなので、その間に色々と他のことができます。\nそういった点で非常に便利になっておりますし、煮込み料理のような時間がかかるものでも機械におまかせで作ることができますので非常に楽をしております。ホットクックがきてから今まで作らなかった料理なんかも作るようになってましてそういったところでも非常に便利な家電でQOLのアップにつながっていると思っております\n以上3つがQOLが向上した家電3つというところです\nでは今日はこの辺りにしようと思います\nここまで修正した文章を ChatGPT に次の指示とともに渡したところ、最初に紹介した文章が返ってきました。\n1あなたは出版社の編集者です。以下の文字起こし文章をタイトル「雑感（QOLが向上した家電3つ）」のブログ記事としてて書き直してください。 2-- 3{上記の文章} 感想 最初はどこまでできるのか疑心暗鬼でしたが、正直に申し上げると「頭の中のアイデアをざっと説明できる程度に整理できれば充分使えるかも」というところまで印象がアップしました。\nWhisper と ChatGPT の処理時間以外に要した時間ですが、まず喋った時間は5分程度で、この文字起こしの修正も5分弱です。そして、ChatGPT が作成した文章を基にこの記事全体の執筆が30分程度ですので、かなり短時間で記事を書くことができました。口頭で話す時点で上手に情報を整理できていれば、長い記事であってもそんなに時間をかけることなく執筆できるのではないかと思います。もちろん、図を用意したりする必要があればそこで時間を要することになりますが、ゼロから執筆するよりは結構楽ができそうな気がします。\nこの辺りはもう少し使い込んでみようと思います。\nそれでは本日はここまでとします。\n参考にした記事\nOpenAI Whisperに音声データを全文書き起こしさせる【Google Colaboratory】 WhisperとGoogle Colaboratoryで音声の文字起こしをやってみた DeepLearningについて、最近作ったもの、書いたもの、勉強したこと ","link":"http://localhost:1313/post/2023-04-11/","section":"post","tags":["備忘録","ChatGPT","Whisper"],"title":"ChatGPT と Whisper を使って記事を書いてみました"},{"body":"","link":"http://localhost:1313/tags/whisper/","section":"tags","tags":null,"title":"Whisper"},{"body":"前置き Ender 3 Pro で Voron Trident の印刷パーツを印刷していたら突然印刷ができなくなり、原因を調べたらモーターがガタガタと振動して正常に回転していませんでした。\nそこでモーターを買い替えて交換したのですが、新しいモーターを動かすまでにあれこれ調べる必要に迫られたため、その時調べたことなどを備忘録として残します。\n試行錯誤の経緯 ステッピングモーターの結線 今回の購入したステッピングモーターは Amazon で購入したものですが、商品ページに結線情報は掲載されていませんでした。ネットで検索したら該当しそうな情報が見つかりましたが、結論から言うとその情報は間違っていました。\nそこでステッピングモーターについて調べ直したのですが、その過程で、ステッピングモーターの4本の配線は、以下の図のとおり2本ずつのペアで「A相、B相」を構成していることに気付きました。なお、以下の図は、オリエンタルモーター社の「テクニカルマニュアル ステッピングモーター編」の50ページに掲載されていたものです。\nステッピングモーターの内部配線 そして、モーター内部で図のとおり繋がっているのであれば、テスターを順番に当てていけば内部で繋がっているピン同士を確認できることに気付きました。\n実施にテスターを当てて調べたところ、内部で繋がっているピンの組み合わせを以下の写真のとおり特定することができました。\nモーターの結線状況 SKR 3 ez の結線 SKR 3 ez のハードウェア情報は SKR-3/Hardware (SKR 3 EZ) at master · bigtreetech/SKR-3 で公開されていますが、最初、ピンの配置図に記載された「2B 2A 1A 1B」の組み合わせ方が分かりませんでした。\nSKR 3 ez のピン配置図 「2B 1B」がB相に、「2A 1A」がA相になるのかと思いましたが違っており、「2B 2A」がA相に、「1A 1B」がB相になるという組み合わせでもありませんでした。組み合わせを間違えた場合、ガタガタと振動するだけならまだしも、場合によっては ShortToGND_A! というエラーが発生して強制シャットダウンされることもありました。\nそのため、あらためて SKR 3 ez の回路図を確認していると、ピンの配置図の「2B 2A 1A 1B」はモータードライバーの出力ピンの名称と一致していないことに気付きました。\nSKR 3 ez の回路図 これで正しい配線方法を特定することができるようになりましたので、以下の図のとおり配線して動かせるようになりました。なお、中継基板を挟んだ結線の線の色は、実際のケーブルの色に合わせています。\n最終的な配線方法 ちなみに、上の図ではモータードライバーの「B2 B2」にモーターのA相を、「A2 A1」にモーターのB相を割り当てていますが、反対にしても動くと思います。私の場合、中継基板を挟んで同じ線同士を接続しておけば、何らかのトラブル対応でコネクタからケーブルを取り外した時に戻しやすくなると考えてこのように配線しています。\nKlipper の設定 こちらは簡単で、SKR 3 ez の回路図に記載された XYZ 軸とエクストルーダーの DIR STEP EN UART のピンの指定に合わせて printer.cfg を指定するだけです。\nSKR 3 ez の回路図 1[extruder] 2step_pin: !PD15 3dir_pin: !PD14 4enable_pin: !PC7 5 6[tmc2130 extruder] 7cs_pin: PC6 8spi_software_miso_pin: PE15 9spi_software_mosi_pin: PE13 10spi_software_sclk_pin: PE14 11run_current: 0.7 ","link":"http://localhost:1313/post/2023-04-08/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"3Dプリンタのステッピングモーターの配線について"},{"body":"","link":"http://localhost:1313/archives/2023/03/","section":"archives","tags":null,"title":"2023/03"},{"body":"前置き 職場内研修の資料を Re:VIEW - Digital Publishing System for Books and eBooks を使って作成していますが、ページが増えて出力した PDF の容量が職場のメールの容量制限に引っかかるようになりました。そこで PDF の切り出しツールと圧縮ツールを探したら以下のツールが見つかりましたので、備忘録を兼ねてツールの紹介と簡単な使い方をまとめます。\n環境 OS Windows11 Pro 22H2 WSL 1.1.3.0 OS on WSL Ubuntu-20.04 使用するツール PDF の切り出しは pdftk-java / pdftk-java · GitLab を使用し、圧縮は Ghostscript を使用しています。それぞれのツールは次のコマンドでインストールしています。\n1sudo apt-get --yes install pdftk 2sudo apt install ghostscript 切り出し方法 次のコマンドで PDF ファイルを切り出します。このコマンドは foo-bar.pdf の1ページから12ページを切り出して foo.pdf ファイルとして保存しています。\n1pdftk foo-bar.pdf cat 1-12 output foo.pdf ここで指定するページ数は、ファイルの1ページ目からの通し番号を指定する必要があります。以下のスクリーンショットにあるページを切り出したい場合、`140` ではなく `148` を指定する必要があります。 PDFファイルのページ数の見本 圧縮方法 次のコマンドを実行して PDF ファイルを圧縮します。このコマンドは input.pdf ファイルを圧縮して output.pdf として出力します。-dPDFSETTINGS=/printer の printer は 300dpi で出力するというオプションで、これを screen にすると 72dpi になります。\n1gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/printer -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf ちなみに、-dPDFSETTINGS=/printer と -dPDFSETTINGS=/screen のオプションの違いによるファイルサイズの差は次のとおりです。\n元ファイル 10.79 MB -dPDFSETTINGS=/ptinter 4.46 MB -dPDFSETTINGS=/screen 1.36 MB 参考にしたサイト Split a PDF in two PDFtk - The PDF Toolkit Reduce PDF File Size in Linux | DigitalOcean pdftk の基本的な使い方 - Qiita ","link":"http://localhost:1313/post/2023-03-16/","section":"post","tags":["備忘録"],"title":"PDFファイルの切り出しと圧縮方法"},{"body":"前置き 先日、OpenSCAD で作成された3Dモデルを一部改変して3Dプリンタで出力したいことがあり、そのとき OpenSCAD で作成されたデータを .step ファイルに変換して Fusion360 で編集する方法を見つけたのですが、日本語で変換方法を説明しているウェブページが見つからなかったため、備忘録を兼ねて手順をまとめます。\n環境 OS Windows11 Pro 22H2 Fusion360 2.0.15509 x86_64 OpenSCAD version 2021.01 FreeCAD version 0.18 大まかな手順 変換したい OpenSCAD データを OpenSCAD で開いて .csg ファイルとしてエクスポートする 1.でエクスポートした .csg ファイルを FreeCAD で開いて .step ファイルとしてエクスポートする 2.でエクスポートした .step ファイルを Fusion360 で開く 具体的な手順 OpenSCAD での作業 まず、対象となる OpenSCAD データを OpenSCAD で開いてレンダリングします。\nレンダリングしたら File \u0026gt; Export \u0026gt; Export as CSG... の順番で選択して対象データを .csg ファイルとしてエクスポートします。\nFreeCAD での作業 まず、OpenSCAD でエクスポートした .csg ファイルを FreeCAD で開きます。\n次に、表示 \u0026gt; ワークベンチ \u0026gt; OpenSCAD の順番で選択してワークベンチを OpenSCAD に変更します。ワークベンチを変更しなくてもエクスポートできますが、エクスポートしたデータを開いたら元の形と全く違うデータになったりします。\nそれから、ctrl-a でデータを全選択し、ファイル \u0026gt; エクスポート の順番で選択してファイル保存ダイアログが開いたら、ファイルの種類を STEP with colors (*.step *.stp) に変更して好きな名前でファイルをエクスポートします\nFusion360 での作業 ファイルを開く \u0026gt; マイコンピュータから開く... の順番で選択してダイアログ画面を表示したら、FreeCAD でエクスポートした .step ファイルを選択して開きます。\n以上の作業で OpenSCAD で作成されたデータを Fusion360 で編集できるようになります。\n参考にしたサイト How to import OpenSCAD file into Fusion360 as a solid body - Autodesk Community OpenSCAD User Manual/STL Export - Wikibooks, open books for an open world\n","link":"http://localhost:1313/post/2023-03-15/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"OpenSCAD で作成されたデータを Fusion360 で編集する方法"},{"body":"前置き 天下一キーボードわいわい会 Vol.4 - connpass にキーボードを出展するためにケースを新規作成しましたが、それに合わせて、以前から実現したかった USB Type-C 化を実現するため、以前購入して上手く使えなかった sekigon-gonnoc/pico-micro: A Pro Micro compatible board with RP2040 and mid-mount USB-C receptacle を使いました。RP2040 で QMK Firmware を動かすのは初めてで、使えるようになるまで多少の試行錯誤がありましたので、備忘録として必要な作業をまとめました。\nなお、RP2040 を使う前は Pro Micro を使っており、その時の設定ファイルは qmk_firmware/keyboards/yamanami at yamanami_keyboard · s-show/qmk_firmware · GitHub のとおりで、RP2040 を使う場合の設定ファイルは qmk_firmware/keyboards/yamanami_rp2040 at yamanami_keyboard · s-show/qmk_firmware · GitHub のとおりです。\nボードと MCU の変更 まず、マイコンボードを Pro Micro から PICO Micro に切り替えるため、MCU とブートローダーの設定を次のとおり変更しました。\n1- MCU = atmega32u4 2+ MCU = RP2040 3- BOOTLOADER = caterina 4+ BOOTLOADER = rp2040 ピン指定の変更 PICO Micro は Pro Micro との間でフットプリントとピン配置に互換性がありますが、RP2040 を使う時はピンの指定を GPIO の番号で指定する必要があるため、以下の対応表を作成してピンの指定を修正しました。\nPro Micro と PICO Micro のピンの対応表 Pro Micro PICO Micro Pro Micro PICO Micro D3 GP0 B5 GP9 D2 GP1 F4 GP29 D1 GP2 F5 GP28 D0 GP3 F6 GP27 D4 GP4 F7 GP26 C6 GP5 B1 GP22 D7 GP6 B3 GP20 E6 GP7 B2 GP23 B4 GP8 B6 GP21 1- #define MATRIX_ROW_PINS { F4, C6, D7, E6 } 2+ #define MATRIX_ROW_PINS { GP29, GP5, GP6, GP7 } 3- #define MATRIX_COL_PINS { F5, F6, F7, B1, B3, B6 } 4+ #define MATRIX_COL_PINS { GP28, GP27, GP26, GP22, GP20, GP21 } 5- #define MATRIX_ROW_PINS_RIGHT { F7, B1, B3, B2 } 6+ #define MATRIX_ROW_PINS_RIGHT { GP26, GP22, GP20, GP23 } 7- #define MATRIX_COL_PINS_RIGHT { D4, C6, D7, E6, B4, B5 } 8+ #define MATRIX_COL_PINS_RIGHT { GP4, GP5, GP6, GP7, GP8, GP9 } PICO Micro のピン配置 左右間のシリアル通信の設定 Pro Micro を使うときは rules.mk に SPLIT_KEYBOARD = yes を指定して config.h に #define USE_SERIAL と #define SOFT_SERIAL_PIN D2 を追加すれば左右間のシリアル通信を設定できましたが、RP2040 では SOFT_SERRIAL_PIN が定義されていないため、次の順番で設定を修正しました。\nまず、公式リファレンスで「RP2040 を使う時は SOFT_SERIAL_PIN の代わりに SERIAL_USART_TX_PIN を使うこと」と指定されており、私の設計では Pro Micro の D2 ピンでシリアル通信していましたので、config.h の SOFT_SERIAL_PIN D2 を #define SERIAL_USART_TX_PIN GP1 に修正しました。\n1- #define SOFT_SERIAL_PIN D2 2+ #define SERIAL_USART_TX_PIN GP1 私のキーボードの回路図 それから、私のキーボードではシリアル通信に使える線が一本だけで全二重通信によるシリアル通信はできないため、半二重通信でシリアル通信するために #define USE_SERIAL を #define SERIAL_USART_HALF_DUPLEX に変更しました。\n1- #define USE_SERIAL 2+ #define SERIAL_USART_HALF_DUPLEX そして、rules.mk に SERIAL_DRIVER = vendor を追加すれば左右間のシリアル通信の設定は完了です。\n1SPLIT_KEYBOARD = yes 2+ SERIAL_DRIVER = vendor その他の設定 Pro Micro を使っているときはキーボードのリセットボタンを押せば Pro Micro がブートローダーモードになってファームウェアを更新できましたので、同じ機能を追加するため config.h に次の設定を追加しました。\n1+ #define RP2040_BOOTLOADER_DOUBLE_TAP_RESET 2+ #define RP2040_BOOTLOADER_DOUBLE_TAP_RESET_TIMEOUT 500U これでキーボードのリセットボタンを2連打すれば PICO Micro がブートローダーモードになって uf2 ファイルを書き込めるようになりますので、ファームウェア更新の手間を減らすため設定を追加した。\n参考にしたウェブページ ‘serial’ Driver\nRaspberry Pi RP2040\nsekigon-gonnoc/pico-micro: A Pro Micro compatible board with RP2040 and mid-mount USB-C receptacle\nLunakey PicoでQMK Firmwareを動かしてみました\n","link":"http://localhost:1313/post/2023-03-06/","section":"post","tags":["自作キーボード"],"title":"RP2040 で QMK Firmware を使うメモ"},{"body":"","link":"http://localhost:1313/archives/2023/02/","section":"archives","tags":null,"title":"2023/02"},{"body":" 目次 長い前置き Raspberry pi Pico を使った温度測定 BOM 手順 XIAO RP2040 を使った Input Shaper の測定 BOM 手順 参考情報 長い前置き Prusa MK3S+ で印刷中にベッドの温度が急激に低下し、場合によっては氷点下まで下がってしまいプリンタが止まってしまうという症状が年末から発生していました。\nDiscord の Klipper_jp でのアドバイスを基にベッドを手でグイグイ動かすと温度が急低下する瞬間があったため、サーミスタの断線が原因だと判断してサーミスタを交換しました。ところが、今度はノズルとベッドが設定温度に到達してホーミング＆メッシュベッドレベリングが始まると、ベッドのヒーターの出力が100%なのにベッドの温度が下がり続けるという不具合が起きました。この不具合の恐ろしいところは、Fluidd の操作画面に表示される温度は下がり続けているのに非接触型温度計で測定する温度は上がっていることで、これでは火事になりかねません。\nそこで、Raspberry pi pico をセカンド MCU にして、ベッドの温度を einsy ボードではなく Raspberry pi pico で計測して同じ問題が発生するか問題が解消するか確かめることにしました。すると、「印刷が始まったら出力100％なのに温度が低下し続けて92℃まで下がる（ここで印刷を手動中止）」という状態だったのが、印刷が始まって96.5℃ぐらいまで下がったところで温度上昇に転じて100℃前後をキープできるようになりました（それでも室温が10℃以下だとベッドの加熱が追い付かなくて Heater heater_bed not heating at expected rate エラーになることはありますが）。\nこのように Raspberry pi pico をセカンド MCU にする方法は Input Shaper の測定で紹介されていますが、温度計測に応用した記事は見当たらなかった（そもそもマザーボードを買い替えろという指摘はいったん脇に置いといて）ので、手順などをまとめたいと思います。\nまた、Raspberry pi pico と同じ RP2040 マイコンを使い、サイズが Raspberry pi pico の約3分の1程度1の Seeed Studio XIAO RP2040 を使って Input Shaper を計測することにも成功しましたので、この方法も紹介します。\nRaspberry pi Pico を使った温度測定 BOM Raspberry pi pico サーミスタ（104NT-4-R025H42G） ユニバーサル基板（ブレッドボード配線パターンタイプ） XHコネクタ（2ピン） 電解コンデンサ（10μF） 抵抗（4.7kΩ と 0Ω） ユニバーサル基板は、配線のはんだ付けを少しでも楽にするために片面ガラス・ユニバーサル基板（ブレッドボード配線パターンタイプ）: パーツ一般 秋月電子通商-電子部品・ネット通販を使いました。\n0Ωの抵抗は、配線の手間を減らすためにワイヤー代わりに使ったものです。\n手順 Klipper のインストール Raspberry pi pico をセカンド MCU にするには Klipper ファームウェアを書き込む必要がありますので、Klipper をインストールして3Dプリンタを制御している Raspberry pi 上でファームウェアを作成します。なお、ファームウェアの作成には、Klipper と関連ツールのインストール・アップデートを簡単にするツールである th33xitus/kiauh: Klipper Installation And Update Helper を使います。\nそれでは作業手順ですが、まず Raspberry pi に SSH で接続して kiauh/kiauh.sh コマンドで KIAUH を起動し、メニューの 4) [Advanced] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~~~ [ Main Menu ] ~~~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| 0) [Log-Upload] | Klipper: Installed: 1 | 10| | Repo: Klipper3d/klipper | 11| 1) [Install] | | 12| 2) [Update] | Moonraker: Installed: 1 | 13| 3) [Remove] | | 14| 4) [Advanced] | Mainsail: Installed! | 15| | Fluidd: Installed! | 16| | KlipperScreen: Not installed! | 17| 6) [Settings] | Telegram Bot: Not installed! | 18| | Obico: Not installed! | 19| | | 20| v5.0.0-14 | Octoprint: Not installed! | 21|-------------------------------------------------------| 22| Q) Quit | 23\\=======================================================/ 24####### Perform action: 4 それから Firmware メニューの 2) [Build only] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~ [ Advanced Menu ] ~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| Klipper \u0026amp; API: | Mainsail: | 10| 1) [Rollback] | 6) [Theme installer] | 11| | | 12| Firmware: | System: | 13| 2) [Build only] | 7) [Change hostname] | 14| 3) [Flash only] | | 15| 4) [Build + Flash] | Extras: | 16| 5) [Get MCU ID] | 8) [G-Code Shell Command] | 17 18|-------------------------------------------------------| 19| B) « Back | 20\\=======================================================/ 21####### Perform action: 2 するとビルドオプションの設定画面が表示されますので Micro-controller Architecture を選択して Raspberry pi RP2040 を選択します。\nビルドオプションの設定画面 マイコンのアーキテクチャ選択画面 マイコンのアーキテクチャに Raspberry pi RP2040 が選択されると、Bootloader offset と Communication interface も自動的に設定されますので、Q Y とタイプして設定を保存して画面を閉じます。\n設定後の画面 これでファームウェアのビルドが始まりますので、終わるまでしばし待ちます。ビルドが終わるとファームウェアが ~/klipper/out/klipper.uf2 として保存されていますので、手元のパソコンにコピーします。私の場合、手元のパソコンで scp pi@192.168.1.25:~/klipper/out/klipper.uf2 ~/ コマンドを実行してコピーしました。\nRaspberry pi pico へのファームウェア書き込みは、まず、BOOTSEL ボタンを押しながら pico をパソコンに接続します。すると、pico がマスストレージとして認識されます。\nマスストレージとして認識された Raspberry pi pico ここに先程 Raspberry pi からコピーしてきた klipper.uf2 をコピーします。これでファームウェアの書き込みが自動的に始まり、書き込みが完了すると自動的に pico が再起動します。再起動するとマスストレージとして認識されなくなりますので、パソコンから pico を取り外します。\n基板の配線 RepRap プロジェクトの RAMPS1.4 ボードの Thermistor の回路図を参考にして次のとおり配線しました。\nRAMPS1.4 ボードの回路図 今回の回路図 現実の配線は次の写真の形になりました。\n今回の回路図 printer.cfg の変更 Raspberry pi pico をセカンド MCU として使うための設定を printer.cfg に追加します。そのために pico に接続するためのシリアルポートを確認する必要がありますので、次の手順で確認します。\nMCU の ID 調査 MCU の ID は KIAUH で簡単に確認できますので、kiauh/kiauh.sh を実行して 4) [Advanced] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~~~ [ Main Menu ] ~~~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| 0) [Log-Upload] | Klipper: Installed: 1 | 10| | Repo: Klipper3d/klipper | 11| 1) [Install] | | 12| 2) [Update] | Moonraker: Installed: 1 | 13| 3) [Remove] | | 14| 4) [Advanced] | Mainsail: Installed! | 15| | Fluidd: Installed! | 16| | KlipperScreen: Not installed! | 17| 6) [Settings] | Telegram Bot: Not installed! | 18| | Obico: Not installed! | 19| | | 20| v5.0.0-14 | Octoprint: Not installed! | 21|-------------------------------------------------------| 22| Q) Quit | 23\\=======================================================/ 24####### Perform action: 4 それから 5) [Get MCU ID] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~ [ Advanced Menu ] ~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| Klipper \u0026amp; API: | Mainsail: | 10| 1) [Rollback] | 6) [Theme installer] | 11| | | 12| Firmware: | System: | 13| 2) [Build only] | 7) [Change hostname] | 14| 3) [Flash only] | | 15| 4) [Build + Flash] | Extras: | 16| 5) [Get MCU ID] | 8) [G-Code Shell Command] | 17|-------------------------------------------------------| 18| B) « Back | 19\\=======================================================/ 20####### Perform action: 5 Raspberry pi と Raspberry pi Pico は USB 接続なので 1) USB を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| Make sure that the controller board is connected now! | 8|-------------------------------------------------------| 9| | 10| How is the controller board connected to the host? | 11| 1) USB | 12| 2) UART | 13| | 14|-------------------------------------------------------| 15| B) « Back | H) Help [?] | 16\\=======================================================/ 17###### Connection method: 1 そうすると 3Dプリンタのマザーボードと pico のシリアルポートが表示されます。rp2040 が含まれる ID が Raspberry pi Pico なので、この ID をメモしておきます。ここでは usb-Klipper_rp2040_E660C06213582227-if00 が pico の ID です。\n1###### Identifying MCU connected via USB ... 2 3 ● MCU #1: usb-Klipper_rp2040_E660C06213582227-if00 4 ● MCU #2: usb-Klipper_stm32h743xx_2E0018000751303231393036-if00 printer.cfg これで printer.cfg を編集する準備が整いましたので、Raspberry pi pico をセカンド MCU とするために、2つ目の [mcu] セクションを追加して serial: に先程確認した ID を設定します。ID を設定するときは先頭に /dev/serial/by-id/ を追加します。なお、raspi_pico の部分は任意の名称を設定できます。\n1[mcu raspi_pico] 2serial: /dev/serial/by-id/usb-Klipper_rp2040_E660C06213582227-if00 また、今回はサーミスタを交換していますので、新しいサーミスタのための設定が必要になります。\nサーミスタの設定については、公式ガイドで [thermistor] セクションにサーミスタの温度毎の抵抗値を3組指定する方法と、温度と抵抗値の組み合わせを1つ指定するとともにβ値を指定する方法の2つが紹介されていますが、ここでは前者の方法を採用しました。なお、サーミスタの温度毎の抵抗値は、サーミスタメーカーのデータシートで確認しました。\n1[thermistor bed_thermistor] 2temperature1: 25 3resistance1: 100000 4temperature2: 60 5resistance2: 22480 6temperature3: 100 7resistance3: 5569 そして、[heater_bed] セクションの sensor_type に先程設定したサーミスタを指定しました。\n1[heater_bed] 2heater_pin: PG5 3sensor_type: bed_thermistor 4sensor_pin: raspi_pico:gpio27 これで、Raspberry pi pico を使ってベッドの温度を測定することができるようになりました。\nこの状況で Raspberry pi pico を取り外したり基板からサーミスタが抜けたりすると、エラーが発生して印刷が強制終了しますので注意してください。 XIAO RP2040 を使った Input Shaper の測定 XIAO RP2040 を使って Input Shaper を測定する方法を説明します。なお、Raspberry pi pico を使って測定する方法は、(2) Raspberry Pi Pico as a secondary MCU for resonance testing working! : klippers や次の動画で解説されています。\nBOM Seeed Studio XIAO RP2040 ADXL345 Qiコネクタ 手順 Klipper のインストール XIAO RP2040 に Klipper のファームウェアをインストールする方法は上記の説明とほぼ同じです。\n違いは、XIAO RP2040 をブートローダーモードで起動するには、基板上の \u0026quot;B\u0026quot; ボタンを押しながら XIAO RP2040 をパソコンに接続し、パソコンに接続したら \u0026quot;B\u0026quot; を離すという手順が必要という点です。これで XIAO RP2040 がブートローダーモードで起動し、パソコンにマスストレージデバイスとして認識されますので、あとは Raspberry pi pico と同様に klipper.uf2 を XIAO RP2040 にコピーします。\nXIAO RP2040 への配線 これが一番苦労した点で、最初は同じことをしている人が公開している XIAO RP2040 のケースで紹介されていた配線方法を試しましたが、ACCELEROMETER_QUERY コマンドを実行しても Invalid adxl345 id (got ff vs e5). というエラーが返ってくるだけで上手くいきませんでした。また、そのページで紹介されている配線方法は XIAO RP2040 のデータシートに記載されているピン情報と合わなかったので、データシートに記載されたピン情報を基に配線を変えましたが、それでも同じエラーが返ってきました。そこでさらに調べると同じ配線で同じエラーに遭遇した人の相談が Reddit で見つかり、そのスレッドにある printer.cfg の設定を用いるとエラーを解消できました。\n無事に動いた配線は次のとおりです。実際に配線する時は SilkScreen の表記を頼りに配線すれば OK だと思いますが、この後説明する printer.cfg では GPIO ピンの番号が必要なのでここに記載しています。なお、私が使っている ADXL345 は 3.3V で動作するタイプです。\nADXL345 SilkScreen XIAO RP2040 GPIO XIAO RP2040 SilkScreen RP2040 SPI SDO 4 9 MISO SDA 3 10 MOSI SCL 2 8 SCK CS 1 7 CS VIN 3V3 GND GND XIAO RP2040 と ADXL345 の実際の配線状況は次のとおりです。XIAO RP2040 への配線がはんだ付けしたところからモゲる事態が何度も起きたため、2液性の接着剤で固めています。\nXIAO RP2040 の配線の様子 ADXL345 の配線の様子 printer.cfg の変更 Raspberry pi pico を使うときと同様に、XIAO RP2040 をセカンド MCU として使うための設定を追加します。シリアルポートの確認方法は上記の説明と同じなので説明は省略します。\nなお、Input Shaper を測定しない時は XIAO RP2040 を Raspberry pi から取り外すと思いますが、以下の設定を printer.cfg に直接書き込んで XIAO RP2040 を Raspberry pi から取り外すとエラーになります。それを避けるには、XIAO RP2040 を取り外す前に以下の設定をコメントアウトするか、または別の設定ファイル（例えば adxl345.cfg というファイル）に記述して printer.cfg に [include adxl345.cfg] を追加し、XIAO RP2040 を取り外す前にそのコードをコメントアウトする方法のいずれかを取る必要があります。後者の方が簡単なので、私は後者の方法を採用しています。\n1# adxl345.cfg 2[mcu xiao_rp2040] 3serial: /dev/serial/by-id/usb-Klipper_rp2040_4150323833373205-if00 それから、ADXL345 を使うための設定を追加します。[adxl345] セクションの各項目に XIAO RP2040 の GPIO ピンの番号を指定しますが、プレフィックスとして xiao_rp2040: を追加する必要があります。\n1[adxl345] 2cs_pin: xiao_rp2040:gpio1 3spi_software_sclk_pin: xiao_rp2040:gpio2 4spi_software_mosi_pin: xiao_rp2040:gpio3 5spi_software_miso_pin: xiao_rp2040:gpio4 6 7[resonance_tester] 8accel_chip: adxl345 9 10probe_points: 115, 115, 20 また、printer.cfg に adxl345.cfg をインクルードするためのコードを追加します。\n1# printer.cfg 2# Input Shaper 測定時以外はコメントアウトしておく 3#[include adxl345.cfg] これで XIAO RP2040 を USB ケーブルで Raspberry pi に接続して [include adxl345.cfg] をアンコメントすれば XIAO RP2040 をセカンド MCU として使うことで Input Shaper を計測することができます。\nなお、Input Shaper 計測に必要な numpy 等のライブラリのインストールは、公式ガイドを参照してください。\n実際の計測 Input Shaper を計測するときは、まず XIAO RP2040 を Raspberry pi に接続し、それから printer.cfg の #[include adxl345.cfg] をアンコメントしてから Klipper を再起動します。\nKlipper が再起動したら、ACCELEROMETER_QUERY コマンドを実行して ADXL345 の接続などを確認します。上手く接続できていれば Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800 という具合に現在の計測値が返ってきます。\nあとは ADXL345 をプリンタに取り付けて TEST_RESONANCES AXIS=X、TEST_RESONANCES AXIS=Y コマンドを実行して XY 方向それぞれについて Input Shaper を計測します。なお、このコマンドは門型のプリンタ（Ender3 や Prusa MK3S+ 等）の場合のコマンドです。\n計測が終わったら、printer.cfg の [include adxl345.cfg] をコメントアウトしてから Klipper を再起動し、XIAO RP2040 を取り外せば作業完了です。\nこの方法は XIAO RP2040 への配線という事前の一手間が必要ですが、一度配線してしまえば、計測の度に Raspberry pi のピンの位置を確認しながらジャンパケーブルで Raspberry pi と ADXL345 を接続する公式ガイドの方法より楽かなと思います。なので、しばらくはこの方法を続けてみようと思います。\n参考情報 Measuring Resonances - Klipper documentation (2) Raspberry Pi Pico as a secondary MCU for resonance testing working! : klippers Input Shaper with a Pi Pico - Klipper Tips - YouTube Overview - Seeed Wiki Case for Adafruit QT PY RP2040 and Seeed XIAO RP2040 (for ADXL345) by motocoder | Download free STL model | Printables.com (2) Assistance requested for ADXL input on RP2040 : klippers Raspberry pi pico のサイズは 21 x 51mmで、XIAO RP2040 のサイズは 20 x 17.5mm です。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"http://localhost:1313/post/2023-02-05/","section":"post","tags":["3Dプリンタ","Klipper","備忘録"],"title":"Raspberry pi pico と XIAO RP2040 を使って温度や Input Shaper を計測する方法"},{"body":"前置き 2022年12月25日の記事で Neovim の設定を色々紹介しましたが、そこで設定コードだけ紹介した 新世代の UI 作成プラグイン ddu.vim について、もう少し詳しく解説したいと思います。\nプラグインの説明 ddu.vim 自体の説明は作者の方のこの記事 → 新世代の UI 作成プラグイン ddu.vim に詳しい説明がありますが、ファジーファインダーとして開発されたプラグインで、ddu.vim 自体はフレームワークの提供に特化し、UI 構築やデータソース取得といった機能は別のプラグインに任せるという点が大きな特徴です。\nそのため、このプラグインだけインストールしても使うことはできず、次のプラグインもインストールする必要があります。\nUI 担当のプラグイン 操作対象となるデータを取得してくるプラグイン データのソート、マッチング、フィルタリングを担当するプラグイン データに対する各種操作 そして、ddu.vim にこれらのプラグインを組み合わせて使っていくこととなります。一見するとかなり面倒なプラグインという印象を受けますが、次の点が大きなメリットとなります。\nまず、UI を専用のプラグインが担当しますので、自分の好きな UI を構築できます。もちろん UI 構築は大変（私には無理）ですが、ddu.vim をファイラーとして使う場合、現時点でも作者がファイラーの UI として作成した Shougo/ddu-ui-filer: File listing UI for ddu.vim とファジーファインダーの UI として作成した Shougo/ddu-ui-ff: Fuzzy finder UI for ddu.vim の2つの UI を使えます。ツリー表示が好みなら ddu-ui-filer を選びますし、多数のファイルから条件に合うファイルをピックアップする形が好みなら ddu-ui-ff を選ぶことになります。\nそれから、操作対象となるデータの取得やソートなどを行うプラグインも自分で選びますので、不要なデータはそもそも取得しないといった設定も可能です。取得できるデータは、ファイルやバッファのリストなどに加えて、レジスタやWindowsのクリップボードの履歴といったものもあります。\nこのように自由度が高く自分の好みに合わせられるプラグインですが、やりたいことから設定を逆引きできるようなドキュメントは見当たらないため、設定作業が難しいのは事実だと思います。かくいう私も、このプラグインをファイラー＆バッファリスト絞り込み＆コマンド履歴絞り込みに使っていますが、しばらくすると設定方法を忘れてしまいそうなので、将来の自分のためにも設定方法をまとめようと思います。\n設定の流れ 大まかな設定の流れは次のとおりです。\nDeno のインストール denops.vim のインストール ddu.vim のインストール UI 用プラグインなどのインストール 設定作業 Deno のインストール ddu.vim は Deno を使って開発されていますので、公式サイト の Installation を参照して Deno をインストールします。私の場合、Neovim を WSL2 にインストールしていますので、次のコマンドでインストールしました。\n1curl -fsSL https://deno.land/x/install/install.sh | sh それから次のコマンドでパスを通します。なお、私はシェルに fish shell を使っています。\n1set -Ux fish_user_paths /home/s-show/.deno/bin/ $fish_user_paths そして、次のコマンドで正しくインストールできたか確認します。\n1\u0026gt; deno --version 2deno 1.28.3 (release, x86_64-unknown-linux-gnu) 3v8 10.9.194.5 4typescript 4.8.3 deno.vim のインストール Deno をインストールしたら、次は Deno を使って Vim/Neovim のプラグインを作成するためのエコシステムである vim-denops/denops.vim: 🐜 An ecosystem of Vim/Neovim which allows developers to write cross-platform plugins in Deno をインストールします。\nこちらはプラグインであるため、インストールは Neovim 側で行います。私はプラグイン管理に tani/vim-jetpack: The lightning-fast plugin manager, alternative to vim-plug を使っていますので、次のコードを init.vim に追加して :JetpackSync コマンドを実行してインストールしています。\n1Jetpack \u0026#39;vim-denops/denops.vim\u0026#39; ddu.vim と付属プラグインのインストール これで下準備はできましたので、ddu.vim と UI と source と Filter 機能を提供するプラグイン関連するプラグインをインストールします。\n関連するプラグインとしてどのプラグインをインストールするかが問題ですが、ここでは、「ファイラー、バッファリスト管理およびコマンド履歴管理」の3つの機能を実現することとし、かつ、「ファイラーはファイルツリー形式で表示」「バッファリストとコマンド履歴はファジーファインダーで管理」するという方針でインストールするプラグインを決定します。\ninit.vim に以下のコードを追加してから :JetpackSync コマンドを実行してプラグインをまとめてインストールします。\n1Jetpack \u0026#39;Shougo/ddu.vim\u0026#39; 2Jetpack \u0026#39;Shougo/ddu-ui-filer\u0026#39; 3Jetpack \u0026#39;Shougo/ddu-ui-ff\u0026#39; 4Jetpack \u0026#39;Shougo/ddu-source-file\u0026#39; 5Jetpack \u0026#39;Shougo/ddu-source-file_rec\u0026#39; 6Jetpack \u0026#39;Shougo/ddu-source-register\u0026#39; 7Jetpack \u0026#39;kuuote/ddu-source-mr\u0026#39; 8Jetpack \u0026#39;Shougo/ddu-source-command_history\u0026#39; 9Jetpack \u0026#39;Shougo/ddu-commands.vim\u0026#39; 10Jetpack \u0026#39;Shougo/ddu-column-filename\u0026#39; 11Jetpack \u0026#39;shun/ddu-source-buffer\u0026#39; 12Jetpack \u0026#39;Shougo/ddu-filter-matcher_substring\u0026#39; 13Jetpack \u0026#39;Shougo/ddu-kind-file\u0026#39; ddu.vim の設定 いよいよ ddu.vim を設定していきますが、先にコードを提示し、そのコードについて解説する方が説明が楽なので、まずコードを提示します。\nhogehoge ","link":"http://localhost:1313/post/2023-01-02/","section":"post","tags":[],"title":"2023 01 02"},{"body":"","link":"http://localhost:1313/archives/2022/12/","section":"archives","tags":null,"title":"2022/12"},{"body":" 目次 前置き アウトラインバッファの作成 2022年1月10日追記 日本語テキストでの移動の効率化 ddu.vim の導入 ddc.vim の導入 lualine.nvim の導入 キーバインド変更 設定ファイル分割 Re:VIEWのシンタックスハイライト noice.nvim の導入 導入したものの廃止したもの fine-cmdline.nvim 参考にしたサイト・情報 前置き WSL2 + Neovim + VSCode で使っていく予定だったのですが、Neovim をあれこれカスタマイズしていると Neovim が使いやすくなってきてメインエディタになりそうなので、これまでの設定をまとめてみようと思います。\n順不同で色々なネタを扱っていて記事が長いですので、上記の目次で必要な個所を拾い読みしてください。\nアウトラインバッファの作成 2022年1月10日追記 このブログは、Go言語 で書かれた静的サイトジェネレーターの The world’s fastest framework for building websites |Hugo で構築しており、記事は Markdown で書いています。また、職場で細々と行っている勉強会の資料は、書籍制作向けのテキストマークアップ言語仕様、およびその変換システムである Re:VIEW - Digital Publishing System for Books and eBooks で作成しています。\nどちらもそこそこ長い記事を書くことがあるのでアウトライン機能が欲しいのですが、プラグインはできる限り少なくしたいため、プラグイン無しでできるか挑戦したところ上手くいきましたので、方法を紹介します。\n処理の大まかな流れは、;o キーをタイプしたらファイルタイプ毎の検索条件を用いて Vimgrep と Quickfix を実行し、その結果をカレントバッファの右半分に表示するというものです。\nただ、Neovim のデフォルトのファイルタイプに Re:VIEW は含まれていませんので、~/.config/nvim/filetype.vim に以下のコードを追加して、Re:VIEW のファイルタイプを登録します。\n1augroup filetypedetect 2 \u0026#34; 拡張子 .re のファイルを Re:VIEW ファイルと判定 3 au BufNewFile,BufRead *.re setf review 4augroup END それから、Vimgrep と Quickfix を次のとおり組み合わせます。\nMarkdown と Re:VIEW の見出し部分を検索条件に設定した Vimgrep を実行 Vimgrep の結果を copen コマンドで表示 wincmd L コマンドで結果を右側に表示 上記の処理を関数にまとめた上で ;o キーバインドに割り当て 具体的なコードは次のとおりです。\n1function! CreateOutlineBuffer() 2 if (\u0026amp;ft==\u0026#39;review\u0026#39;) 3 vimgrep /^=\\+ / % 4 elseif (\u0026amp;ft==\u0026#39;markdown\u0026#39;) 5 vimgrep /^#\\+ / % 6 endif 7 copen 8 wincmd L 9endfunction 10 11nnoremap \u0026lt;silent\u0026gt; ;o :\u0026lt;Cmd\u0026gt;call CreateOutlineBuffer()\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; これで ;o 次のスクリーンショットのようにアウトラインバッファを作成することができます。\nアウトラインバッファを表示 実際の動作は次の動画のとおりです。\nThere should have been a video here but your browser does not seem to support it. ちなみに、このアウトラインバッファは、今は開発が終了した Github 製エディタのプラグインの [t9md/atom-narrow: narrow something](https://github.com/t9md/atom-narrow) の見た目を模して設定しました。私はこのプラグインがお気に入りでしたので、見た目だけでも同じようにしたかったものです。 2022年1月10日追記 上記のコードには欠陥があり、次のウィンドウ配置で編集しているときにアウトラインを更新するために ;f キーバインドをタイプすると画面配置が変わってしまいます。\n1アウトライン更新前 2+────────────+────────────+ 3| Window A | Window B | 4| (Doc) | (Outline) | 5| +────────────+ 6| | Window C | 7| | (Terminal) | 8+────────────+────────────+ 1アウトライン更新後 2+───────+────────+────────+ 3| Win A | Win C | Win B | 4| | | | 5| | | | 6| | | | 7| | | | 8+───────+────────+────────+ この問題を解決するため、;f キーバインドをタイプしたときに Quickfix ウィンドウが存在しているか調査し、存在していればその時点のウィンドウ配置をいったん保存してからアウトラインを更新してウィンドウ配置を元に戻す方法に変更しました。\n具体的なコードは次のとおりです。\n1function! CreateOutlineBuffer() 2 let QuickfixWindowExists = QuickfixWindowExists() 3 if QuickfixWindowExists == \u0026#34;true\u0026#34; 4 let windowLayout = winsaveview() 5 call DoVimgrep(\u0026amp;filetype) 6 copen 7 execute winrestview(windowLayout) 8 else 9 call DoVimgrep(\u0026amp;filetype) 10 copen 11 wincmd L 12 endif 13endfunction 14 15function! QuickfixWindowExists() abort 16 let bufferNoList = tabpagebuflist() 17 for bufferNo in bufferNoList 18 if getwininfo(bufwinid(bufferNo))[\u0026#39;variables\u0026#39;][\u0026#39;quickfix\u0026#39;] == 1 19 return \u0026#34;true\u0026#34; 20 endif 21 endfor 22 return \u0026#34;false\u0026#34; 23endfunction 24 25function! DoVimgrep(filetype) abort 26 if (a:filetype==\u0026#39;review\u0026#39;) 27 vimgrep /^=\\+ / % 28 elseif (a:filetype==\u0026#39;markdown\u0026#39;) 29 vimgrep /^#\\+ / % 30 endif 31endfunction 32 33nnoremap \u0026lt;silent\u0026gt; ;o :\u0026lt;Cmd\u0026gt;call CreateOutlineBuffer()\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; Quickfix ウィンドウの存在確認は QuickfixWindowExists() 関数で行っています。\nまず、tabpagebuflist() 関数で編集中のタブにあるバッファの番号リストを取得します。そうしたら、その番号リストを for 文で順番に bufwinid() 関数に渡してウィンドウID を取得し、その ID を getwininfo() 関数に渡してウィンドウ情報を辞書のリストとして取得します。ウィンドウ情報にはそのウィンドウが Quickfix/Location ウィンドウかどうかを示す項目がありますので、その項目を if 文の条件に用いています。Quickfix ウィンドウは1つしか開くことができませんので、Quickfix ウィンドウが1つ見つかった時点で \u0026quot;true\u0026quot; を返して関数を終了します。\nあとは、QuickfixWindowExists() 関数の返り値が \u0026quot;true\u0026quot; なら Quickfix ウィンドウが存在するので winsaveview() 関数を実行してウィンドウ配置の情報を取得して変数に格納します。それからアウトライン表示の DoVimgrep() 関数を実行してアウトラインを更新し、Ex コマンドの winrestview に先ほど格納したウィンドウ配置の情報を渡してウィンドウ配置を復元します。\nなお、cbuffer コマンドを実行してアウトラインを更新する方法も試しましたが、行頭に || が追加されて Enter キーを押しても該当箇所にジャンプできなくなる症状を解消できなかったため、断念して上記の方法に切り替えました。\n日本語テキストでの移動の効率化 Vim の f{char} コマンドを日本語で使う場合、f キーをタイプしてから IME をオンにして検索文字を入力する必要があり、非常に面倒くさいです。\nそこで、Vimで日本語編集時の f, t の移動や操作を楽にするプラグイン ftjpn を作りました をインストールして、f, や f. や fg のキーバインドで 、 や 。 や が に移動できるようにしました。\nソースコードを編集するときのような細やかな移動はできませんが、、 や 。 や が に移動できるだけでも結構効率は上がりますので、このプラグインは便利なプラグインです。なお、私の設定は次のとおりです。\n1let g:ftjpn_key_list = [ 2 \\ [\u0026#39;.\u0026#39;, \u0026#39;。\u0026#39;, \u0026#39;．\u0026#39;], 3 \\ [\u0026#39;,\u0026#39;, \u0026#39;、\u0026#39;, \u0026#39;，\u0026#39;], 4 \\ [\u0026#39;g\u0026#39;, \u0026#39;が\u0026#39;], 5 \\ [\u0026#39;w\u0026#39;, \u0026#39;を\u0026#39;], 6 \\ [\u0026#39;h\u0026#39;, \u0026#39;は\u0026#39;], 7 \\ [\u0026#39;(\u0026#39;, \u0026#39;（\u0026#39;, \u0026#39;）\u0026#39;], 8 \\ [\u0026#39;;\u0026#39;, \u0026#39;！\u0026#39;, \u0026#39;？\u0026#39;], 9 \\ [\u0026#39;[\u0026#39;, \u0026#39;「\u0026#39;, \u0026#39;『\u0026#39;, \u0026#39;【\u0026#39;], 10 \\ [\u0026#39;]\u0026#39;, \u0026#39;」\u0026#39;, \u0026#39;』\u0026#39;, \u0026#39;】\u0026#39;], 11 \\ ] なお、このプラグインを使い始めた当初、, や . は使えるのに g や h が使えなくて困っていましたが、作者に相談して無事に使えるようになりました。あらためて御礼申し上げます。\nddu.vim の導入 エディタ内蔵のファイラーがあると便利なので色々探したのですが、Vim 標準の Netrw は操作性が独特だったりサイドバーの幅の調整が難しかったりとイマイチ合わなかったので、思い切って 新世代のファイラー UI ddu-ui-filer を導入しました。\n最初は設定方法などがさっぱり分からず悪戦苦闘の連続でしたが、何とか使えるようになるととても便利で、手放せないプラグインになりそうです。\n現在はファイラーに加えて、バッファリストとコマンド履歴の絞り込み＆選択にも使っています。特に、バッファリストの選択は便利な機能で、ターミナルで nvim **.vim や nvim **.re と入力して設定ファイルや Re:VIEW ファイルを一括して開いてバッファリストに読み込み、そのリストを ;b キーバインドで呼び出してサクサク切り替えています。ついでに、リストから開くときに Enter だとカレントバッファに読み込み、vo でウィンドウを縦分割して読み込み、vs でウィンドウを水平分割して読み込むように設定しています。ただし、ここまで来るには悪戦苦闘の連続でした。\n実際の設定とその解説を書けば他の人の役に立つと思うのですが、記事が一本書けそうな気がしますので、設定の解説は別の記事にします。そのため、ここでは実際の設定のみ掲載します。\n1let g:denops#deno = \u0026#39;/home/s-show/.deno/bin/deno\u0026#39; 2 3call ddu#custom#patch_global({ 4\\ \u0026#39;ui\u0026#39;: \u0026#39;filer\u0026#39;, 5\\ \u0026#39;sources\u0026#39;: [ 6\\ { 7\\ \u0026#39;name\u0026#39;: \u0026#39;file\u0026#39;, 8\\ \u0026#39;params\u0026#39;: {}, 9\\ }, 10\\ ], 11\\ \u0026#39;sourceOptions\u0026#39;: { 12\\ \u0026#39;_\u0026#39;: { 13\\ \u0026#39;columns\u0026#39;: [\u0026#39;filename\u0026#39;], 14\\ }, 15\\ \u0026#39;command_history\u0026#39;: { 16\\ \u0026#39;matchers\u0026#39;: [ \u0026#39;matcher_substring\u0026#39; ], 17\\ }, 18\\ \u0026#39;buffer\u0026#39;: { 19\\ \u0026#39;matchers\u0026#39;: [ \u0026#39;matcher_substring\u0026#39; ], 20\\ }, 21\\ }, 22\\ \u0026#39;kindOptions\u0026#39;: { 23\\ \u0026#39;file\u0026#39;: { 24\\ \u0026#39;defaultAction\u0026#39;: \u0026#39;open\u0026#39;, 25\\ }, 26\\ \u0026#39;command_history\u0026#39;: { 27\\ \u0026#39;defaultAction\u0026#39;: \u0026#39;execute\u0026#39;, 28\\ }, 29\\ }, 30\\ \u0026#39;uiParams\u0026#39;: { 31\\ \u0026#39;filer\u0026#39;: { 32\\ \u0026#39;sort\u0026#39;: \u0026#39;filename\u0026#39;, 33\\ \u0026#39;split\u0026#39;: \u0026#39;floating\u0026#39;, 34\\ \u0026#39;displayTree\u0026#39;: v:true, 35\\ \u0026#39;previewVertical\u0026#39;: v:true, 36\\ \u0026#39;previewWidth\u0026#39;: 80, 37\\ } 38\\ }, 39\\ }) 40 41autocmd FileType ddu-ff call s:ddu_my_settings() 42function! s:ddu_my_settings() abort 43 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;CR\u0026gt; 44 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;itemAction\u0026#39;)\u0026lt;CR\u0026gt; 45 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; vo 46 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;open\u0026#39;, \u0026#39;params\u0026#39;: {\u0026#39;command\u0026#39;: \u0026#39;vsplit\u0026#39;}})\u0026lt;CR\u0026gt; 47 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; vs 48 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;open\u0026#39;, \u0026#39;params\u0026#39;: {\u0026#39;command\u0026#39;: \u0026#39;split\u0026#39;}})\u0026lt;CR\u0026gt; 49 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;Space\u0026gt; 50 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;toggleSelectItem\u0026#39;)\u0026lt;CR\u0026gt; 51 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; i 52 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;openFilterWindow\u0026#39;)\u0026lt;CR\u0026gt; 53 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; q 54 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#ff#do_action(\u0026#39;quit\u0026#39;)\u0026lt;CR\u0026gt; 55endfunction 56 57autocmd FileType ddu-ff-filter call s:ddu_filter_my_settings() 58function! s:ddu_filter_my_settings() abort 59 inoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;CR\u0026gt; 60 \\ \u0026lt;Esc\u0026gt;\u0026lt;Cmd\u0026gt;close\u0026lt;CR\u0026gt; 61 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;CR\u0026gt; 62 \\ \u0026lt;Cmd\u0026gt;close\u0026lt;CR\u0026gt; 63 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; q 64 \\ \u0026lt;Cmd\u0026gt;close\u0026lt;CR\u0026gt; 65endfunction 66 67autocmd FileType ddu-filer call s:ddu_filer_my_settings() 68function! s:ddu_filer_my_settings() abort 69 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;CR\u0026gt; 70 \\ ddu#ui#filer#is_tree() ? 71 \\ \u0026#34;\u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;narrow\u0026#39;})\u0026lt;CR\u0026gt;\u0026#34; : 72 \\ \u0026#34;\u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34; 73 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; vo 74 \\ ddu#ui#filer#is_tree() ? 75 \\ \u0026#34;\u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;narrow\u0026#39;})\u0026lt;CR\u0026gt;\u0026#34; : 76 \\ \u0026#34;\u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;open\u0026#39;, \u0026#39;params\u0026#39;: {\u0026#39;command\u0026#39;: \u0026#39;vsplit\u0026#39;}})\u0026lt;CR\u0026gt;\u0026#34; 77 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;Space\u0026gt; 78 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;toggleSelectItem\u0026#39;)\u0026lt;CR\u0026gt; 79 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;Esc\u0026gt; 80 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;quit\u0026#39;)\u0026lt;CR\u0026gt; 81 nnoremap \u0026lt;buffer\u0026gt; o 82 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;expandItem\u0026#39;, 83 \\ {\u0026#39;mode\u0026#39;: \u0026#39;toggle\u0026#39;})\u0026lt;CR\u0026gt; 84 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; q 85 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;quit\u0026#39;)\u0026lt;CR\u0026gt; 86 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; .. 87 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;narrow\u0026#39;, \u0026#39;params\u0026#39;: {\u0026#39;path\u0026#39;: \u0026#39;..\u0026#39;}})\u0026lt;CR\u0026gt; 88 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; c 89 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;copy\u0026#39;})\u0026lt;CR\u0026gt; 90 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; p 91 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;paste\u0026#39;})\u0026lt;CR\u0026gt; 92 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; d 93 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;delete\u0026#39;})\u0026lt;CR\u0026gt; 94 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; r 95 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;rename\u0026#39;})\u0026lt;CR\u0026gt; 96 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; mv 97 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;move\u0026#39;})\u0026lt;CR\u0026gt; 98 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; t 99 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;newFile\u0026#39;})\u0026lt;CR\u0026gt; 100 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; mk 101 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;newDirectory\u0026#39;})\u0026lt;CR\u0026gt; 102 nnoremap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; yy 103 \\ \u0026lt;Cmd\u0026gt;call ddu#ui#filer#do_action(\u0026#39;itemAction\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;yank\u0026#39;})\u0026lt;CR\u0026gt; 104endfunction 105 106\u0026#34; `;f` でファイルリストを表示する 107nmap \u0026lt;silent\u0026gt; ;f \u0026lt;Cmd\u0026gt;call ddu#start({ 108\\ \u0026#39;name\u0026#39;: \u0026#39;filer\u0026#39;, 109\\ \u0026#39;uiParams\u0026#39;: { 110\\ \u0026#39;filer\u0026#39;: { 111\\ \u0026#39;search\u0026#39;: expand(\u0026#39;%:p\u0026#39;) 112\\ } 113\\ }, 114\\ })\u0026lt;CR\u0026gt; 115 116\u0026#34; `;b` でバッファリストを表示する 117nmap \u0026lt;silent\u0026gt; ;b \u0026lt;Cmd\u0026gt;call ddu#start({ 118\\ \u0026#39;ui\u0026#39;: \u0026#39;ff\u0026#39;, 119\\ \u0026#39;sources\u0026#39;: [{\u0026#39;name\u0026#39;: \u0026#39;buffer\u0026#39;}], 120\\ \u0026#39;uiParams\u0026#39;: { 121\\ \u0026#39;ff\u0026#39;: { 122\\ \u0026#39;split\u0026#39;: \u0026#39;floating\u0026#39;, 123\\ } 124\\ }, 125\\ })\u0026lt;CR\u0026gt; 126 127\u0026#34; `;c` でコマンドリストを表示する 128nmap \u0026lt;silent\u0026gt; ;c \u0026lt;Cmd\u0026gt;call ddu#start({ 129\\ \u0026#39;ui\u0026#39;: \u0026#39;ff\u0026#39;, 130\\ \u0026#39;sources\u0026#39;: [ 131\\ { 132\\ \u0026#39;name\u0026#39;: \u0026#39;command_history\u0026#39;, 133\\ }, 134\\ ], 135\\ \u0026#39;uiParams\u0026#39;: { 136\\ \u0026#39;ff\u0026#39;: { 137\\ \u0026#39;split\u0026#39;: \u0026#39;floating\u0026#39;, 138\\ }, 139\\ }, 140\\ })\u0026lt;CR\u0026gt; ファイルリストなどの実際の表示は次のとおりです。\nファイラーを表示 バッファリストを表示 コマンド履歴を表示 ddc.vim の導入 自動補完機能を強化するため、上記の ddu.vim と同じ方が作成してる自動補完プラグインの 新世代の自動補完プラグイン ddc.vim を導入しました。合わせて、自動補完をコマンドラインバッファでも有効にするため、自動補完プラグイン ddc.vim + pum.vim も導入しました。こちらも導入は悪戦苦闘の連続でしたが、何とか自動補完ができるようになりました。\n過去に入力したコマンドであれば、上記の ddu.vim のコマンド履歴表示でも対応可能なのですが、新規のコマンドはコマンドラインバッファで入力しないといけないですし、コマンド履歴表示は若干タイムラグがあるので、コマンドラインバッファでの自動補完は便利です。また、通常のファイル編集でも2文字入力すれば補完機能が発動しますので、便利に使っています。ただし、プログラミングで必須の LSP 周りの設定は全くできていないため、次はここに挑戦します。\nなお、こちらも ddu.vim と同じく解説を書くと記事が一本書けそうな感じなので、ここでは実際のコードのみ掲載します。\n1\u0026#34;======================================================================================= 2\u0026#34; ddc.nvim の設定 3\u0026#34;======================================================================================= 4\u0026#34; 5call ddc#custom#patch_global(\u0026#39;sources\u0026#39;, [\u0026#39;around\u0026#39;]) 6call ddc#custom#patch_global(\u0026#39;sourceOptions\u0026#39;, { 7 \\ \u0026#39;_\u0026#39;: { 8 \\ \u0026#39;matchers\u0026#39;: [\u0026#39;matcher_head\u0026#39;], 9 \\ \u0026#39;sorters\u0026#39;: [\u0026#39;sorter_rank\u0026#39;] 10 \\ }, 11 \\ \u0026#39;around\u0026#39;: { 12 \\ \u0026#39;mark\u0026#39;: \u0026#39;around\u0026#39; 13 \\ }, 14 \\}) 15 16 17\u0026#34;======================================================================================= 18\u0026#34; pum.nvim の設定 19\u0026#34;======================================================================================= 20\u0026#34; 21call ddc#custom#patch_global(\u0026#39;cmdlineSources\u0026#39;, { 22 \\ \u0026#39;:\u0026#39;: [\u0026#39;cmdline-history\u0026#39;, \u0026#39;cmdline\u0026#39;, \u0026#39;around\u0026#39;], 23 \\ \u0026#39;@\u0026#39;: [\u0026#39;cmdline-history\u0026#39;, \u0026#39;input\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;around\u0026#39;], 24 \\ \u0026#39;\u0026gt;\u0026#39;: [\u0026#39;cmdline-history\u0026#39;, \u0026#39;input\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;around\u0026#39;], 25 \\ \u0026#39;/\u0026#39;: [\u0026#39;around\u0026#39;, \u0026#39;line\u0026#39;], 26 \\ \u0026#39;?\u0026#39;: [\u0026#39;around\u0026#39;, \u0026#39;line\u0026#39;], 27 \\ \u0026#39;-\u0026#39;: [\u0026#39;around\u0026#39;, \u0026#39;line\u0026#39;], 28 \\ \u0026#39;=\u0026#39;: [\u0026#39;input\u0026#39;], 29 \\ }) 30 31call ddc#custom#patch_global(\u0026#39;ui\u0026#39;, \u0026#39;pum\u0026#39;) 32\u0026#34;call ddc#custom#patch_global(\u0026#39;completionMenu\u0026#39;, \u0026#39;pum.vim\u0026#39;) 33inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; 34 \\ pum#visible() ? \u0026#39;\u0026lt;Cmd\u0026gt;call pum#map#insert_relative(+1)\u0026lt;CR\u0026gt;\u0026#39; : 35 \\ (col(\u0026#39;.\u0026#39;) \u0026lt;= 1 \u0026lt;Bar\u0026gt;\u0026lt;Bar\u0026gt; getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;) - 2] =~# \u0026#39;\\s\u0026#39;) ? 36 \\ \u0026#39;\u0026lt;TAB\u0026gt;\u0026#39; : ddc#manual_complete() 37inoremap \u0026lt;S-Tab\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative(-1)\u0026lt;CR\u0026gt; 38inoremap \u0026lt;C-n\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#select_relative(+1)\u0026lt;CR\u0026gt; 39inoremap \u0026lt;C-p\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#select_relative(-1)\u0026lt;CR\u0026gt; 40inoremap \u0026lt;C-y\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#confirm()\u0026lt;CR\u0026gt; 41inoremap \u0026lt;C-e\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#cancel()\u0026lt;CR\u0026gt; 42inoremap \u0026lt;PageDown\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative_page(+1)\u0026lt;CR\u0026gt; 43inoremap \u0026lt;PageUp\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative_page(-1)\u0026lt;CR\u0026gt; 44 45call ddc#custom#patch_global(\u0026#39;autoCompleteEvents\u0026#39;, [ 46 \\ \u0026#39;InsertEnter\u0026#39;, \u0026#39;TextChangedI\u0026#39;, \u0026#39;TextChangedP\u0026#39;, 47 \\ \u0026#39;CmdlineEnter\u0026#39;, \u0026#39;CmdlineChanged\u0026#39;, 48 \\ ]) 49 50nnoremap : \u0026lt;Cmd\u0026gt;call CommandlinePre()\u0026lt;CR\u0026gt;: 51nnoremap ;; \u0026lt;Cmd\u0026gt;call CommandlinePre()\u0026lt;CR\u0026gt;: 52 53function! CommandlinePre() abort 54 \u0026#34; Note: It disables default command line completion! 55 cnoremap \u0026lt;Tab\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative(+1)\u0026lt;CR\u0026gt; 56 cnoremap \u0026lt;S-Tab\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative(-1)\u0026lt;CR\u0026gt; 57 cnoremap \u0026lt;C-n\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative(+1)\u0026lt;CR\u0026gt; 58 cnoremap \u0026lt;C-p\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#insert_relative(-1)\u0026lt;CR\u0026gt; 59 cnoremap \u0026lt;C-y\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#confirm()\u0026lt;CR\u0026gt; 60 cnoremap \u0026lt;C-e\u0026gt; \u0026lt;Cmd\u0026gt;call pum#map#cancel()\u0026lt;CR\u0026gt; 61 62 \u0026#34; Overwrite sources 63 if !exists(\u0026#39;b:prev_buffer_config\u0026#39;) 64 let b:prev_buffer_config = ddc#custom#get_buffer() 65 endif 66 call ddc#custom#patch_buffer(\u0026#39;cmdlinesources\u0026#39;, 67 \\ [\u0026#39;neovim\u0026#39;, \u0026#39;around\u0026#39;]) 68 69 autocmd User DDCCmdlineLeave ++once call CommandlinePost() 70 autocmd InsertEnter \u0026lt;buffer\u0026gt; ++once call CommandlinePost() 71 72 \u0026#34; Enable command line completion 73 call ddc#enable_cmdline_completion() 74endfunction 75 76function! CommandlinePost() abort 77 silent! cunmap \u0026lt;Tab\u0026gt; 78 silent! cunmap \u0026lt;S-Tab\u0026gt; 79 silent! cunmap \u0026lt;C-n\u0026gt; 80 silent! cunmap \u0026lt;C-p\u0026gt; 81 silent! cunmap \u0026lt;C-y\u0026gt; 82 silent! cunmap \u0026lt;C-e\u0026gt; 83 84 \u0026#34; Restore sources 85 if exists(\u0026#39;b:prev_buffer_config\u0026#39;) 86 call ddc#custom#set_buffer(b:prev_buffer_config) 87 unlet b:prev_buffer_config 88 else 89 call ddc#custom#set_buffer({}) 90 endif 91endfunction 92 93call ddc#enable() 実際の自動補完の様子は次のとおりです。\nコマンドラインバッファでの補完表示 インプットモードでの補完表示 lualine.nvim の導入 ステータスバーにもっと多くの情報を表示するため、nvim-lualine/lualine.nvim: A blazing fast and easy to configure neovim statusline plugin written in pure lua. を導入しました。\n設定は公式リポジトリの「Default configuration」とほぼ同じですが、右側の表示のセパレータを  から | に変更し、また、ファイル名の表示をフルパス表示に変更しています。\nIMEの状態を右側に表示しようとしましたが、カーソルを上下移動するたびに画面がちらつくうえ、動作が明らかに重くなったため断念しました。\n1lua \u0026lt;\u0026lt; END 2 require(\u0026#39;lualine\u0026#39;).setup { 3 options = { 4 icons_enabled = true, 5 theme = \u0026#39;nord\u0026#39;, 6 component_separators = { left = \u0026#39;\u0026#39;, right = \u0026#39;|\u0026#39;}, 7 section_separators = { left = \u0026#39;\u0026#39;, right = \u0026#39;\u0026#39;}, 8 disabled_filetypes = { 9 statusline = {}, 10 winbar = {}, 11 }, 12 ignore_focus = {}, 13 always_divide_middle = true, 14 globalstatus = true, 15 refresh = { 16 statusline = 1000, 17 tabline = 1000, 18 winbar = 1000, 19 } 20 }, 21 sections = { 22 lualine_a = {\u0026#39;mode\u0026#39;}, 23 lualine_b = {\u0026#39;branch\u0026#39;, \u0026#39;diff\u0026#39;, \u0026#39;diagnostics\u0026#39;}, 24 lualine_c = {{ \u0026#39;filename\u0026#39;, file_status = true, path = 3 }}, 25 lualine_x = {\u0026#39;encoding\u0026#39;, \u0026#39;fileformat\u0026#39;, \u0026#39;filetype\u0026#39;}, 26 lualine_y = {\u0026#39;progress\u0026#39;}, 27 lualine_z = {\u0026#39;location\u0026#39;} 28 }, 29 inactive_sections = { 30 lualine_a = {}, 31 lualine_b = {}, 32 lualine_c = {\u0026#39;filename\u0026#39;}, 33 lualine_x = {\u0026#39;location\u0026#39;}, 34 lualine_y = {}, 35 lualine_z = {} 36 }, 37 tabline = {},ftjpnの動作状況 38 39 winbar = {}, 40 inactive_winbar = {}, 41 extensions = {} 42 } 43END 44 45\u0026#34; IMEの状態を取得する関数。動作に支障が出るくらい遅くなるため未使用 46function! Get_ime_status() 47 let b:ime_status=system(\u0026#39;spzenhan.exe\u0026#39;) 48 if b:ime_status==1 49 return \u0026#39;IME ON\u0026#39; 50 else 51 return \u0026#39;IME OFF\u0026#39; 52 endif 53endfunction また、lualine.nvim の導入と合わせて、画面を縦分割してもステータスバーを分割しないという設定も行っています。この設定は、設定ファイルに次の設定を追加すれば可能です。\n1set laststatus=3 設定の結果は次のとおりです。\n設定後の lualine.nvim の表示 キーバインド変更 上書き保存などを少しでも簡単にできるようにするため、いくつかのキーバインドを設定しました。\n1\u0026#34; 大文字Ｋでカーソル上のヘルプが見られる設定 2\u0026#34; 日本語ヘルプがあれば日本語版を、無ければ英語版を表示します。 3\u0026#34; 事前に \u0026#39;vim-jp/vimdoc-ja\u0026#39; をインストールする必要があります。 4nnoremap \u0026lt;silent\u0026gt; K :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt; 5function! s:show_documentation() abort 6 if index([\u0026#39;vim\u0026#39;,\u0026#39;help\u0026#39;], \u0026amp;filetype) \u0026gt;= 0 7 try 8 execute \u0026#39;h \u0026#39; . expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) .. \u0026#34;@ja\u0026#34; 9 catch /^Vim\\%((\\a\\+)\\)\\=:E661:/ 10 execute \u0026#39;h \u0026#39; . expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) 11 endtry 12 endif 13endfunction 14 15\u0026#34; qa で全てのバッファを閉じる 16nnoremap qa qall\u0026lt;CR\u0026gt; 17 18\u0026#34; ;w で保存 19nnoremap ;w \u0026lt;Cmd\u0026gt;update\u0026lt;CR\u0026gt; 20 21\u0026#34; ; 2連打でコマンドラインに移動 22nnoremap ;; : 23 24\u0026#34; ノーマルモードで BackSpace による削除を可能にする 25nnoremap \u0026lt;BS\u0026gt; X 設定ファイル分割 最初は init.vim に全ての設定を書いていましたが、可読性に欠けるので次のような形で分割することにしました。\n1nvim 2├── filetype.vim 3├── ftplugin 4│ └── review.vim 5├── init.vim 6├── init.vim.backup 7├── minimal.lua 8└── config_files 9 ├── init 10 │ ├── basic.vim 11 │ ├── clipboard.vim 12 │ ├── IME.vim 13 │ ├── jetpack.vim 14 │ ├── keymapping.vim 15 │ ├── lsp.vim 16 │ └── user_interface.vim 17 └── plugin 18 ├── ddc.vim 19 ├── ddu.vim 20 ├── ftpjn.vim 21 └── lualine.vim そして、この分割したファイルを init.vim の先頭で読み込んでいます。\n1source $HOME/.config/nvim/config_files/init/jetpack.vim 2source $HOME/.config/nvim/config_files/init/basic.vim 3source $HOME/.config/nvim/config_files/init/IME.vim 4source $HOME/.config/nvim/config_files/init/clipboard.vim 5source $HOME/.config/nvim/config_files/init/user_interface.vim 6source $HOME/.config/nvim/config_files/init/keymapping.vim 7source $HOME/.config/nvim/config_files/init/lsp.vim 8source $HOME/.config/nvim/config_files/plugin/ddu.vim 9source $HOME/.config/nvim/config_files/plugin/ddc.vim 10source $HOME/.config/nvim/config_files/plugin/ftpjn.vim 11source $HOME/.config/nvim/config_files/plugin/lualine.vim なお、runtime! config_files/init/*.vim、runtime! config_files/plugins/*.vim の2行を init.vim の先頭に書いて自動的に設定ファイルを読み込む方法を紹介しているサイトがあり、私もその方法を一度採用しましたが、プラグインが機能しなかったため、上記のように愚直に設定ファイルを読み込む方法に変えました。\nRe:VIEWのシンタックスハイライト Re:VIEW は Neovim にデフォルトで登録されているファイルタイプではないため、当然シンタックスハイライトも用意されていません。そのため、シンタックスハイライトは手動で設定する必要があります。\nとはいえ、シンタックスハイライトの設定を公開（tokorom/vim-review: Vim syntax for Re:VIEW）してくださっている方がいますので、その方の設定を拝借することにしました。\n手順は次のとおりです。なお、Re:VIEW のファイルタイプ判定は、上記の「アウトラインバッファの作成」を参照してください。\nまず、.config/nvim/ftplugin/review.vim を作成して、次のコードを記述します。\n1\u0026#34; .config/nvim/ftplugin/review.vim 2setl commentstring=#@#\\ %s 3 4if !exists(\u0026#39;g:vim_review#include_filetypes\u0026#39;) 5 let g:vim_review#include_filetypes = [] 6endif 7 8if !exists(\u0026#39;g:vim_review#include_grouplists\u0026#39;) 9 let g:vim_review#include_grouplists = {} 10 for ft in g:vim_review#include_filetypes 11 let g:vim_review#include_grouplists[ft] = \u0026#39;syntax/\u0026#39; . ft . \u0026#39;.vim\u0026#39; 12 endfor 13endif それから、.config/nvim/syntax/review.vim を作成して次のコードを記述します。\n1\u0026#34; .config/nvim/syntax/review.vim 2\u0026#34; Vim syntax file 3\u0026#34; Language: Re:VIEW 4\u0026#34; Maintainer: Yuta Tokoro \u0026lt;tokorom@gmail.com\u0026gt; 5 6if exists(\u0026#34;b:current_syntax\u0026#34;) 7 finish 8endif 9 10\u0026#34; ---------- 11\u0026#34; syntax 12 13syn case match 14 15syn match reviewHeading contains=reviewInlineCommand,reviewInlineStyleCommand 16 \\ \u0026#34;^=\\+\\%(\\s\\+\\|{\\|\\[\\).*\u0026#34; 17 18syn region reviewInlineCommand oneline 19 \\ start=\u0026#34;@\u0026lt;\\w\\+\u0026gt;{\u0026#34; end=\u0026#34;}\u0026#34; 20syn region reviewInlineStyleCommand transparent oneline 21 \\ matchgroup=reviewInlineCommand 22 \\ start=\u0026#34;@\u0026lt;\\%\\(kw\\|bou\\|ami\\|u\\|b\\|i\\|strong\\|em\\|tt\\|tti\\|ttb\\|code\\|tcy\\)\u0026gt;{\u0026#34; 23 \\ end=\u0026#34;}\u0026#34; 24 25syn region reviewBlockCommand transparent keepend 26 \\ matchgroup=reviewBlockDeclaration start=\u0026#34;^//\\w\\+\\[\\?.*{\\s*$\u0026#34; end=\u0026#34;^//}\\s*$\u0026#34; 27 28syn match reviewBlockCommandWithoutContent 29 \\ \u0026#34;^//\\w\\+\\[.*[^{]\\s*$\u0026#34; 30syn match reviewControlCommand 31 \\ \u0026#34;^//\\\u0026lt;\\%\\(noindent\\|blankline\\|linebreak\\|pagebreak\\)\\\u0026gt;\\s*$\u0026#34; 32 33syn region reviewItemize transparent oneline 34 \\ matchgroup=reviewItemizePrefix start=\u0026#34;^\\s\\+\\*\\+\\s\\+\u0026#34; end=\u0026#34;$\u0026#34; 35syn region reviewOrderedItemize transparent oneline 36 \\ matchgroup=reviewItemizePrefix start=\u0026#34;^\\s\\+[0-9]\\+\\.\\s\\+\u0026#34; end=\u0026#34;$\u0026#34; 37syn region reviewDefinitionList transparent oneline 38 \\ matchgroup=reviewItemizePrefix start=\u0026#34;^\\s\\+\\:\\s\\+\u0026#34; end=\u0026#34;$\u0026#34; 39 40syn match reviewComment contains=reviewTodo 41 \\ \u0026#34;^#@.*\u0026#34; 42syn region reviewCommentBlock keepend contains=reviewTodo 43 \\ start=\u0026#34;^//\\\u0026lt;comment\\\u0026gt;\\[\\?.*{\\s*\u0026#34; end=\u0026#34;^//}\\s*$\u0026#34; 44syn region reviewCommentInline oneline contains=reviewTodo 45 \\ start=\u0026#34;@\u0026lt;comment\u0026gt;{\u0026#34; end=\u0026#34;}\u0026#34; 46 47syn match reviewPreProcCommand 48 \\ \u0026#34;^#@\\\u0026lt;\\%\\(require\\|provide\\)\\\u0026gt;\\s\\+.*\u0026#34; 49syn region reviewPreProcBlockCommand keepend 50 \\ start=\u0026#34;^#@\\\u0026lt;\\%\\(mapfile\\|maprange\\|mapoutput\\)\\\u0026gt;(.*).*\u0026#34; end=\u0026#34;^#@end\\s*$\u0026#34; 51 52syn region reviewWarning oneline 53 \\ matchgroup=reviewPreProcCommand start=\u0026#34;^#@warn(\u0026#34; end=\u0026#34;).*$\u0026#34; 54 55syn case ignore 56syn keyword reviewTodo MARK TODO FIXME contained 57syn case match 58 59\u0026#34; ---------- 60\u0026#34; include other languages 61 62if exists(\u0026#39;g:vim_review#include_grouplists\u0026#39;) 63 let include_grouplists = g:vim_review#include_grouplists 64 let operations = \u0026#39;\\\u0026lt;\\%\\(list\\|listnum\\|emlist\\|emlistnum\\)\\\u0026gt;\u0026#39; 65 66 for ft in keys(include_grouplists) 67 let syntaxfile = include_grouplists[ft] 68 execute \u0026#39;syn include @\u0026#39; . ft . \u0026#39; \u0026#39; . syntaxfile 69 let code_block_region = \u0026#39;start=\u0026#34;^//\u0026#39; . operations . \u0026#39;\\[.*\\[\u0026#39; . ft . \u0026#39;\\]{\\s*$\u0026#34;\u0026#39; 70 \\ . \u0026#39; end=\u0026#34;^//}\\s*$\u0026#34;\u0026#39; 71 let groupname = \u0026#39;reviewCodeBlock_\u0026#39; . ft 72 execute \u0026#39;syn region \u0026#39; . groupname . \u0026#39; keepend contains=@\u0026#39; . ft 73 \\ . \u0026#39; matchgroup=reviewBlockDeclaration\u0026#39; 74 \\ . \u0026#39; \u0026#39; . code_block_region 75 76 if exists(\u0026#39;b:current_syntax\u0026#39;) 77 unlet b:current_syntax 78 endif 79 endfor 80endif 81 82\u0026#34; ---------- 83\u0026#34; highlight 84 85hi def link reviewHeading Conditional 86hi def link reviewInlineCommand Function 87hi def link reviewBlockDeclaration Identifier 88hi def link reviewBlockCommandWithoutContent Identifier 89hi def link reviewControlCommand Identifier 90hi def link reviewItemizePrefix Special 91hi def link reviewComment Comment 92hi def link reviewCommentBlock Comment 93hi def link reviewCommentInline Comment 94hi def link reviewPreProcCommand PreProc 95hi def link reviewPreProcBlockCommand PreProc 96hi def link reviewWarning Underlined 97hi def link reviewTodo Todo 98 99\u0026#34; ---------- 100 101let b:current_syntax = \u0026#34;review\u0026#34; なお、シンタックスハイライトを設定したのに一部のキーワードがハイライトされない場合、テーマの色とバッティングしている可能性があります。私も shaunsingh/nord.nvim: Neovim theme based off of the Nord Color Palette, written in lua with tree sitter support テーマを設定していたところ、一部のキーワードがハイライトされなかったので、テーマの色が邪魔をしているのではないかと疑って別のテーマにしたら全てのキーワードがハイライトされました。\nちなみに、変更後のテーマは protesilaos/tempus-themes: [Mirror] Tempus is a collection of themes for Vim, text editors, and terminal emulators that are compliant at the very least with the WCAG AA accessibility standard for colour contrast の tempus_classic です。\nnoice.nvim の導入 Neovim だとコマンドラインバッファがエディタの下の端にありますが、VSCode だとコマンドパレットがエディタの上半分の区域のちょうど良い場所にポップアップするので、Neovim でも同じような機能が欲しいと思って folke/noice.nvim: 💥 Highly experimental plugin that completely replaces the UI for messages, cmdline and the popupmenu. を導入してみました。\nddc.vim も設定してコマンドライン補完もできるようにしたのですが、入力カーソルが表示されないという問題が発生し、公式リポジトリの Issues にも同じ症状が投稿（Invisible cursor in cmdline popup · Issue #251 · folke/noice.nvim）されていましたので、問題が解消されるまで様子見かなと思い、この後に紹介する VonHeikemen/fine-cmdline.nvim: Enter ex-commands in a nice floating input. に切り替えました。\nところが、作者が「その問題はカラースキーマがカーソルのカラーを提供しないことが原因だ」とコメントしたのを見て、カラースキーマを変えた今なら問題が解消されているかもと思ってプラグインを再び有効化したところ、問題なく入力カーソルが表示されました。そのため、本プラグインを引き続き利用することにしました。\n現在の設定は次のとおりです。公式リポジトリの設定例などを継ぎ接ぎしたもので詳細は勉強中です。noice.vim ファイルで設定しているため、先頭に lua \u0026lt;\u0026lt; END を追加し、末尾に END を追加しています。\n1lua \u0026lt;\u0026lt; END 2require(\u0026#34;noice\u0026#34;).setup({ 3 -- you can enable a preset for easier configuration 4 presets = { 5 bottom_search = false, -- use a classic bottom cmdline for search 6 command_palette = true, -- position the cmdline and popupmenu together 7 long_message_to_split = true, -- long messages will be sent to a split 8 inc_rename = false, -- enables an input dialog for inc-rename.nvim 9 lsp_doc_border = false, -- add a border to hover docs and signature help 10 }, 11 messages = { 12 view_search = \u0026#39;notify\u0026#39;, 13 }, 14 routes = { 15 { 16 view = \u0026#34;notify\u0026#34;, 17 filter = { event = \u0026#34;msg_showmode\u0026#34; }, 18 }, 19 { 20 filter = { 21 event = \u0026#34;notify\u0026#34;, 22 warning = true, 23 find = \u0026#34;failed to run generator.*is not executable\u0026#34;, 24 }, 25 opts = { skip = true }, 26 }, 27 }, 28 cmdline = { 29 enabled = true, 30 menu = \u0026#39;popup\u0026#39;, 31 }, 32 views = { 33 cmdline_popup = { 34 position = { 35 row = 5, 36 col = \u0026#34;50%\u0026#34;, 37 }, 38 size = { 39 width = 60, 40 height = \u0026#34;auto\u0026#34;, 41 }, 42 }, 43 popupmenu = { 44 relative = \u0026#34;editor\u0026#34;, 45 position = { 46 row = 8, 47 col = \u0026#34;50%\u0026#34;, 48 }, 49 size = { 50 width = 60, 51 height = 10, 52 }, 53 border = { 54 style = \u0026#34;rounded\u0026#34;, 55 padding = { 0, 1 }, 56 }, 57 win_options = { 58 cursorline = true, 59 cursorlineopt = \u0026#39;line\u0026#39;, 60 winhighlight = { Normal = \u0026#34;Normal\u0026#34;, FloatBorder = \u0026#34;DiagnosticInfo\u0026#34; }, 61 }, 62 }, 63 }, 64}) 65END 導入したものの廃止したもの fine-cmdline.nvim noice.nvim の使用を一度断念した後、同様の機能を持つプラグインである VonHeikemen/fine-cmdline.nvim: Enter ex-commands in a nice floating input. を使ってみました。\nこちらは入力カーソルが消失するような不具合が無く、ddc.vim による補完もできるのですが、上下キーで履歴を移動する度に画面がちらつく上、動作もキビキビしているとは言い難かったため使用を断念しました。\n参考にしたサイト・情報 vimgrepとQuickfix知らないVimmerはちょっとこっち来い - Qiita Vimファイラの決定版「ddu-ui-filer」設定例を紹介 - アルパカログ Vimで技術書を執筆する環境 with Re:VIEW + RedPen + prh | Spinners Inc. とある PR のおかげで Neovim がもはや VSCode な件について Vimの自動補完プラグイン「ddc.vim」の使い方 vim - Vim起動時にウィンドウ縦分割→右側にファイルを開く方法 - スタック・オーバーフロー 新世代の UI 作成プラグイン ddu.vim 自動補完プラグイン ddc.vim + pum.vim 新世代の UI 作成プラグイン ddu.vim 新世代のファイラー UI ddu-ui-filer cmdheight=0 in neovim Neovimの補完をddc.vim + Built-in LSP へ移行した | ntsk Vimファイラの決定版「ddu-ui-filer」設定例を紹介 - アルパカログ Neovimのコマンドラインや通知がリッチになるnoice.nvim使ってみた | DevelopersIO Vim のヘルプファイル ","link":"http://localhost:1313/post/2022-12-30/","section":"post","tags":["備忘録","Neovim"],"title":"Neovim の設定集（2022年12月30時点）"},{"body":"前置き 昨日の WSL2 + Neovim + VSCode でIME の状態を制御する方法 - 閑古鳥ブログ に続いて WSL2 + Neovim の設定についてメモしていきます。\n今回は、Neovim でヤンクした内容を OS のクリップボードに共有する方法と、OS のクリップボードの内容を Neovim に貼り付ける方法の模索です。\nちなみに、先に申し上げておきますと、今回ご紹介する方法は「現時点では動いている」というものです。色々調べて現在の設定に至っていますが、ある人にとって上手くいく方法が別の人では上手くいかなかったりしているようですので、これからご紹介する方法を真似しても上手くいかないかもしれません。\n方法 win32yank.exe のインストール まず、WSL2 上の Neovim と Windows 側のクリップボードの橋渡しをするアプリが必要なため、公式の FAQ を参考に win32yank.exe をインストールします。\nWindows 側と WSL2 の両方に Neovim をインストールしている場合と WSL2 のみにインストールしている場合で手順が異なりますが、私は WSL2 にのみ Neovim をインストールしているため、次のコマンドで win32yank.exe をインストールしました。\n1curl -sLo/tmp/win32yank.zip https://github.com/equalsraf/win32yank/releases/download/v0.0.4/win32yank-x64.zip 2unzip -p /tmp/win32yank.zip win32yank.exe \u0026gt; /tmp/win32yank.exe 3chmod +x /tmp/win32yank.exe 4sudo mv /tmp/win32yank.exe /usr/local/bin/ init.vim の設定その1 公式の FAQ では、init.vim に set clipboard=unnamedplus を追加すれば Neovim がデフォルトでシステム側のクリップボードを使うようになると書かれています。しかし、私の環境でこの設定を追加すると希望通りの動作にならなかったため、set clipboard=unnamed という設定に変更しました。\nこの set clipboard= の設定は人によって説明がまちまちで、set clipboard=unnamedplus、set cilpboard+=unnamedplus、さらに set clipboard=unnamed にと色々なパターンがあるようです。私の場合、3つ試して set clipboard=unnamed で上手くいきました。\ninit.vim の設定その2 最初は set clipboard=unnamedplus を追加すれば Neovim でヤンクした内容が OS のクリップボードにコピーされましたが、vscode-neovim/vscode-neovim: Vim-mode for VS Code using embedded Neovim をインストールした VSCode では、ヤンクした内容がクリップボードにコピーされませんでした。\nそこで同様の症状に遭遇した人がいるか調べたところ、vscode-neovim の Issues（WSL visual yank to clipboard） で同じ症状に遭遇した人がいて、その方は clip.exe を使う設定を追加して問題を解決していました。\nそれから、win32yank.exe を使う方法を紹介しているこちらの記事 (Neovim on WSL2で、win32yankを導入してクリップボードの共有と遅延問題を解決) と Reddit のこの投稿（Solution! Neovim clipboard with WSL） も発見しましたので、これらの記事で紹介されている設定を追加したところ、VSCode でもヤンクした文字列がクリップボードにコピーされるようになりました。\n以上の設定をまとめると、次のとおりとなります。\n1\u0026#34; ヤンクでWindowsのクリップボードを使う 2set clipboard=unnamed 3let g:clipboard = { 4\\ \u0026#39;name\u0026#39;: \u0026#39;WslClipboard\u0026#39;, 5\\ \u0026#39;copy\u0026#39;: { 6\\ \u0026#39;+\u0026#39;: \u0026#39;win32yank.exe -i --crlf\u0026#39;, 7\\ \u0026#39;*\u0026#39;: \u0026#39;win32yank.exe -i --crlf\u0026#39;, 8\\ }, 9\\ \u0026#39;paste\u0026#39;: { 10\\ \u0026#39;+\u0026#39;: \u0026#39;win32yank.exe -o --lf\u0026#39;, 11\\ \u0026#39;*\u0026#39;: \u0026#39;win32yank.exe -o --lf\u0026#39;, 12\\ }, 13\\ \u0026#39;cache_enabled\u0026#39;: 0, 14\\ } これらの設定を追加することで、ブラウザなどでクリップボードにコピーした内容を Neovim に p キーで貼り付けられるようになりました。\nただし、nvim . コマンドで Neovim を起動すると、なぜか直前にコピーした内容と異なる内容が貼付けされてしまいます。この症状を解消すべく試行錯誤しましたが解決できませんでしたので、現在は nvim コマンドで Neovim を起動するようにしています。\n補足 私が使っている win32yank.exe ですが、公式リポジトリの Issues にはクラッシュなどの報告が結構見受けられます。私の環境でも、WindowsTerminal で Neovim を動かしてコピペして編集していますと、たまに WindowsTerminal がクラッシュしますので、その点は注意が必要だと思います。\n","link":"http://localhost:1313/post/2022-12-12/","section":"post","tags":["備忘録"],"title":"WSL2 + Neovim + VSCode でクリップボードを共有する方法"},{"body":"前置き これまでいくつかのエディタを使ってきましたが、Vim のキーバインドが使えると何かと楽、というよりも Vim のキーバインドに手が慣れているため、思い切って Neovim を使ってみることにしました。\nただ、必要に応じて VSCode も使えるようにしたいので、VSCode のプラグインの vscode-neovim/vscode-neovim: Vim-mode for VS Code using embedded Neovim もインストールして、VSCode と Neovim を統合することにしました。\nそのために現在進行形で色々と設定していますので、備忘録として設定内容をメモしていきます。\n今回実現したいこと インサートモードでの IME の状態を記憶しておいて、ノーマルモードに戻ってから再度インサートモードに入ったときに、従前の IME の状態を復元するというものです。\nつまり、インサートモードで IME をオンにして日本語を編集し、そこから esc キーでノーマルモードに戻ったら IME をオフにしてキー操作に備え、再びインサートモードに入ったら IME の状態を復元（＝IME オン）するというものです。\nこの機能を実現したい理由は、私がエディタで編集する文書の多くが日本語の文章なので、インサートモードで選択した IME の状態を、再びインサートモードに入ったときに復元できると作業効率が大幅にアップするためです。\nノーマルモードに戻ったときに IME を自動的にオフにする方法はすぐに見つかったのですが、インサートモードで選択していた IME の状態を復元する方法は中々見つからなかったため、その方法をメモします。\n環境 1# Powershell 2$ wsl --version 3WSL バージョン: 1.0.3.0 4カーネル バージョン: 5.15.79.1 5WSLg バージョン: 1.0.47 6MSRDC バージョン: 1.2.3575 7Direct3D バージョン: 1.606.4 8DXCore バージョン: 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp 9Windowsバージョン: 10.0.22621.900 1# WSL2 2$ lsb_release -a 3No LSB modules are available. 4Distributor ID: Ubuntu 5Description: Ubuntu 20.04.5 LTS 6Release: 20.04 7Codename: focal 8 9$ nvim --version 10NVIM v0.8.1 11Build type: Release 12LuaJIT 2.1.0-beta3 13Compiled by linuxbrew@43b3775c8372 使った外部ツール Neovim 自体に IME の状態取得や切り替え機能は備わっていませんので、IME の状態取得や切り替えは外部ツールを使う必要があります。\n私が使ったのは kaz399/spzenhan.vim というツールです。このツールは、引数無しで実行すると IME の状態（IME ON → 1, IME OFF → 0）を返し、引数に 1 か 0 を渡すと IME をオン・オフしてくれるというものです。\nこのツールは iuchim/zenhan から Fork して開発されたツールですが、zenhan が備えている IME の切り替え機能に現在の IME の状態を取得する機能が追加されているため、今回採用しました。\n手順 ツールのインストール まず、git clone [git@github.com](mailto:git@github.com):kaz399/spzenhan.vim.git コマンドで spzenhan.vim をインストールします。\nパスの設定 私はシェルに fish を使っているため、 set -Ux fish_user_paths $HOME/spzenhan.vim/zenhan/ $fish_user_paths コマンドでツールへのパスを通しました。これで spzenhan.exe コマンドで IME の状態取得や制御ができるようになります。使用結果は次のとおりです。\n1# IME ON の時 2$ spzenhan.exe 31 4# IME Off の時 5$ spzenhan.exe 60 7 8$ spzenhan.exe 1 # IME Off -\u0026gt; On 9$ spzenhan.exe 0 # IME On -\u0026gt; Off init.vim の設定 以下のコードを init.vim に追加します。\n1\u0026#34; IME制御の設定 2command! ImeOff silent !spzenhan.exe 0 3command! ImeOn silent !spzenhan.exe 1 4 5function! ImeAutoOn() 6 if !exists(\u0026#39;b:ime_status\u0026#39;) 7 let b:ime_status=0 8 endif 9 if b:ime_status==1 10 :silent ImeOn 11 endif 12endfunction 13 14function! ImeAutoOff() 15 let b:ime_status=system(\u0026#39;spzenhan.exe\u0026#39;) 16 :silent ImeOff 17endfunction 18 19\u0026#34; IME off when in insert mode 20augroup InsertHook 21 autocmd! 22 autocmd InsertEnter * call ImeAutoOn() 23 autocmd InsertLeave * call ImeAutoOff() 24augroup END コードの内容を解説しますと、command! で IME のオンオフを切り替える ImeOff と ImeOn というユーザー定義コマンドを作成し、それをインサートモードに入ったとき（autocmd InsertEnter）とインサートモードを抜けるとき（autocmd InsertLeave）に ImeAutoOn(), ImeAutoOff() 関数経由で実行しています。\nImeAutoOff 関数では let b:ime_status=system('spzenhan.exe') で spzenhan.exe を引数無しで実行して IME の状態を取得して変数に格納しています。この変数を ImeAutoOn 関数で使用することで、インサートモードを抜けるときの IME の状態を復元しています。\n参考にしたサイト 【FreeBSD】Vim/Neovimで挿入モード遷移時に前回のIME状態をセットする(uim-fep/fcitx) - HacoLab VSCodeでもnormal移行時に英数IMEに切り替えたい - GitPress.io ","link":"http://localhost:1313/post/2022-12-11/","section":"post","tags":["備忘録"],"title":"WSL2 + Neovim + VSCode でIME の状態を制御する方法"},{"body":"","link":"http://localhost:1313/archives/2022/11/","section":"archives","tags":null,"title":"2022/11"},{"body":"前置き Github でパスワードを用いた HTTPS 接続が 2021年8月13日に廃止されたことに伴い、WSL2 で SSH 接続のための秘密鍵と公開鍵のペアを作成して各種操作に利用していました。\nしかし、WSL2 だけではなく Windows11 でも Github にアクセスする必要が出てきたので、WSL2 で生成した鍵のペアを Windows11 でも使えるようにしました。\nWindows11 or 10 で生成した鍵のペアを WSL2 で使えるようにする方法はいくつか見つかりましたが、その反対の方法を解説したページが見つからなかったため、手順を備忘録として公開します。\n環境 OS: Windows11 Pro (10.0.22621 ビルド 22621)\nGit Bash: mintty 3.6.1 (x86_64-pc-msys) [Windows 22621]\nGit: git version 2.37.3.windows.1\n秘密鍵と公開鍵の保存場所: ~/.ssh/id_ed25519 ~/.ssh/id_ed25519.pub\n手順 Github の公式ガイドに沿って作業を進めていきますが、既に鍵のペアを生成しているため、秘密鍵を ssh-agent に登録するところから作業を開始します。\nまず、ssh-agent を起動するため、Git Bash を起動して eval \u0026quot;$(ssh-agent -s)\u0026quot; コマンドを実行します。ssh-agent が起動すれば Agent pid 59566 という形で PID が返ってきます。\nssh-agent が起動したら、秘密鍵を ssh-agent に登録するため ssh-add ~/.ssh/id_ed25519 コマンドを実行します。\n次に公開鍵を Github に登録するため、公開鍵の内容をクリップボードにコピーします。クリップボードへのコピーは clip \u0026lt; ~/.ssh/id_ed25519.pub コマンドでOKです。\nここまで進んだら github.com にアクセスして右上のアイコンから Settings → SSH and GPG keys と進み、New SSH key をクリックして公開鍵を登録する画面を開きます。\nあとは、Title に適当なタイトルを入力し、Key 欄に先ほどクリップボードにコピーした公開鍵の内容をペーストし、Add SSH key をクリックして公開鍵を Github に登録します。\n最後に、SSH でアクセスできるか確認するため、 ssh -T git@github.com コマンドを実行して「Hi (username)! You've successfully authenticated, but GitHub does not provide shell access.」と表示されれば OK です。\n-—\n参考ページ\nGithub の公式ガイド -\u0026gt; Generating a new SSH key and adding it to the ssh-agent - GitHub Docs\nパスワードを用いた HTTPS 接続停止のアナウンス -\u0026gt; Token authentication requirements for Git operations | The GitHub Blog\n","link":"http://localhost:1313/post/2022-11-20/","section":"post","tags":["備忘録","プログラミング"],"title":"WSL2 で生成した SSH の鍵を Windows11 で使う方法"},{"body":"getopts 備忘録\n1#!/usr/bin/bash 2 3Message() { 4 cat \u0026lt;\u0026lt;- EOF 5This script is change rotation_distance value. 6Usage: sh change_rotation_distance -x 40 -y 39.5 -z 8.4 7 sh change_rotation_distance -y 40 -z 8 8 sh change_rotation_distance -h 9 NG -\u0026gt; sh change_rotation_distance -x -y -z 8.9 10 sh change_rotation_distance -x -40 -y -40 -z 8.9 11EOF 12} 13 14isNumeric() { 15 if expr \u0026#34;$1\u0026#34; : \u0026#34;[0-9]*$\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 || ( expr \u0026#34;$1\u0026#34; : \u0026#34;[0-9]*\\.[0-9]*$\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; [ \u0026#34;$1\u0026#34; != \u0026#34;.\u0026#34; ] );then 16 return_value=0 17 else 18 return_value=1 19 fi 20 return \u0026#34;$return_value\u0026#34; 21} 22 23if [ $# -eq 0 ] 24then 25 Message 26 exit 0 27fi 28 29while getopts x:y:z:h OPT 30do 31 isNumeric \u0026#34;$OPTARG\u0026#34; 32 return_value=$? 33 if [ \u0026#34;$return_value\u0026#34; -eq 1 ] 34 then 35 if [ \u0026#34;$OPT\u0026#34; = \u0026#39;h\u0026#39; ] 36 then 37 Message 38 exit 0 39 elif [ \u0026#34;$OPT\u0026#34; != \u0026#39;?\u0026#39; ] 40 then 41 echo \u0026#34;-${OPT} argument is not a positive number.\u0026#34; 42 Message 43 exit 1 44 fi 45 fi 46 case $OPT in 47 x) x_axis=\u0026#34;$OPTARG\u0026#34; ;; 48 y) y_axis=\u0026#34;$OPTARG\u0026#34; ;; 49 z) z_axis=\u0026#34;$OPTARG\u0026#34; ;; 50 ?) Message 51 exit 1 ;; 52 esac 53done 54 55if [ \u0026#34;${x_axis}\u0026#34; ] 56then 57 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[xX])/\\1 ${x_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 58fi 59 60if [ \u0026#34;${y_axis}\u0026#34; ] 61then 62 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[yY])/\\1 ${y_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 63fi 64 65if [ \u0026#34;${z_axis}\u0026#34; ] 66then 67 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[zZ])/\\1 ${z_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 68fi 引数の数を確認する $# 変数に引数の数が格納されているので、if [ $# -eq 0 ] とすれば引数がゼロ個の場合の処理に分岐できる。\n名前付き引数の引数名と引数の取り出し方 以下のコードでは getopts コマンドのオプション文字列に x:y:z:h と指定することで、このシェルスクリプトの引数として -x -y -z -h という名前付き引数を使えるようにしている。\n1while getopts x:y:z:h OPT 2do 3 if [ \u0026#34;$OPT\u0026#34; = \u0026#39;h\u0026#39; ] 4 then 5 echo \u0026#39;hogehoge\u0026#39; 6 exit 0 7 fi 8 case $OPT in 9 x) x_axis=\u0026#34;$OPTARG\u0026#34; ;; 10 y) y_axis=\u0026#34;$OPTARG\u0026#34; ;; 11 z) z_axis=\u0026#34;$OPTARG\u0026#34; ;; 12 ?) Message 13 exit 1 ;; 14 esac 15done 名前付き引数のうち、 -x -y -z は値を必須とする引数としているため、-x 40 -y 39 -z 8 のような形で値が渡されることになる。渡された値は $OPTARG 変数に格納されているので、上のコードでは x_axis=\u0026quot;$OPTARG\u0026quot; として値を取り出している。\n名前付き引数の一部しか渡されなかった場合の挙動 指定していない名前付き引数が渡された時の挙動 値を必要とする名前付き引数と値を必要としない名前付き引数を同時に指定する方法 値を必須とする名前付き引数を指定するときは、引数の後ろに : を追加すればよいので、getopts x:y:z:h とすれば、xyz は値を必須とする引数に、h は値を必須としない引数として同時に指定することができる。\n引数が数値か否か確認する方法 ","link":"http://localhost:1313/post/2022-10-01/","section":"post","tags":[],"title":"2022 10 01"},{"body":"","link":"http://localhost:1313/archives/2022/09/","section":"archives","tags":null,"title":"2022/09"},{"body":"前置き プリントヘッドの移動に合わせてフィラメントの押出量を調整する Pressure advance 機能を使う場合、必要な設定値を printer.cfg に pressure_advance: 0.045 の形式で設定する必要があります。しかし、この設定値は、フィラメント毎、印刷温度毎に変化しますので、最低でもフィラメントを切り替える都度 printer.cfg を編集する必要が生じます。\nこれは結構面倒ですが、幸い、スライサーの設定を変更することでフィラメント毎に設定値を変更する方法を教えてもらいましたので、備忘録としてまとめます。\nちなみに、教えてもらった場は 3Dプリンタ愛好家の方々が集まっている Discord のサーバーの Klipper_jp で、教えていただいた方は show555（@show555）さん / Twitter です。\n方法 この方法は、PrusaSlicer または SuperSlicer で実施できます。具体的な方法はどちらのスライサーでも同じです。\nまず、それぞれのスライサーの設定画面の「フィラメント設定 (Filament Settings) 」を開き、次に「カスタムGコード (Custom G-code) 」を開きます。そして、「Gコードの最初 (Start G-code) 」に次のコードを追加します。コードを追加したら、このプリセットを保存し、モデルをスライスします。\n1{if physical_printer_preset == \u0026#34;Fluiddpi_Ender3\u0026#34;}SET_PRESSURE_ADVANCE ADVANCE=0.05{endif} 2{if physical_printer_preset == \u0026#34;Prusa MK3S+ with Klipper\u0026#34;}SET_PRESSURE_ADVANCE ADVANCE=0.05{endif} PrusaSlicer の場合 SuperSlicer の場合 このコードの内容は次のとおりです。\nまず、{if physical_printer_preset == \u0026quot;Fluiddpi_Ender3\u0026quot;} の部分は、使うプリンタの名前が Fluiddpi_Ender3 であるかどうかを if 文で判定しています。そして、判定結果が真であれば、SET_PRESSURE_ADVANCE ADVANCE=0.05 Gコードをスライスして生成した Gコードに印刷開始前の部分に埋め込みます。これにより、printer.cfg を編集することなくフィラメントに応じた設定値が印刷に適用されるようになります。最後の {endif} は、if 文終了のコードです。\nここで使うプリンタ名は、「物理プリンターの編集 (Edit phisycal printer) 」の「プリンタの記述的な名前 (Descriptive name for the printer) 」に登録している名前です。\nPrusaSlicer の場合 SuperSlicer の場合 これでモデルをスライスして生成された Gコードに SET_PRESSURE_ADVANCE ADVANCE=0.05 が埋め込まれるようになります。\n1; Don\u0026#39;t change E values below. Excessive value can damage the printer. 2M907 E430 ; set extruder motor current 3G21 ; set units to millimeters 4G90 ; use absolute coordinates 5M83 ; use relative distances for extrusion 6; Filament gcode 7 8SET_PRESSURE_ADVANCE ADVANCE=0.05 \u0026lt;-- 埋め込まれた Gコード 9M107 10;LAYER_CHANGE 11;Z:0.2 12;HEIGHT:0.2 13;BEFORE_LAYER_CHANGE 14G92 E0.0 なお、上記の if 文で登場する physical_printer_preset は、カスタム Gコードの設定で使える Placeholder です。これを使うとプリンタ名に応じて処理を切り替えられるようになります。これ以外にも、以下の公式マニュアルで色々な Placeholder が用意されていることが分かりますので、必要に応じて使い分けると便利だと思います。\nList of placeholders | Prusa Knowledge Base\nまた、if 文の構文などは、以下の公式マニュアルで解説されていますので、こちらも必要に応じて参照してください。\nMacros | Prusa Knowledge Base\n","link":"http://localhost:1313/post/2022-09-19/","section":"post","tags":["3Dプリンタ"],"title":"スライサーの設定で Pressure_advance の設定値を変更する方法"},{"body":"長い前置き 私はキー数が右手側・左手側 24 キーずつの合計 48 キーの自作キーボードを使っているのですが、IME の切り替えは、Windows の標準的なトグル式ではなく、Mac のように IME をオンにするキーとオフにするキーを別々に用意する形にしています。\nこの IME 切り替えキーの置き場所にいつも悩んでいるのですが、一番の希望先は親指周りのキーで、左手側のキーボードには IME オフのキーを、右手側のキーボードには IME オンのキーを割り当てて左右対称のキーマップにして、キーマップを覚えやすくしたいと思っています。\nしかし、私のキーボードは親指周りに 8 キーありますが、ここに Win（左右）, Alt（左右）, Space（左手）, Backspace（右手）, lower（左手）, raise（右手） の 6 種類を割り当てる必要があるため、空きが無い状態となっています。そのため、1 つのキーに一人二役を担わせる必要があるのですが、それができるのは以下のとおり lower/raise キーぐらいという状態です。\nWin 単押しとホールドの両方行うので、二つ目の役割は二連打に割り当てることになる。 Alt 単押しとホールドの両方行うので、二つ目の役割は二連打に割り当てることになる。 Backspace 単押しと連打とホールドを行うので、二つ目の役割を担わせるのは不可能。 Space 単押しと連打とホールドを行うので、二つ目の役割を担わせるのは不可能。 lower ホールドのみなので、単打か二連打に別の処理を割り当て可能。 raise ホールドのみなので、単打か二連打に別の処理を割り当て可能。 そこで lower/raise キーに一人二役を担ってもらうのですが、単打とホールドを同じキーに割り当てる方法は既に編み出されています。\nQMK Firmware で Raise/Lower と変換/無変換を同じキーに割り当てる - Okapies' Archive\n私もこの方法を採用していたのですが、キーボードのキー数が 48 キーなので、記号・数字の入力や矢印キーを使うときに LOWER/RAISE レイヤーに移動する必要があり、その時のタイピングミスでレイヤー移動（ホールド）のつもりが IME 切り替え（単打）になることがちょくちょくありました。これはかなりストレスになるので、やむなくこの方法を断念してコンボ機能を使って JK 同時押しに IME オン、DF 同時押しに IME オフを割り当てていましたが、IME 切り替えのために 2 つのキーを同時押しするのもイマイチという印象を感じていました。\nそうした中、私が最初の翻訳を手掛けたタップダンス機能の解説の中に、1 つのキーに 4 つの機能を持たせるというものがあり、ホールドとダブルタップ（二連打）に別々の処理が割り当てられていたことを思い出しました。\n4つの機能とその入力方法 1回タップ = x を送信 押し続ける = Control を送信 2回タップ = Escape を送信 2回タップして押し続ける = Alt を送信 この方法でホールドにレイヤー移動を割り当ててダブルタップに IME 切り替えを割り当てようと思ったのですが、処理が結構複雑だったので、ホールドと単打の使い分けの方法を応用してもっと処理を簡単にできないかと思い、一応希望する動作を実現できたので、備忘録としてどんな処理にしたのかをまとめます。\n実際のコード ホールドとダブルタップの判定は、キーを押す度に実行される process_record_user 関数の中で実施します。ただし、最初のタップ時に立てるフラグ (first_lower/raise_pressed) とキーを押した時間を格納する変数 (first_lower/raise_pressed_time) は、process_record_user 関数を終了しても状態を保存する必要がありますので、関数の外でグローバル変数として定義しています。\n処理の内容は以下のコードのとおりですが、補足情報をコメントで書き込んでいます。\n1static bool first_lower_pressed = false; 2static uint16_t first_lower_pressed_time = 0; 3static bool first_raise_pressed = false; 4static uint16_t first_raise_pressed_time = 0; 5 6bool process_record_user(uint16_t keycode, keyrecord_t *record) { 7 switch (keycode) { 8 case LOWER: 9 if (record-\u0026gt;event.pressed) { 10 if (!first_lower_pressed) { 11 first_lower_pressed_time = record-\u0026gt;event.time; 12 // 一回目のタップのフラグがオン \u0026amp; 最初のキー押下から2回目のキー押下までの時間が TAPPING_TERM の2倍超なら 13 // 間隔を空けた2回目のタップと判断する 14 } else if (first_lower_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_lower_pressed_time) \u0026gt; TAPPING_TERM * 2)) { 15 first_lower_pressed_time = record-\u0026gt;event.time; 16 first_lower_pressed = false; 17 } 18 layer_on(_LOWER); 19 update_tri_layer(_LOWER, _RAISE, _ADJUST); 20 } else { 21 layer_off(_LOWER); 22 update_tri_layer(_LOWER, _RAISE, _ADJUST); 23 // タップのフラグがオフ \u0026amp; 最初のキー押下からキーを離した時までの時間が TAPPING_TERM 未満なら 24 // タップと判断する 25 if (!first_lower_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_lower_pressed_time) \u0026lt; TAPPING_TERM)) { 26 first_lower_pressed = true; 27 // タップのフラグがオン \u0026amp; 最初のキー押下から2回目のタイプでキーを離した時までの時間が TAPPING_TERM の2倍以下なら 28 // ダブルタップと判断する 29 } else if (first_lower_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_lower_pressed_time) \u0026lt;= TAPPING_TERM * 2)) { 30 tap_code(KC_LANG2); 31 first_lower_pressed = false; 32 } else { 33 first_lower_pressed = false; 34 } 35 } 36 return false; 37 break; 38 case RAISE: 39 if (record-\u0026gt;event.pressed) { 40 if (!first_raise_pressed) { 41 first_raise_pressed_time = record-\u0026gt;event.time; 42 } else if (first_raise_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_raise_pressed_time) \u0026gt; TAPPING_TERM * 2)) { 43 first_raise_pressed_time = record-\u0026gt;event.time; 44 first_raise_pressed = false; 45 } 46 layer_on(_RAISE); 47 update_tri_layer(_LOWER, _RAISE, _ADJUST); 48 } else { 49 layer_off(_RAISE); 50 update_tri_layer(_LOWER, _RAISE, _ADJUST); 51 if (!first_raise_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_raise_pressed_time) \u0026lt; TAPPING_TERM)) { 52 first_raise_pressed = true; 53 } else if (first_raise_pressed \u0026amp;\u0026amp; (TIMER_DIFF_16(record-\u0026gt;event.time, first_raise_pressed_time) \u0026lt;= TAPPING_TERM * 2)) { 54 tap_code(KC_LANG1); 55 first_raise_pressed = false; 56 } else { 57 first_raise_pressed = false; 58 } 59 } 60 return false; 61 break; 62 } 63 first_lower_pressed = false; 64 first_raise_pressed = false; 65 return true; 66} 終わり これで lower/raise キーのホールドにレイヤー移動機能を、ダブルタップに IME 切り替えの機能を持たせることができるようになりました。\nダブルタップに処理を割り当てた場合、タイピングミスでレイヤー移動のつもりが IME 切り替えになってしまうという事態はまず発生しませんので、快適に入力できるようになりました。\n本記事がどなたかの参考になれば幸いです。\n","link":"http://localhost:1313/post/2022-09-05/","section":"post","tags":["自作キーボード"],"title":"QMK Firmware で1つのキーに Hold/Double Tap を割り当てる方法"},{"body":"以前PrusaSlicer/SuperSlicer で 一定のレイヤー毎に設定を変更する方法 という記事を書いたのですが、執筆後に色々調べたところ、SuperSlicer だとより簡単に、かつリトラクト長も変えられることが分かりましたので、その方法を紹介します。\n大まかな作業の流れ モデルをスライスして、設定を変更したい箇所の高さの範囲を確認する 右側の設定画面で「Height range Modifier」をクリック 設定画面下側に設定を変更する高さの範囲を入力する画面が表示されるので、設定を変更したい高さの範囲を入力する。 「Range 0.00-2.00 (mm)」という形で設定を変更する高さ範囲が表示されるので、その範囲の右側の歯車アイコンをクリックして変更したい項目を選ぶ。 設定を変更したい高さ範囲を追加する場合、3番目に戻って作業を繰り返す 実際のモデルを使った方法（温度変更） ここからは実際のモデルを使って手順を説明します。使うモデルは Teaching Tech 3D Printer Calibration で配布されているモデルで、高さによって印刷温度を変えて印刷することで、一回の印刷で複数の温度設定を確認できるものです。\nまず、モデルをスライスして、右側のバーで高さに応じた印刷状況を確認できるようにします。\nそれから、右側のバーを上下に動かして、温度を切り替える高さを決定します。ここでは、最初に温度を切り替える高さを9.00mmにしています。\n再び同様に右側のバーを動かして2番目、3番目……に温度を切り替える高さを決定していきます。その結果、次のとおり温度を切り替える高さを決定しました。\nこれで高さの調査ができましたので、次は右側の設定画面で「Height range Modifier」をクリックして設定を変更する高さの範囲を入力していきます。\n高さの範囲の設定が完了したら、次はそれぞれの高さの範囲毎に温度を設定します。\nそれぞれの高さの範囲の右側にある歯車のアイコンをクリックすると設定変更が可能な項目が表示されますので、「Add settings」→「Filament」の順番で選択します\nそうすると変更可能なフィラメント設定が表示されますので、「Temperature」にチェックを付けて「Apply」をクリックします。\n右側の設定画面に追加された「Filament」をクリックすると下側に温度を入力する画面が表示されますので、設定したい温度（ここでは260℃）を入力します。あとは同じ作業をそれぞれの高さ範囲について実施します。\nこれでそれぞれの高さ範囲について印刷温度を変更することができましたので、再度スライスします。スライス後に「Gcode Preview」の「View」を「Temperature」にすると、設定した高さ範囲によって印刷温度が変更されていることが分かります。\n実際のモデルを使った方法（リトラクト長の変更） 以上で紹介した方法と同様の方法で、高さに応じてリトラクト長を変更することが可能です。\n作業手順は、上記の手順のうち「Add settings」→「Filament」の順番で選択するところまで同じです。\n変更可能なフィラメント設定が表示されたら、今度は「Retraction length」にチェックを付けて「Apply」をクリックします。\nそうすると右側の設定画面の下側にリトラクト長を入力する画面が表示されますので、設定したい長さを入力します。あとは同じ作業をそれぞれの高さ範囲について実施します。\nこれで、一度の印刷で複数のリトラクト長を試せるようになります。\n","link":"http://localhost:1313/post/2022-09-03/","section":"post","tags":["3Dプリンタ"],"title":"SuperSlicer で 一定の高さ毎に温度やリトラクト長を変える方法"},{"body":"","link":"http://localhost:1313/archives/2022/08/","section":"archives","tags":null,"title":"2022/08"},{"body":"前置き 2022年8月18日に3Dプリンタユーザーが集まっている Discord のサーバーの klipper_jp で「GCode をスタートボタンを押して1行ずつ実行する方法はないか」という質問がありました。\nそこで、1行ずつ実行する方法を調べたのですが、その過程でレイヤー切り替え毎に手動で一時停止・印刷再開を行う方法を編み出せましたので、誰かの参考になればと思い方法をまとめました。\n必要な手順の概要 printer.cfg に save_variables セクションを追加して一時停止フラグを格納するファイルのファイル名を指定する SAVE_VARIABLE マクロを使って一時停止フラグのオン・オフを切り替えるマクロを printer.cfg に追加する PAUSE マクロと RESUME マクロを定義する（定義済みならこの作業は不要） 一時停止フラグの状態に応じて PAUSE マクロを実行するマクロを追加する 実際のコード 1#printer.cfg 2 3[gcode_macro PAUSE] 4rename_existing: BASE_PAUSE 5gcode: 6 SAVE_GCODE_STATE NAME=PAUSE_state 7 BASE_PAUSE 8 G91 9 G1 E-0.5 F100 10 G1 Z5 11 G90 12 #G1 X{X} Y{Y} F6000 13 14[gcode_macro RESUME] 15rename_existing: BASE_RESUME 16gcode: 17 G91 18 G1 E0.5 F100 19 G90 20 RESTORE_GCODE_STATE NAME=PAUSE_state MOVE=1 21 BASE_RESUME 22 23[gcode_macro PAUSE_FLAG_OFF] 24gcode: 25 SAVE_VARIABLE VARIABLE=pause_flag VALUE=0 26 27[gcode_macro PAUSE_FLAG_ON] 28gcode: 29 SAVE_VARIABLE VARIABLE=pause_flag VALUE=1 30 31[gcode_macro ECHO_PAUSE_FLAG] 32gcode: 33 RESPOND MSG=\u0026#34;PAUSE_FLAG is {printer.save_variables.variables.pause_flag}\u0026#34; 34 35[gcode_macro STEP_BY_STEP_PRINT] 36description: Controls step-by-step printing, pausing at each layer 37gcode: 38 {% if printer.save_variables.variables.pause_flag == 1 %} 39 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG ON\u0026#34; 40 PAUSE 41 {% else %} 42 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG OFF\u0026#34; 43 {% endif %} 44 45[save_variables] 46filename: ~/variables.cfg 各処理の説明 一時停止フラグの準備 フラグの格納場所 スライサーで作成した GCode にグローバル変数を埋め込むことはできないので、一時停止フラグは、Raspberry Pi のローカルファイルに格納します。\nKlipper 独自の GCode には、変数をローカルファイルに書き込むSAVE_VARIABLE というマクロが用意されており、ここで格納した変数は printer.save_variables.variables.変数名 で呼び出せます。\nこのマクロを使うには、printer.cfg にsave_variables セクションを追加し、変数を書き込むファイルを filename: ~/variables.cfg と指定する必要があります（ファイル名は任意の名前でOKだと思います）。\n1[save_variables] 2filename: ~/variables.cfg フラグの切り替え フラグを格納する場所を指定しましたので、次は SAVE_VARIABLE マクロを使ってフラグを立てるマクロとフラグを下ろすマクロを次のとおり作成します。なお、フラグの名前は pause_flag としています。\n1[gcode_macro PAUSE_FLAG_ON] 2gcode: 3 SAVE_VARIABLE VARIABLE=pause_flag VALUE=1 4 5[gcode_macro PAUSE_FLAG_OFF] 6gcode: 7 SAVE_VARIABLE VARIABLE=pause_flag VALUE=0 また、現在のフラグの状態を表示するマクロがあると便利なので、そちらも用意します。\n1[gcode_macro ECHO_PAUSE_FLAG] 2gcode: 3 RESPOND MSG=\u0026#34;PAUSE_FLAG is {printer.save_variables.variables.pause_flag}\u0026#34; ここでは、引数で渡されたメッセージをコンソールに出力するRESPOND マクロを使って現在のフラグの状態をコンソールに出力しています。現在のフラグの状態は printer.save_variables.variables.pause_flag で確認できますので、{...} で囲んでメッセージに埋め込んでいます。\nなお、変数を {...} で囲む理由は、Klipper のドキュメントで次のように説明されているためです。\nTemplate expansion\nThe gcode_macro gcode: config section is evaluated using the Jinja2 template language. One can evaluate expressions at run-time by wrapping them in { } characters or use conditional statements wrapped in {% %}. See the Jinja2 documentation for further information on the syntax.\njinja2 で変数展開するには {...} ではなく {{...}} で囲むはずなのですが、Klipper のマクロでは {...} で囲めば変数が展開されると書かれていますので、それに従ってコードを書いています。\n一時停止フラグの状態に応じた条件分岐 これで一時停止フラグを切り替えられるようになりましたので、一時停止フラグの状態に応じて一時停止するか通常通り印刷するかの条件分岐を行うマクロを追加します。\nマクロの gcode: セクションで条件分岐する場合、if 文は {% ... %} で囲みますので、コードは次のとおりとなります。\n1[gcode_macro STEP_BY_STEP_PRINT] 2gcode: 3 {% if printer.save_variables.variables.pause_flag == 1 %} 4 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG ON\u0026#34; 5 PAUSE 6 {% else %} 7 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG OFF\u0026#34; 8 {% endif %} {% if printer.save_variables.variables.pause_flag == 1 %} でフラグが立っているか確認し、フラグが立っていれば PAUSE マクロを実行しています。\nこれで printer.cfg 側で行う準備は完了です。\nスライサー側の設定 PrusaSlicer/SuperSlicer の「Printer Settings」の「Custom G-code」の「Before layer change g-code」に PAUSE_FLAG_OFF と STEP_BY_STEP_PRINT マクロを追加します。PAUSE_FLAG_OFF マクロも追加するのは、意図しない一時停止を発生させないためです。\n1;BEFORE_LAYER_CHANGE 2;[layer_z] 3PAUSE_FLAG_OFF 4STEP_BY_STEP_PRINT これで STL ファイルをスライスするだけでレイヤー切り替え直前に一時停止するかどうかの条件分岐が行われるようになりました。また、printer.cfg にマクロを設定したことにより、Mainsail の Macros タブに PAUSE_FLAG_ON、PAUSE_FLAG_OFF ボタンが追加されていますので、この2つのボタンでフラグを切り替えて印刷を制御します。\nMacros のボタン この2つのボタンを使って印刷を制御している様子を動画にしていますので、よろしければご覧ください。\n以上で説明は完了です。\n補足 フラグを立てる処理で SAVE_VARIABLE VARIABLE=pause_flag VALUE=1 というコードを実行していますが、条件分岐では変数の値だけでなく型もチェックされているようですので、 SAVE_VARIABLE VARIABLE=pause_flag VALUE=1 を実行してから次のマクロを実行した場合、コンソールには PAUSE_FLAG is numeric 1 が表示されます。\n1[gcode_macro TEST] 2gcode: 3 {% if printer.save_variables.variables.pause_flag == \u0026#39;1\u0026#39; %} 4 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG is string \u0026#39;1\u0026#39;\u0026#34; 5 {% endif %} 6 {% if printer.save_variables.variables.pause_flag == 1 %} 7 RESPOND TYPE=command MSG=\u0026#34;PAUSE_FLAG is numeric 1\u0026#34; 8 {% endif %} また、 SAVE_VARIABLE マクロを使った変数のローカルファイルへの格納は、実行してから保存されるまで若干のタイムラグがあるようです。pause_flag の値が 0 の状態で次のコードを実行すると、コンソールに表示される値は 1 ではなく 0 になりました。\n1[gcode_macro PAUSE_FLAG_ON] 2gcode: 3 SAVE_VARIABLE VARIABLE=pause_flag VALUE=1 4 RESPOND MSG=\u0026#34;PAUSE_FLAG is {printer.save_variables.variables.pause_flag}\u0026#34; そのため、SAVE_VARIABLE マクロを実行した直後に条件分岐のコードを追加した場合、意図した動作にならない可能性があります。\n","link":"http://localhost:1313/post/2022-08-31/","section":"post","tags":["3Dプリンタ","Klipper","Mainsail"],"title":"Klipper のマクロを使って Step by step 印刷を実現する方法"},{"body":"","link":"http://localhost:1313/tags/mainsail/","section":"tags","tags":null,"title":"Mainsail"},{"body":"追記事項（2022年9月30日） この記事を公開した時に、\nそこで rotation_distance の設定値を引数として渡すと printer.cfg の設定値を変更するシェルスクリプトは作成したのですが、これを Mainsail の CONSOLE から実行する方法が分からないため、この点は現在保留中です。正確に言うと、Mainsail の CONSOLE で複数の引数を渡す方法が分からない（できない？）ため、保留にしています。\nと書いていましたが、このたび、Mainsail の Console から rotation_distance の設定値を変更することに成功しましたので、その方法を末尾にまとめました。\n前置き Klipper の設定項目の1つである rotation_distance は、ステッピングモーターが1回転した時の移動量を指定するものですが、フィラメント毎に調整しないと印刷物の大きさが微妙に変わってしまうため、新しいフィラメントを使う度に調整が必要になります。しかし、G-Code で設定できる pressure_advance とは異なり、 rotation_distance を調整するには毎回次の作業が必要になります。\nprinter.cfg ファイルの現在の設定値を確認 印刷物のサイズを測る 実測値と現在の設定値を基に新しい設定値を計算 新しい設定値を printer.cfg ファイルに追加 Klipper 再起動という このうち、新しい設定値の計算については、印刷物の実測値と現在の設定値から自動的に計算できるツールを作成しているので特に面倒な作業ではないのですが、現在の設定値を確認するには、Mainsail の MACHINE タブで printer.cfg ファイルを開いてスクロールしながら目視で確認するか、SSH で Raspberry Pi にアクセスして cat klipper_config/printer.cfg | grep ^rotation_distance コマンドを実行する必要があり、正直言って面倒な作業でした。\nそこで、現在の設定値を簡単に確認できる方法を探していたところ、Mainsail で任意のシェルコマンドを実行できる方法が見つかったため、早速試したところ上手くいきましたので、その方法をまとめました。\n大まかな処理の流れ KIAUH のプラグインである G-Code Shell Command Extension をインストール rotaton_distance を確認するためのシェルスクリプト ( ~/get_rotation_distance.sh ) を作成して実行権限を追加 printer.cfg に上記のシェルスクリプトを実行する GCode を追加 Klipper を再起動 Mainsail の Console で RUN_SHELL_COMMAND CMD=get_rotation_distance を実行 Console に rotation_distance の設定が表示される 1# eSun Silk PLA 2rotation_distance: 32.14 3-- 4# eSun Silk PLA 5rotation_distance: 32.07 6-- 7# eSun Silk PLA 8rotation_distance: 8.09 9-- 10enable_pin: !PA4 11rotation_distance: 21.77 各手順の説明（rotation_distance の確認） G-Code Shell Command Extension のインストール G-Code Shell Command Extension は、Mainsail の Console からシェルコマンドを実行できるようにする KIAUH のプラグインです。\nインストール方法は次のとおりです。なお、KIAUH が既にインストールされていることを前提にしています。KIAUH をインストールしていない場合、th33xitus/kiauh: Klipper Installation And Update Helper を参照してインストールしてください。\nSSH で Raspberry Pi にアクセスします kiauh/kiauh.sh コマンドで KIAUH を起動します Main Menu で 4) [Advanced] を選択します Advanced Menu で 8) [G-Code Shell Command] を選択します いくつかの質問に Y を回答するとインストールされます シェルスクリプトの作成 G-Code Shell Command をインストールしたら、次は rotation_distance を確認するためのシェルスクリプトを作成します。\nシェルスクリプトの保存場所はどこでもOKなので、以下のコードのスクリプトを ~/get_rotation_distance.sh で作成しています。スクリプトを作成したら chmod 777 ~/get_rotation_distance.sh で実行権限を追加します。\n1#!/bin/bash 2cat ~/klipper/printer.cfg | grep --before-context=1 ^rotation_distance なお、直前の１行を出力しているのは、私の printer.cfg では rotation_distance をフィラメント毎に設定しており、設定値の1行前にフィラメント名を記載しているためです。\n1# printer.cfg 2 3# Tinmorry MATT PLA 4rotation_distance: 40.153 5# Polymaker ABS 6#rotation_distance: 40.252 7... printer.cfg の設定 上記のシェルスクリプトを Mainsail の Console から実行できるようにするため、printer.cfg に次の設定を追加します。設定は公式ページの設定例を参考にしています。\n1[gcode_shell_command GET_rotation_distance] 2 command: sh /home/pi/get_rotation_distance.sh 3 timeout: 30. 4 verbose: True printer.cfg を編集したら次のいずれかの方法で Klipper を再起動します。\nMainsail の DASHBOARD の右上の電源ボタンから Klipper の再起動を選択する SSH でアクセスしている Raspberry Pi で sudo systemctl restart klipper.service を実行する こうすると Console で RUN_SHELL_COMMAND CMD=get_rotation_distance と入力すると rotation_distance の設定値を確認できるようになります。\n1# eSun Silk PLA 2rotation_distance: 32.14 3-- 4# eSun Silk PLA 5rotation_distance: 32.07 6-- 7# eSun Silk PLA 8rotation_distance: 8.09 9-- 10enable_pin: !PA4 11rotation_distance: 21.77 rotation_distance の修正 2022年9月30日加筆修正\n上記の方法で rotation_distance の設定値を確認することはできますが、もう一歩進めて設定値の修正までできるようになるとさらに楽になります。\nそこで rotation_distance の設定値を引数として渡すと printer.cfg の設定値を変更するシェルスクリプトは作成したのですが、これを Mainsail の CONSOLE から実行する方法が分からないため、この点は現在保留中です。正確に言うと、Mainsail の CONSOLE で複数の引数を渡す方法が分からない（できない？）ため、保留にしています。\nとりあえず KIAUH の Issues で複数パラメーターを渡せる機能を追加して欲しいと要望していますので、機能が実装されるのを待つか、現時点でも可能であればその方法も追記しようと思います。\nなお、シェルスクリプトのコードは次のとおりです。前提として、 rotation_distance を設定している行に、コメントで XYZ 軸の区別ができるようにするためのコメントを挿入しています。\nそのため、まず rotation_distance の設定値を引数として渡したら printer.cfg の内容を書き換えるシェルスクリプト（~/ change_rotation_distance.sh）を作成しました。ある程度のエラーには対応できるように作成していますが、もし不具合がありましたらコメント欄で教えてください。\n1#!/usr/bin/bash 2 3Message() { 4 cat \u0026lt;\u0026lt;- EOF 5This script is change rotation_distance value. 6Usage: sh change_rotation_distance -x 40 -y 39.5 -z 8.4 7 sh change_rotation_distance -y 40 -z 8 8 sh change_rotation_distance -h 9 NG -\u0026gt; sh change_rotation_distance -x -y -z 8.9 10 sh change_rotation_distance -x -40 -y -40 -z 8.9 11EOF 12} 13 14isNumeric() { 15 if expr \u0026#34;$1\u0026#34; : \u0026#34;[0-9]*$\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 || ( expr \u0026#34;$1\u0026#34; : \u0026#34;[0-9]*\\.[0-9]*$\u0026#34; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; [ \u0026#34;$1\u0026#34; != \u0026#34;.\u0026#34; ] );then 16 return_value=0 17 else 18 return_value=1 19 fi 20 return \u0026#34;$return_value\u0026#34; 21} 22 23if [ $# -eq 0 ] 24then 25 Message 26 exit 0 27fi 28 29while getopts x:y:z:h OPT 30do 31 isNumeric \u0026#34;$OPTARG\u0026#34; 32 return_value=$? 33 if [ \u0026#34;$return_value\u0026#34; -eq 1 ] 34 then 35 if [ \u0026#34;$OPT\u0026#34; = \u0026#39;h\u0026#39; ] 36 then 37 Message 38 exit 0 39 elif [ \u0026#34;$OPT\u0026#34; != \u0026#39;?\u0026#39; ] 40 then 41 echo \u0026#34;-${OPT} argument is not a positive number.\u0026#34; 42 Message 43 exit 1 44 fi 45 fi 46 case $OPT in 47 x) x_axis=\u0026#34;$OPTARG\u0026#34; ;; 48 y) y_axis=\u0026#34;$OPTARG\u0026#34; ;; 49 z) z_axis=\u0026#34;$OPTARG\u0026#34; ;; 50 ?) Message 51 exit 1 ;; 52 esac 53done 54 55if [ \u0026#34;${x_axis}\u0026#34; ] 56then 57 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[xX])/\\1 ${x_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 58fi 59 60if [ \u0026#34;${y_axis}\u0026#34; ] 61then 62 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[yY])/\\1 ${y_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 63fi 64 65if [ \u0026#34;${z_axis}\u0026#34; ] 66then 67 sed -E \u0026#34;s/^(rotation_distance:)\\s?[0-9]+\\.?[0-9]+(.+#\\s?[zZ])/\\1 ${z_axis}\\2/\u0026#34; -i $HOME/klipper_config/printer.cfg 68fi あわせて、printer.cfg に4つある rotation_distance について、どれが XYZ 軸の値なのかを示すコメントを追加して、sed コマンドの検索パターンで指定できるようにしました。\n1# printer.cfg 2 3[stepper_x] 4rotation_distance: 32.14 # x_axis 5[stepper_y] 6rotation_distance: 32.07 # y_axis 7[stepper_z] 8rotation_distance: 8.09 # z_axis sh change_rotation_distance.sh -x 32.14 -y 32.07 -z 8.09 の形で rotation_distance の設定を引数として渡します。\nそれから、このシェルスクリプトを Mainsail の Console から実行するためのマクロを作成します。このマクロのコードは、KIAUH の Issues で私が「複数パラメーターを渡せる機能を追加して欲しい」と要望したのに対し、「この方法を試してほしい」と回答していただいたものをほぼコピーしています。\n1# printer.cfg 2 3[gcode_shell_command change_rotation_distance] 4command: sh /home/pi/change_rotation_distance.sh 5timeout: 30. 6verbose: True 7 8[gcode_macro change_rotation_distance] 9gcode: 10 # Set the X, Y, Z variables up here. Assuming that the default is None 11 {% set param_data = [] %} 12 13 # If variable is None, ignore and don\u0026#39;t add it to param_data list 14 {% if X is not none %} 15 {% set param_data = param_data + [\u0026#39;-x \u0026#39; + X] %} 16 {% endif %} 17 {% if Y is not none %} 18 {% set param_data = param_data + [\u0026#39;-y \u0026#39; + Y] %} 19 {% endif %} 20 {% if Z is not none %} 21 {% set param_data = param_data + [\u0026#39;-z \u0026#39; + Z] %} 22 {% endif %} 23 24 # Join param_data with a space 25 {% set param_data = \u0026#39; \u0026#39;.join(param_data) %} 26 27 RUN_SHELL_COMMAND CMD=change_rotation_distance PARAMS=\u0026#34;{pass_data}\u0026#34; 28 # Note the quotation marks around the pass_data. Without them, Klipper will attempt (and fail) to interpret each word in the params マクロを作成したら Klipper を再起動して読み込ませます。そして、Mainsail の Console に次のコマンドを入力して実行します。このとき、シェルスクリプトに渡す引数をシングルクォーテーション（'）で囲む必要があります。\nRUN_SHELL_COMMAND CMD=change_rotation_distance PARAMS='-x 31.644 -y 31.574 -z 8.042'\nこのコマンドを実行すると Running Command {change_rotation_distance}...: と表示されてシェルスクリプトが実行され、少し待つと Command {change_rotation_distance} finished と実行完了の通知が表示されます。\n実際に rotation_distance の設定値が変更されたか確認するため、Mainsail の Console に RUN_SHELL_COMMAND CMD=get_rotation_distance と入力して実行すると、rotation_distance の設定値が変更されていることが確認できます。\n実行結果 ","link":"http://localhost:1313/post/2022-08-20/","section":"post","tags":["3Dプリンタ","Klipper","Mainsail"],"title":"Mainsail から rotation_distance を確認・変更する方法"},{"body":"前置き QMK Firmware は US 配列を前提にしたファームウェアなので、OS のキーボード配列を US キーボードにして US キーキャップを使う場合は、言語関係の問題は生じません。\nしかし、OS のキーボード配列を JIS キーボードに設定すると、途端に言語関係の問題が生じます。対応方法は、US キーキャップを使う場合と JIS キーキャップを使う場合でそれぞれ違いますので、それぞれのパターンについて紹介したいと思います。\ntl,dl JIS キーキャップを使う場合 qmk_firmware/keymap_japanese.h at master · qmk/qmk_firmware を keymap.c の先頭で #include\u0026quot;keymap_jp.h\u0026quot; して読み込んだ上で、KC_* の代わりに JP_* キーを使います。 US キーキャップを使う場合 この場合の方法は、次の2つです。 方法1 koktoh/jtu_custom_keycodes: Keycodes to use jis keycode in us keymap を使い、個別に対応が必要なキーを JU_* キーに置き換えます。\nただし、! や ( のように Shift キーを押しながら入力する記号類を直接入力する場合（例えば、Raise レイヤーで Q を押したら ! が入力されるといったものです。）、qmk_firmware/keymap_japanese.h at master · qmk/qmk_firmware を使って JP_EXLM 等の形で指定する必要があります。1\n方法2 Version 0.14.0 で導入された Key Overrides 機能と JP_* キー を組み合わせてキーの挙動を変更するという方法です。\nQMK Breaking Changes - 2021 August 28 Changelog\n一見すると回りくどい方法ですが、JU_* キーはキーリピートが効かないのに対し、この方法で設定したキーはキーリピートが効きますので、普通のキーの挙動に可能な限り近づけることができます。\n解説 追加ライブラリまたは設定が必要な理由 keymap.c で KC_A と指定したキーをタイプした時、キーボードから PC に送信されるデータは A という文字に応じたキーコードです。そして、OS は受け取ったキーコードに応じた文字をアプリケーションに渡します。2\n問題は、このキーコードと文字の対応関係が言語によって異なっており、例えば、[ に当たる KC_LBRC のキーコードを送信しても、OS のキーボード配列が JIS になっていると OSは = を返してしまいます。\nこのような取り違えが生じるキーがいくつかありますので、OS のキーボード配列を JIS にした状態でキーキャップの印字通りに入力したい場合、何らかの変換処理が必要となります。\n上記で紹介した qmk_firmware/keymap_japanese.h at master · qmk/qmk_firmware と koktoh/jtu_custom_keycodes: Keycodes to use jis keycode in us keymap を使う方法は、ライブラリに変換処理を任せる方法で、Key Overrides を使う方法は自力で変換処理を行うという方法です。\n実装 ここからは具体的な実装を紹介していきます。なお、OS のキーボード配列が JIS 配列になっていることが前提です。\nJIS キーキャップを使う場合 qmk_firmware/keymap_japanese.h at master · qmk/qmk_firmware を keymap.c の先頭で #include\u0026quot;keymap_jp.h\u0026quot; して読み込んで、KC_* の代わりに JP_* キーを使います。\n以下のキーマップは、OS のキーボード配列とキーキャップを JIS にする前提で設計された 自作キーボードキット『JISplit89』ビルドガイド - 自作キーボード温泉街の歩き方 のデフォルトキーマップですが、JIS キーキャップ独自のキー（下の図の赤枠のキー）のキーコードに JP_* キーコードを指定しています。\nqmk_firmware/keyboards/salicylic_acid3/jisplit89 at master · qmk/qmk_firmware より 1[_QWERTY] = LAYOUT( 2 //,-----------------------------------------------------| |--------------------------------------------------------------------------------. 3 KC_ESC, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_INS, KC_PSCR, 4 //|--------+--------+--------+--------+--------+--------| |--------+--------+--------+--------+--------+--------+--------+--------+--------| 5 LT(_ADJUST,KC_ZKHK),KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, JP_MINS, JP_CIRC, JP_YEN, KC_BSPC, KC_DEL, 6 //|--------+--------+--------+--------+--------+--------| |--------+--------+--------+--------+--------+--------+--------+--------+--------| 7 KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, JP_AT, JP_LBRC, KC_ENT, KC_HOME, 8 //|--------+--------+--------+--------+--------+--------| |--------+--------+--------+--------+--------+--------+--------+--------+--------| 9 KC_CAPS, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, JP_SCLN, JP_COLN, JP_RBRC, KC_END, 10 //|--------+--------+--------+--------+--------+--------| |--------+--------+--------+--------+--------+--------+--------+--------+--------| 11 KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, JP_BSLS, KC_PGDN, KC_UP, KC_PGUP, 12 //|--------+--------+--------+--------+--------+--------| |--------+--------+--------+--------+--------+--------+--------+--------+--------| 13 KC_LCTRL, KC_LGUI, KC_LALT, KC_MHEN, KC_SPC, KC_SPC, KC_SPC, KC_SPC, KC_HENK, KC_KANA, KC_APP, KC_LEFT, KC_DOWN,KC_RIGHT 14 //`-----------------------------------------------------| |--------------------------------------------------------------------------------\u0026#39; 15), このように、JIS キーキャップと US キーキャップで印字が異なるキーについて、JP_* キーコードを使用して違いを吸収しています。\nUS キーキャップを使う場合 JU_* を使う場合 koktoh/jtu_custom_keycodes: Keycodes to use jis keycode in us keymap を使い、; や ' のように Shift キーを使わなくてもキーキャップの印字通りに入力されないキーや、Shift キーを使った場合に印字通りに入力されない 2 や 6 について、JU_* キーを使って違いを吸収しています。\nKeyboard Layout Editor で作成 1[_QWERTY] = LAYOUT( 2 KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, JU_GRV, \\ 3 KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, JU_SCLN, JU_QUOT, \\ 4), 5[_LOWER] = LAYOUT( \\ 6 KC_1, JU_2, KC_3, KC_4, KC_5, JU_6, JU_7, JU_8, JU_9, JU_0, JU_BSLS, \\ 7 KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, JU_MINS, JU_EQL, JU_LBRC, JU_RBRC, _______, \\ 8), なお、JU_* キーを使う場合、ライブラリとして読み込む方法とコードをコピペして使う方法の2つがあります。jtu_custom_keycodes/default/README.md に手順が記載されていますので、そちらを確認して実装します。\nKey Overrides を使う方法 Key Overrides の詳細は、QMK Firmware の公式ドキュメントの暫定日本語訳 で確認できますが、この機能を簡単に説明すると、修飾キーとキーの組み合わせを上書きして別のキーを送信できるようにするというものです。PC に送信するキーコード自体を変更できますので、US と JIS の違いを吸収するのにうってつけの機能となります。\n例えば、OS のキーボード配列が JIS だと Shift + 2 は \u0026quot; と解釈されますが、Key Overrides を使うと Shift + 2 を JP_AT に変換して PC に送信できますので、Shift + 2 を押して @ を表示させるということができるようになります。このように修飾キーとキーの組み合わせを上書きすることで、US キーキャップの印字通りの入力を実現できるようになります。\nここから具体的なコードを示しますが、まず、Key Overrides を使うには rules.mk に KEY_OVERRIDE_ENABLE = yes を追加する必要があります。\n1KEY_OVERRIDE_ENABLE = yes 次に、keymap.c に Key Overrides の対象となるキーの組み合わせなどを定義した key_override_t 構造体を初期化します。\n1// `shift + \u0026#39;` を上書きして `\u0026#34;` を送信する 2const key_override_t JP_QUOT_key_override = 3 ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_QUOT, S(KC_2), ~0, MOD_MASK_CAG); 4 5// `shift + 2` を上書きして `@` を送信する 6const key_override_t KC_2_key_override = 7 ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_2, KC_LBRC, ~0, MOD_MASK_CAG); 初期化で使っている ko_make_with_layers_and_negmods 初期化子は、最もオプションが多い初期化子で、Key Overrides を使うレイヤーや押してはいけない修飾キーを指定できます。1つ目の設定に指定している引数の内容は次のとおりです。\nMOD_MASK_SHIFT Key Overrides を使うために押す必要がある修飾キーに Shift キーを指定しています。キーの指定は、MOD_BIT(KC_RSFT) のように MOD_BIT() を使うか、モッドマスク（MOD_MASK_CTRL 等）を使って行います。 JP_QUOT Key Overrides を使うために押す必要があるキーに ' を指定しています。なお、KC_QUOT ではなく JP_QUOT としているのは、キーマップで KC_QUOT の代わりに JP_QUOT を指定しているためです。 S(KC_2) \u0026quot; を送信するためのキーコードを指定しています。OS のキーボード配列が JIS の場合に \u0026quot; を送信するには S(KC_2) と指定する必要がありますが、JP_DQUO と指定しても OK です。ここは好みで決めます。 ~0 全てのレイヤーで Key Overrides を使うという指定です。レイヤー i でこのオーバーライドを使うには、i 番目のビット (1 \u0026lt;\u0026lt; i) を設定します。 MOD_MASK_CAG Key Overrides を使うときに押していてはいけない修飾キーに control、windows、alt キーを指定しています。なお、押していてはいけない修飾キーを指定する場合、shift、control、windows、alt の4種類の修飾キーを「押す必要がある」と「押していてはいけない」のどちらかに指定する必要があります。指定漏れや重複指定があると Key Overrides が無効化されます。 それから、key_overrides 配列の要素に key_override_t 構造体を指定します。key_overrides 配列は NULL で終了し、key_override_t 値へのポインタ (const key_override_t **) を含みます。\n1const key_override_t **key_overrides = (const key_override_t *[]){ 2 \u0026amp;JP_QUOT_key_override, 3 \u0026amp;KC_2_key_override, 4 NULL // Null terminate the array of overrides! 5}; あとは、これを必要なキーの数だけ繰り返していきます。私が行った設定をキーマップと合わせて以下に示します。\n1// 全レイヤーで Key Overrides を有効化 2// Ctrl, Win, Altキーを押していたら Key Overrides を発動しない 3const key_override_t JP_GRV_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_GRV, S(KC_EQL), ~0, MOD_MASK_CAG); 4const key_override_t KC_SCLN_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_SCLN, KC_QUOT, ~0, MOD_MASK_CAG); 5const key_override_t JP_QUOT_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_QUOT, S(KC_2), ~0, MOD_MASK_CAG); 6const key_override_t KC_2_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_2, KC_LBRC, ~0, MOD_MASK_CAG); 7const key_override_t KC_6_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_6, KC_EQL, ~0, MOD_MASK_CAG); 8const key_override_t KC_7_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_7, S(KC_6), ~0, MOD_MASK_CAG); 9const key_override_t KC_8_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_8, S(KC_QUOT), ~0, MOD_MASK_CAG); 10const key_override_t KC_9_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_9, S(KC_8), ~0, MOD_MASK_CAG); 11const key_override_t KC_0_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_0, S(KC_9), ~0, MOD_MASK_CAG); 12const key_override_t JP_BSLS_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_BSLS, S(KC_INT3), ~0, MOD_MASK_CAG); 13const key_override_t KC_MINS_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, KC_MINS, S(KC_INT1), ~0, MOD_MASK_CAG); 14const key_override_t JP_EQL_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_EQL, S(KC_SCLN), ~0, MOD_MASK_CAG); 15const key_override_t JP_LBRC_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_LBRC, S(KC_RBRC), ~0, MOD_MASK_CAG); 16const key_override_t JP_RBRC_key_override = ko_make_with_layers_and_negmods(MOD_MASK_SHIFT, JP_RBRC, S(KC_NUHS), ~0, MOD_MASK_CAG); 17 18const key_override_t **key_overrides = (const key_override_t *[]){ 19 \u0026amp;JP_GRV_key_override, 20 \u0026amp;KC_SCLN_key_override, 21 \u0026amp;JP_QUOT_key_override, 22 \u0026amp;KC_2_key_override, 23 \u0026amp;KC_6_key_override, 24 \u0026amp;KC_7_key_override, 25 \u0026amp;KC_8_key_override, 26 \u0026amp;KC_9_key_override, 27 \u0026amp;KC_0_key_override, 28 \u0026amp;JP_BSLS_key_override, 29 \u0026amp;KC_MINS_key_override, 30 \u0026amp;JP_EQL_key_override, 31 \u0026amp;JP_LBRC_key_override, 32 \u0026amp;JP_RBRC_key_override, 33 NULL // Null terminate the array of overrides! 34}; 35// key override setting end 36 37/* keymap */ 38const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { \\ 39 [_QWERTY] = LAYOUT( 40 KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, JP_GRV, \\ 41 KC_LCTL, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, JP_QUOT, \\ 42 KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_ENT, \\ 43 KC_LANG2, KC_ESC, KC_LALT, KC_LGUI, LOWER, KC_SPC, KC_BSPC, RAISE, KC_RGUI, KC_RALT, KC_RCTL, KC_LANG1 \\ 44 ), 45 46 [_LOWER] = LAYOUT( \\ 47 JP_ZKHK, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, JP_BSLS, \\ 48 _______, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_MINS, JP_EQL, JP_LBRC, JP_RBRC, _______, \\ 49 _______, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_APP, JP_LPRN, JP_RPRN, _______, _______, \\ 50 _______, _______, _______, _______, _______, _______, KC_DEL, _______, _______, _______, _______, _______ \\ 51 ), 52 53 [_RAISE] = LAYOUT( \\ 54 KC_AGRV, KC_NO, KC_PGUP, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_INS, KC_NO, KC_PSCR, KC_NO, \\ 55 _______, KC_HOME, KC_PGDN, KC_END, KC_NO, KC_NO, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_NO, KC_NO, \\ 56 _______, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, _______, _______, _______, _______, \\ 57 _______, _______, _______, _______, _______, KC_ENT, _______, _______, _______, _______, _______, _______ \\ 58 ), 59 60 [_ADJUST] = LAYOUT( \\ 61 RESET, JP_EXLM, JP_AT, JP_HASH, JP_DLR, JP_PERC, JP_CIRC, JP_AMPR, JP_ASTR, JP_LPRN, JP_RPRN, KC_NO, \\ 62 DEBUG, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_CAD, KC_APSCR, KC_NO,\\ 63 _______, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, _______, _______, _______, _______, \\ 64 _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______ \\ 65 ) 66}; S(JU_2) の形で指定したキーを押しても何も送信されませんので、JP_EXLM 等のキーコードを使う必要があります。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPC に送信されるキーコードは qmk_firmware/keycode.h at master · qmk/qmk_firmware で定義されています。このキーコードは USB 規格 の HID Usage Table で定められているコードを基にして、現在の OS では使われないコード (0xA5-0xDF) にメディアキー等が割り当てられています。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"http://localhost:1313/post/2022-08-07/","section":"post","tags":null,"title":"OS のキーボード配列が JIS キーボードの時の QMK Firmware の設定について"},{"body":"","link":"http://localhost:1313/archives/2022/06/","section":"archives","tags":null,"title":"2022/06"},{"body":"前置き 自作キーボードのコミュニティで使用している質問用フォームを管理していますが、1つのページに全ての質問を載せる形から、問題の内容に応じて質問を分けるようにしました。\nこの改修により、管理するページ数が1から6に増え、そのうち5つのページでヘッダー等が共通していましたので、共通部分を切り出す方法を探したところ、html-includes - npm というプラグインがちょうど良かったため、早速使うことにしました。\nこのプラグインの解説をした日本語ページが見当たらなかったので、備忘録を兼ねて簡単な使い方を説明します。\nプラグインの概要 あるHTMLファイルに別のHTMLファイルを挿入してくれるプラグインです。各ページに共通する部分を別ファイルに切り出して、それをビルドして一つのファイルに統合することができるようになります。\nインストール方法 npm でプラグインをインストールします。\n1npm i --save-dev html-includes それから package.json に次の設定を追加すると、 npm run compile コマンドでビルドできるようになります。\n1\u0026#34;scripts\u0026#34;: { 2 \u0026#34;compile\u0026#34;: \u0026#34;html-includes --src src --dest dist\u0026#34;, 3 \u0026#34;compile:watch\u0026#34;: \u0026#34;html-includes --src src --dest dist --watch\u0026#34; 4}, html-includes のオプションは次のとおりです。\n-src src 統合する html ファイルが保存されているディレクトリを指定する。 -dest dist 統合した html ファイルを保存するディレクトリを指定する。 --watch ファイルが変更されたら自動的にビルドする。 使い方 大まかな手順は次のとおりです。\n共通部分を読み込む側の html ファイルに ${require('読み込みたいファイルのパス')} を記述 上で説明した -src src で指定したディレクトリに共通部分を切り出した html ファイルを保存 npm run compile でビルドする 1# ファイル構成 2src/ 3└── html 4 ├── common 5 │ ├── _firmwareInfo.html 6 │ ├── _footer.html 7 │ ├── _head.html 8 │ ├── _header.html 9 │ ├── _microcomputerInfo.html 10 │ ├── _otherInfo.html 11 │ ├── _resultForm.html 12 │ ├── _tailOfBodyTag.html 13 │ └── _testMicrocomputerOnly.html 14 ├── BLEProblem.html 15 ├── buildProblem.html 16 ├── designProblem.html 17 ├── firmwareProblem.html 18 ├── index.html 19 ├── memo.html 20 └── otherProblem.html 21 22 dist/ 23├── BLEProblem.html 24├── buildProblem.html 25├── designProblem.html 26├── firmwareProblem.html 27├── index.html 28└── otherProblem.html 読み込む側の html ファイルの設定 html ファイルに ${require('/common/_microcomputerInfo.html')} と追加すると、その部分に /common/_microcomputerInfo.html の内容が追加されます。\n1# src/html/buildProblem.html 2\u0026lt;div class=\u0026#34;border rounded shadow-sm m-3 p-3 bg-white\u0026#34;\u0026gt; 3 ${require(\u0026#39;/common/_microcomputerInfo.html\u0026#39;)} 4\u0026lt;/div\u0026gt; 1# /common/_microcomputerInfo.html 2 \u0026lt;h2 id=\u0026#34;microcomputerInfomationTitle\u0026#34;\u0026gt;マイコンの情報\u0026lt;/h2\u0026gt; 3 \u0026lt;div class=\u0026#34;form-group p-2\u0026#34; id=\u0026#34;microcomputerInfomation\u0026#34;\u0026gt; 4 \u0026lt;label id=\u0026#34;labelMicrocomputerInfo\u0026#34;\u0026gt;マイコンの種類\u0026lt;/label\u0026gt; 5 \u0026lt;div class=\u0026#34;form-check\u0026#34;\u0026gt; 6 \u0026lt;input class=\u0026#34;form-check-input\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;microcontroller\u0026#34; id=\u0026#34;promicro(atmega32u4)\u0026#34; value=\u0026#34;Pro Micro(ATmega32U4)\u0026#34;\u0026gt; 7 \u0026lt;label id=\u0026#34;labelProMicro(ATMega32U4)\u0026#34; class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;promicro(atmega32u4)\u0026#34;\u0026gt;Pro Micro(ATmega32U4)\u0026lt;/label\u0026gt; 8 \u0026lt;/div\u0026gt; 9 \u0026lt;div class=\u0026#34;form-check\u0026#34;\u0026gt; 10 \u0026lt;input class=\u0026#34;form-check-input\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;microcontroller\u0026#34; id=\u0026#34;promicro(RP2040)\u0026#34; value=\u0026#34;Pro Micro(RP2040)\u0026#34;\u0026gt; 11 \u0026lt;label id=\u0026#34;labelProMicro(RP2040)\u0026#34; class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;promicro(RP2040)\u0026#34;\u0026gt;Pro Micro(RP2040)\u0026lt;/label\u0026gt; 12 \u0026lt;/div\u0026gt; 13 \u0026lt;/div\u0026gt; 1# dist/buildProblem.html 2\u0026lt;div class=\u0026#34;border rounded shadow-sm m-3 p-3 bg-white\u0026#34;\u0026gt; 3 \u0026lt;h2 id=\u0026#34;microcomputerInfomationTitle\u0026#34;\u0026gt;マイコンの情報\u0026lt;/h2\u0026gt; 4 \u0026lt;div class=\u0026#34;form-group p-2\u0026#34; id=\u0026#34;microcomputerInfomation\u0026#34;\u0026gt; 5 \u0026lt;label id=\u0026#34;labelMicrocomputerInfo\u0026#34;\u0026gt;マイコンの種類\u0026lt;/label\u0026gt; 6 \u0026lt;div class=\u0026#34;form-check\u0026#34;\u0026gt; 7 \u0026lt;input class=\u0026#34;form-check-input\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;microcontroller\u0026#34; id=\u0026#34;promicro(atmega32u4)\u0026#34; value=\u0026#34;Pro Micro(ATmega32U4)\u0026#34;\u0026gt; 8 \u0026lt;label id=\u0026#34;labelProMicro(ATMega32U4)\u0026#34; class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;promicro(atmega32u4)\u0026#34;\u0026gt;Pro Micro(ATmega32U4)\u0026lt;/label\u0026gt; 9 \u0026lt;/div\u0026gt; 10 \u0026lt;div class=\u0026#34;form-check\u0026#34;\u0026gt; 11 \u0026lt;input class=\u0026#34;form-check-input\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;microcontroller\u0026#34; id=\u0026#34;promicro(RP2040)\u0026#34; value=\u0026#34;Pro Micro(RP2040)\u0026#34;\u0026gt; 12 \u0026lt;label id=\u0026#34;labelProMicro(RP2040)\u0026#34; class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;promicro(RP2040)\u0026#34;\u0026gt;Pro Micro(RP2040)\u0026lt;/label\u0026gt; 13 \u0026lt;/div\u0026gt; 14 \u0026lt;/div\u0026gt; 15\u0026lt;/div\u0026gt; 読み込まれる側の html ファイルの設定 読み込まれる側の html ファイルに必要な設定はありませんが、読み込まれる html ファイルのファイル名の一文字目を _ にすると、ビルド時に読み込んだファイルが dist ディレクトリにコピーされなくなります。\nまた、読み込まれる側の html ファイルに Javascript 式に似た \u0026lt;p\u0026gt;Main content ${props.foo}\u0026lt;/p\u0026gt; のような設定を追加しておくと、読み込む側のファイルで ${require('./_main.html') foo=\u0026quot;and you can also pass props\u0026quot;} とすることで文字列を受渡しできるようになります。ページタイトルのように共通部分の一部のみ変更する必要がある場合に役に立ちます。\n1# src/html/buildProblem.html 2\u0026lt;head\u0026gt; 3 ${require(\u0026#39;/common/_head.html\u0026#39;) pageTitle=\u0026#34;組み立てに関する問題\u0026#34;} 4\u0026lt;/head\u0026gt; 1# common_head.html 2\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 3 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; 4 5 \u0026lt;!-- Font Awesome --\u0026gt; 6 \u0026lt;link 7 href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\u0026#34; 8 rel=\u0026#34;stylesheet\u0026#34; 9 /\u0026gt; 10 \u0026lt;!-- Google Fonts --\u0026gt; 11 \u0026lt;link 12 href=\u0026#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700\u0026amp;display=swap\u0026#34; 13 rel=\u0026#34;stylesheet\u0026#34; 14 /\u0026gt; 15 \u0026lt;!-- MDB --\u0026gt; 16 \u0026lt;link 17 href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/4.0.0/mdb.min.css\u0026#34; 18 rel=\u0026#34;stylesheet\u0026#34; 19 /\u0026gt; 20 21 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;image/favicon.ico\u0026#34;\u0026gt; 22 23 \u0026lt;title\u0026gt;問診票テンプレート - ${props.pageTitle}\u0026lt;/title\u0026gt; 1# dist/buildProblem.html 2\u0026lt;head\u0026gt; 3 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 4 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; 5 6 \u0026lt;!-- Font Awesome --\u0026gt; 7 \u0026lt;link 8 href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\u0026#34; 9 rel=\u0026#34;stylesheet\u0026#34; 10 /\u0026gt; 11 \u0026lt;!-- Google Fonts --\u0026gt; 12 \u0026lt;link 13 href=\u0026#34;https://fonts.googleapis.com/css?family=Roboto:300,400,500,700\u0026amp;display=swap\u0026#34; 14 rel=\u0026#34;stylesheet\u0026#34; 15 /\u0026gt; 16 \u0026lt;!-- MDB --\u0026gt; 17 \u0026lt;link 18 href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/4.0.0/mdb.min.css\u0026#34; 19 rel=\u0026#34;stylesheet\u0026#34; 20 /\u0026gt; 21 22 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;image/favicon.ico\u0026#34;\u0026gt; 23 24 \u0026lt;title\u0026gt;問診票テンプレート - 組み立てに関する問題\u0026lt;/title\u0026gt; 25\u0026lt;/head\u0026gt; ","link":"http://localhost:1313/post/2022-06-11/","section":"post","tags":null,"title":"html-include の使い方"},{"body":"","link":"http://localhost:1313/archives/2022/04/","section":"archives","tags":null,"title":"2022/04"},{"body":"前置き MainsailOS をインストールしている Raspberry Pi で sudo apt update を実行したら The following signatures were invalid: EXPKEYSIG 2CE2AC08D880C8E4 shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; と表示されるようになりました。\n1\u0026gt; sudo apt update 2Get:1 https://pkgs.tailscale.com/stable/raspbian buster InRelease 3Hit:2 http://archive.raspberrypi.org/debian buster InRelease 4Get:3 http://raspbian.raspberrypi.org/raspbian buster InRelease [15.0 kB] 5Hit:4 http://download.opensuse.org/repositories/shells:/fish/Debian_10 InRelease 6Hit:5 https://deb.nodesource.com/node_16.x buster InRelease 7Err:4 http://download.opensuse.org/repositories/shells:/fish/Debian_10 InRelease 8 The following signatures were invalid: EXPKEYSIG 2CE2AC08D880C8E4 shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; 9Get:6 http://raspbian.raspberrypi.org/raspbian buster/main armhf Packages [13.0 MB] 100% [6 Packages 6,114 kB/13.0 MB 47%] 40.1 kB/s 2min 51sdebug1: client_input_channel_req: channel 0 rtype keepalive@openssh.com reply 1 110% [6 Packages 12.9 MB/13.0 MB 99%] 28.5 kB/s 3sdebug1: client_input_channel_req: channel 0 rtype keepalive@openssh.com reply 1 12Fetched 13.0 MB in 6min 19s (34.4 kB/s) 13Reading package lists... Done 14Building dependency tree 15Reading state information... Done 163 packages can be upgraded. Run \u0026#39;apt list --upgradable\u0026#39; to see them. 17W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: http://download.opensuse.org/repositories/shells:/fish/Debian_10 InRelease: The following signatures were invalid: EXPKEYSIG 2CE2AC08D880C8E4 shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; 18W: Failed to fetch http://download.opensuse.org/repositories/shells:/fish/Debian_10/InRelease The following signatures were invalid: EXPKEYSIG 2CE2AC08D880C8E4 shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; 19W: Some index files failed to download. They have been ignored, or old ones used instead. これではアップデートに支障が生じるので解決策を探したところ、公式の Github の Issues で解決策が見つかりましたので、参考のためにシェアします。\n解決策の概要 簡単にまとめると次のとおりです。\n期限切れになった既存のリポジトリキーを削除 新しいキーを登録 sudo apt update を実行 具体的な手順 既存のリポジトリキーの確認 既存のリポジトリキーは、次のコマンドで確認できます。一番下の /etc/apt/trusted.gpg.d/shells_fish.gpg が期限切れ（expired）になったキーです。\n1\u0026gt; sudo apt-key list 2/etc/apt/trusted.gpg 3-------------------- 4pub rsa2048 2012-04-01 [SC] 5 A0DA 38D0 D76E 8B5D 6388 7281 9165 938D 90FD DD2E 6uid [ unknown] Mike Thompson (Raspberry Pi Debian armhf ARMv6+VFP) \u0026lt;mpthompson@gmail.com\u0026gt; 7sub rsa2048 2012-04-01 [E] 8 9pub rsa2048 2012-06-17 [SC] 10 CF8A 1AF5 02A2 AA2D 763B AE7E 82B1 2992 7FA3 303E 11uid [ unknown] Raspberry Pi Archive Signing Key 12sub rsa2048 2012-06-17 [E] 13 14pub rsa4096 2020-02-25 [SC] 15 2596 A99E AAB3 3821 893C 0A79 458C A832 957F 5868 16uid [ unknown] Tailscale Inc. (Package repository signing key) \u0026lt;info@tailscale.com\u0026gt; 17sub rsa4096 2020-02-25 [E] 18 19/etc/apt/trusted.gpg.d/shells_fish.gpg 20-------------------------------------- 21pub rsa2048 2013-10-08 [SC] [expired: 2022-04-12] 22 24A6 3B31 CAB4 1B33 EC48 801E 2CE2 AC08 D880 C8E4 23uid [ expired] shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; 期限切れになったリポジトリキーの削除 期限切れになったリポジトリキーは、次のコマンドで削除できます。\n1\u0026gt; sudo apt-key del 2CE2AC08D880C8E4 2OK 削除後のリポジトリキーのリストを確認すると、 /etc/apt/trusted.gpg.d/shells_fish.gpg が削除されていることが確認できます。\n1\u0026gt; sudo apt-key list 2/etc/apt/trusted.gpg 3-------------------- 4pub rsa2048 2012-04-01 [SC] 5 A0DA 38D0 D76E 8B5D 6388 7281 9165 938D 90FD DD2E 6uid [ unknown] Mike Thompson (Raspberry Pi Debian armhf ARMv6+VFP) \u0026lt;mpthompson@gmail.com\u0026gt; 7sub rsa2048 2012-04-01 [E] 8 9pub rsa2048 2012-06-17 [SC] 10 CF8A 1AF5 02A2 AA2D 763B AE7E 82B1 2992 7FA3 303E 11uid [ unknown] Raspberry Pi Archive Signing Key 12sub rsa2048 2012-06-17 [E] 13 14pub rsa4096 2020-02-25 [SC] 15 2596 A99E AAB3 3821 893C 0A79 458C A832 957F 5868 16uid [ unknown] Tailscale Inc. (Package repository signing key) \u0026lt;info@tailscale.com\u0026gt; 17sub rsa4096 2020-02-25 [E] 新しいリポジトリキーの登録 新しいリポジトリキーは、次のコマンドで登録できます。このコマンドは、最初に触れた Github の Issues で提案されたコマンドを Debian10 向けに修正したものです。\n1curl -fsSL https://download.opensuse.org/repositories/shells:fish:release:3/Debian_10/Release.key |gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/shells_fish_release_3.gpg \u0026gt; /dev/null 新しいリポジトリキーを登録した後のキーリストは次のとおりです。 /etc/apt/trusted.gpg.d/shells_fish_release_3.gpg が登録されていることが確認できます。\n1\u0026gt; sudo apt-key list 2/etc/apt/trusted.gpg 3-------------------- 4pub rsa2048 2012-04-01 [SC] 5 A0DA 38D0 D76E 8B5D 6388 7281 9165 938D 90FD DD2E 6uid [ unknown] Mike Thompson (Raspberry Pi Debian armhf ARMv6+VFP) \u0026lt;mpthompson@gmail.com\u0026gt; 7sub rsa2048 2012-04-01 [E] 8 9pub rsa2048 2012-06-17 [SC] 10 CF8A 1AF5 02A2 AA2D 763B AE7E 82B1 2992 7FA3 303E 11uid [ unknown] Raspberry Pi Archive Signing Key 12sub rsa2048 2012-06-17 [E] 13 14pub rsa4096 2020-02-25 [SC] 15 2596 A99E AAB3 3821 893C 0A79 458C A832 957F 5868 16uid [ unknown] Tailscale Inc. (Package repository signing key) \u0026lt;info@tailscale.com\u0026gt; 17sub rsa4096 2020-02-25 [E] 18 19/etc/apt/trusted.gpg.d/shells_fish_release_3.gpg 20------------------------------------------------ 21pub rsa2048 2013-10-08 [SC] [expires: 2024-06-07] 22 24A6 3B31 CAB4 1B33 EC48 801E 2CE2 AC08 D880 C8E4 23uid [ unknown] shells:fish OBS Project \u0026lt;shells:fish@build.opensuse.org\u0026gt; sudo apt update の実行 新しいリポジトリキーを登録しましたので、 sudo apt update を実行して問題がないか確認します。 できます。このコマンドは、最初に触れた Github の Issues で提案されたコマンドを Debian10 向けに修正したものです。\n1\u0026gt; sudo apt update 2Hit:1 http://download.opensuse.org/repositories/shells:/fish/Debian_10 InRelease 3Hit:2 https://deb.nodesource.com/node_16.x buster InRelease 4Hit:3 http://archive.raspberrypi.org/debian buster InRelease 5Hit:4 http://raspbian.raspberrypi.org/raspbian buster InRelease 6Get:5 https://pkgs.tailscale.com/stable/raspbian buster InRelease 7Fetched 5,543 B in 2s (2,367 B/s) 8Reading package lists... Done 9Building dependency tree 10Reading state information... Done 113 packages can be upgraded. Run \u0026#39;apt list --upgradable\u0026#39; to see them. 無事に問題が発生することなくアップデートできていることが確認できました。\n参考にしたサイト\nhttps://github.com/fish-shell/fish-shell/issues/8869\n","link":"http://localhost:1313/post/2022-04-19/","section":"post","tags":["備忘録"],"title":"sudo apt update で Fish のリポジトリキーが不正と表示される件について"},{"body":"前置き 我が家では3台の3Dプリンタ（Prusa MK3S+、Ender 3 Pro、Voron V0.0）が稼動していて、これらを全て MainsailOS で制御しています。\nしかし、操作画面を取り違えることがありましたので、どのプリンタの制御画面を開いているのか一目で分かる目印を表示させたいと思いました。調べてみると Mainsail にはテーマ機能が用意されていましたので、この機能を使ってプリンタ毎に目印が表示されるようにしました。\n作業自体は簡単ですが、同じことをしている日本語記事が見当らないので、誰かの参考になればと思って記事にしました。\nTL,DL W300 x H900 の画像を用意して ~/klipper_config/.theme/sidebar-background.png というファイル名で保存すると、そのファイルがサイドバーのバックグラウンド画像となります。\n具体的な手順 ~/klipper_config ディレクトリに .theme というディレクトリを作成します ディレクトリの作成は、RaspberryPi に SSH でアクセスして mkdir klipper/.theme コマンドを実行するか、Mainsail の MACHINE タブの Config Files の Create Directory ボタンを使って行います。 表示させるロゴを作成して sidebar-background.png というファイル名で保存します ロゴは W300 x H900 とし、上から 400 ぐらいの場所にロゴを置きます。 作成したロゴを Mainsail をインストールしている RaspberryPi の ~/klipper_config/.theme/ ディレクトリにコピーします。 これで sidebar-background.png ファイルがサイドバーに表示されます サイドバーにロゴが表示されています 補足 我が家の3Dプリンタは Prusa MK3S+、Ender 3 Pro、Voron V0.0 の3台なので、それぞれに合わせたロゴを用意する必要があります。\nこのうち Voronについては、Mainsail 公式が案内しているテーマを Kiauh でインストールし、Voron V0.0 のプリントヘッドに合わせてklipper_config/.theme/sidebar_toolheads/sidebar-backgroundV0.0.png を klipper_config/.theme/sidebar-background.png という名前でコピーすればOKです。\neriroh/Mainsail-x-Voron-Toolhead-Theme\nVoron の操作画面 Prusa MK3S+、Ender 3 Pro にはそうしたテーマが作成されていないようなので、ウェブでロゴに使えそうな画像を探してロゴを作成しました。Ender 3 Pro の操作画面は上の画像のとおりで、Prusa MK3S+ の操作画面は次のとおりです。\nPrusa の操作画面 テーマに関する公式情報\ndocs.mainsail.xyz/features/theming\n","link":"http://localhost:1313/post/2022-04-04/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"Mainsail でサイドバーにロゴを表示させる方法"},{"body":"","link":"http://localhost:1313/archives/2022/02/","section":"archives","tags":null,"title":"2022/02"},{"body":" 目次 前置き TL;DL 具体的な作業 Klipper と Moonraker の削除 Klipper のインストール Moonraker のインストール printer.cfg の編集 moonraker.conf の編集 タイムラプス動画撮影のスクリプトをインストール Webカメラの設定 FluiddPi の設定 前置き 日本の3Dプリンタユーザーが集まっている Discord の 3D Printing Japan Comunity のメンバーの虎鉄悦夫さんがRaspberry pi1台で複数台のKlipper搭載３Dプリンタを制御する方法（KIAUH活用版）｜虎鉄悦夫｜noteという記事を執筆されたので、自分もやってみようと思ってみたら結構大変だったので、自分用の備忘録として作業記録を残します。\nなお、今回の作業はゼロからのスタートではなく、2台の Raspberry Pi で2台の3Dプリンタ（Klipperインストール済）を制御している状態からスタートして、1台の Raspberry Pi で2台の3Dプリンタを動かしながらタイムラプス動画も撮影できるようにしました。\nTL;DL Klipper と Moonraker を一度削除してから2台分インストールする klipper_config/printer_1/printer.cfg と klipper_config/printer_2/printer.cfg を設定する タイムラプス動画撮影のためのスクリプトを clone する タイムラプス動画撮影のインストールスクリプトを2つ用意して修正する タイムラプス動画撮影のスクリプトをインストールする カメラの設定ファイルを2つ用意して編集する 動画を保存するディレクトリを2つ用意する FluiddPi で2台のプリンタを制御できるようにする 具体的な作業 Klipper と Moonraker の削除 既存の Klipper と Moonraker の削除は、Kiauh を使うと簡単です。まず、./kiauh/kiauh.sh でプロンプトを開いて 3) [Remove] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~~~ [ Main Menu ] ~~~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| 0) [Upload Log] | Klipper: Installed: 2 | 10| | Branch: master | 11| 1) [Install] | | 12| 2) [Update] | Moonraker: Installed: 2 | 13| 3) [Remove] | | 14| 4) [Advanced] | Mainsail: Not installed! | 15| 5) [Backup] | Fluidd: Installed! | 16| | KlipperScreen: Not installed! | 17| 6) [Settings] | Telegram Bot: Not installed! | 18| | | 19| | DWC2: Not installed! | 20| v3.1.0-93 | Octoprint: Not installed! | 21|-------------------------------------------------------| 22| Q) Quit | 23\\=======================================================/ 24Perform action: 3 次に 1) [Klipper] を選択して Klipper を削除すると答えると、合わせて Moonraker も削除するか聞かれますので、はいと答えます。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~~ [ Remove Menu ] ~~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| Directories which remain untouched: | 10| --\u0026gt; Your printer configuration directory | 11| --\u0026gt; ~/kiauh-backups | 12| You need remove them manually if you wish so. | 13|-------------------------------------------------------| 14| Firmware: | Touchscreen GUI: | 15| 1) [Klipper] | 5) [KlipperScreen] | 16| | | 17| Klipper API: | Other: | 18| 2) [Moonraker] | 6) [Duet Web Control] | 19| | 7) [OctoPrint] | 20| Klipper Webinterface: | 8) [PrettyGCode] | 21| 3) [Mainsail] | 9) [Telegram Bot] | 22| 4) [Fluidd] | | 23| | 10) [MJPG-Streamer] | 24| | 11) [NGINX] | 25|-------------------------------------------------------| 26| B) « Back | 27\\=======================================================/ 28Perform action: 1 これで既存の Klipper と Moonraker を削除できましたので、今度は必要な台数分 Klipper と Moonraker をインストールします。\nKlipper のインストール インストール方法は、./kiauh/kiauh.sh でプロンプトを開いて 1) [Install] を選択し、続いて 1) [Klipper] を選択します。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~ [ Installation Menu ] ~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| You need this menu usually only for installing | 10| all necessary dependencies for the various | 11| functions on a completely fresh system. | 12|-------------------------------------------------------| 13| Firmware: | Touchscreen GUI: | 14| 1) [Klipper] | 5) [KlipperScreen] | 15| | | 16| Klipper API: | Other: | 17| 2) [Moonraker] | 6) [Duet Web Control] | 18| | 7) [OctoPrint] | 19| Klipper Webinterface: | 8) [PrettyGCode] | 20| 3) [Mainsail] | 9) [Telegram Bot] | 21| 4) [Fluidd] | | 22| | Webcam: | 23| | 10) [MJPG-Streamer] | 24|-------------------------------------------------------| 25| B) « Back | 26\\=======================================================/ 27Perform action: 1 そうすると何台分インストールするか聞かれますので、必要な台数を回答するとその数だけ Klipper をインストールしてくれます。\nMoonraker のインストール Moonraker のインストールも同様の手順で、上の画面で 2) [Moonraker] を選択すると何台分インストールするか聞かれるので、必要な台数を回答します。\nなお、インストールの最後に FluiddPi でアクセスするときに必要な IPアドレスが表示されますので、忘れずにメモします。\n1######################################################### 2 2 Moonraker instances have been set up! 3######################################################### 4 5 ● Instance 1: 192.168.1.5:7125 6 ● Instance 2: 192.168.1.5:7126 これで Klipper と Moonraker がサービスとして必要な台数分だけ起動されます。\n1systemctl -l | grep klipper 2klipper-1.service loaded active running Starts klipper instance 1 on startup 3klipper-2.service loaded active running Starts klipper instance 2 on startup 4 5systemctl -l | grep moonraker 6moonraker-1.service loaded active running Starts Moonraker 1 on startup 7moonraker-2.service loaded active running Starts Moonraker 2 on startup ちなみに、Klipper と Moonraker が1台分だけ起動されている場合のサービス状況は次のとおりです。\n1systemctl list-units --type=service | grep klipper 2klipper.service loaded active running Starts klipper on startup 3 4systemctl list-units --type=service | grep moonraker 5moonraker.service loaded active running Starts Moonraker on startup printer.cfg の編集 klipper_config/printer_1 と klipper_config/printer_2 ができているはずなので、それぞれのディレクトリに printer.cfg を作成して設定します。私の場合、klipper_config/printer_1/printer.cfg を Prusa に、klipper_config/printer_2/printer.cfg を Ender 3 Pro に割り当てています。\nprinter.cfg の [mcu] に設定するシリアルポートについては、Raspberry Pi とプリンタを接続してからプリンタの電源を入れ、./kiauh/kiauh.sh を実行して 4) Advanced -\u0026gt; 6) [Get MCU ID] -\u0026gt; 1) USB と進むと確認できます。\n1###### Identifying MCU ... 2 ● (USB) MCU #1: /dev/serial/by-id/usb-Klipper_stm32f103xe_34FFFFFF344E313337570157-if00 3 ● (USB) MCU #2: /dev/serial/by-id/usb-Prusa_Research__prusa3d.com__Original_Prusa_i3_MK3_CZPX3419X004XC43991-if00 ここで確認したシリアルポートを [mcu] に設定します。プリンタを取り違えるとホットエンドが常時加熱されたりしますので、その点は注意してください。そのほかの設定は、プリンタが1台の場合と同じです。\nmoonraker.conf の編集 klipper_config/printer_1 と klipper_config/printer_2 に moonraker.cfg を作成して設定します。printer.cfg とは違い、moonraker.conf はプリンタが複数台になったことに伴って設定箇所が増えていますので、変更点と変更理由を説明します。\nなお、klipper_config/printer_1/moonraker.cfg を Prusa に、klipper_config/printer_2/moonraker.cfg を Ender 3 Pro に割り当てています。\n1# printer_2/moonraker.cfg 2[server] 3-port: 7125 4+port: 7126 Ender 3 Pro のアクセス先が「192.168.1.5:7126」となっていることに伴う変更です。\n1# printer_1/moonraker.cfg 2[server] 3-klippy_uds_address: /tmp/klippy_uds 4+klippy_uds_address: /tmp/klippy_uds-1 1# printer_2/moonraker.cfg 2[server] 3-klippy_uds_address: /tmp/klippy_uds 4+klippy_uds_address: /tmp/klippy_uds-2 上記のインストールにより /tmp/klippy_uds が /tmp/klippy_uds-1、/tmp/klippy_uds-2 になっていますので、それに合わせて変更しています。\n1# printer_1/moonraker.cfg 2+[database] 3+database_path: /home/pi/.moonraker_database_1 1# printer_2/moonraker.cfg 2+[database] 3+database_path: /home/pi/.moonraker_database_2 デフォルトでは設定不要のセクションですが、上記のインストールにより設定する必要が生じています。\n1# printer_1/moonraker.cfg 2[file_manager] 3-config_path: ~/klipper_config 4+config_path: ~/klipper_config/printer_1 1# printer_2/moonraker.cfg 2[file_manager] 3-config_path: ~/klipper_config 4+config_path: ~/klipper_config/printer_2 設定ファイルの保存場所が /klipper_config/printer_1 と /klipper_config/printer_2 に分かれたことに伴う変更です。\n1# printer_1/moonraker.cfg 2[update_manager timelapse] 3-#output_path: ~/timelapse/ 4+output_path: ~/timelapse/printer1 1# printer_2/moonraker.cfg 2[update_manager timelapse] 3-#output_path: ~/timelapse/ 4+output_path: ~/timelapse/printer2 タイムラプス動画の保存場所をプリンタ毎に用意しています。\n1# printer_1/moonraker.cfg 2[timelapse] 3-#frame_path: /tmp/timelapse/ 4+frame_path: /tmp/timelapse/printer1 1# printer_2/moonraker.cfg 2[timelapse] 3-#frame_path: /tmp/timelapse/ 4+frame_path: /tmp/timelapse/printer2 タイムラプス動画の撮影中の画像の保存先をプリンタ毎に分けています。保存先が同じだと、2台のカメラで撮影した画像が繋ぎ合わされた動画が作成されます。\n1# printer_2/moonraker.cfg 2[timelapse] 3-#snapshoturl: http://localhost:8080/?action=snapshot 4+snapshoturl: http://192.168.1.5:8081/?action=snapshot 2台目のプリンタのみ設定します。2台の Webカメラを使うように設定していますが、2台目のカメラの URL がデフォルトの http://localhost:8080/?action=snapshot から変更されていますので、それに伴う変更です。なお、IPアドレス直打ちにしているのは、localhost では上手く接続できないときがあったためです。\nタイムラプス動画撮影のスクリプトをインストール git clone https://github.com/mainsail-crew/moonraker-timelapse.git を実行してタイムラプス動画撮影スクリプトをインストールしますが、このスクリプトは、複数台のプリンタが接続されているケースに対応していないため、修正が必要です。\n1cp moonraker-timelapse/install.sh moonraker-timelapse/install_printer1.sh 2cp moonraker-timelapse/install.sh moonraker-timelapse/install_printer2.sh 上記のコマンドでスクリプトを必要な台数分コピーしてから、Klipper と Moonraker を複数起動したことに伴うサービス名の変更に対応するための修正を行います。\n1- if [ \u0026#34;$(sudo systemctl list-units --full -all -t service --no-legend | grep -F \u0026#34;klipper.service\u0026#34;)\u0026#34; ]; then 2+ if [ \u0026#34;$(sudo systemctl list-units --full -all -t service --no-legend | grep -F \u0026#34;klipper-1.service\u0026#34;)\u0026#34; ]; then 3- sudo systemctl stop klipper 4+ sudo systemctl stop klipper-1 5- if [ \u0026#34;$(sudo systemctl list-units --full -all -t service --no-legend | grep -F \u0026#34;moonraker.service\u0026#34;)\u0026#34; ]; then 6+ if [ \u0026#34;$(sudo systemctl list-units --full -all -t service --no-legend | grep -F \u0026#34;moonraker-1.service\u0026#34;)\u0026#34; ]; then 7- sudo systemctl stop moonraker 8+ sudo systemctl stop moonraker-1 9- After=moonraker.service 10- Wants=moonraker.service 11+ After=moonraker-1.service 12+ Wants=moonraker-1.service 13- ExecStopPost=systemctl restart klipper 14- ExecStopPost=systemctl restart moonraker 15+ ExecStopPost=systemctl restart klipper-1 16+ ExecStopPost=systemctl restart moonraker-1 17- sudo systemctl restart moonraker 18+ sudo systemctl restart moonraker-1 19- sudo systemctl restart klipper 20+ sudo systemctl restart klipper-1 スクリプトを修正したら、次のコマンドでスクリプトをインストールします。\n1bash ~/moonraker-timelapse/install_printer1.sh KLIPPER_CONFIG_DIR=/home/pi/klipper_config/printer_1/ 2bash ~/moonraker-timelapse/install_printer2.sh KLIPPER_CONFIG_DIR=/home/pi/klipper_config/printer_2/ 引数に KLIPPER_CONFIG_DIR=/home/pi/klipper_config/printer_1/ を指定しているのは、printer.cfg の保存場所が klipper_config から klipper_config/printer_1 に変更されていることに対応するためです。\nあとは、タイムラプス動画を保存する場所をカメラ毎に用意します。\n1mkdir timelapse/printer1 2mkdir timelapse/printer2 Webカメラの設定 次に Webカメラの設定を行います（この作業に一番悩みました）。\nまず、FluiddPi をインストールしている場合、Webカメラは webcamd.service というサービスで制御されています。\n1systemctl list-units --type=service | grep webcam 2webcamd.service loaded active running the FluiddPI webcam daemon (based on OctoPi) with the user specified config このサービスは /etc/systemd/system/webcamd.service から起動されており、コードは次のとおりです。\n1cat /etc/systemd/system/webcamd.service 2 3[Unit] 4Description=the FluiddPI webcam daemon (based on OctoPi) with the user specified config 5 6[Service] 7WorkingDirectory=/usr/local/bin 8StandardOutput=append:/var/log/webcamd.log 9StandardError=append:/var/log/webcamd.log 10ExecStart=/usr/local/bin/webcamd 11Restart=always 12Type=forking 13User=pi 14 15[Install] 16WantedBy=multi-user.target そして、/etc/systemd/system/webcamd.service は /usr/local/bin/webcamd を実行していますが、/usr/local/bin/webcamd のコードを見ると、~/klipper_config ディレクトリにある複数の webcam*.txt を読み込んでいることが分かります。\n1# /usr/local/bin/webcamd 抜粋 2config_dir=\u0026#34;/home/pi/klipper_config\u0026#34; 3 4echo \u0026#34;Starting up webcamDaemon...\u0026#34; 5echo \u0026#34;\u0026#34; 6 7cfg_files=() 8#cfg_files+=/boot/fluidd.txt 9if [[ -d ${config_dir} ]]; then 10 cfg_files+=( `ls ${config_dir}/webcam*.txt` ) 11fi そのため、複数台のWebカメラを制御したければ、klipper_config/webcam1.txt、klipper_config/webcam2.txt という具合に、カメラの台数分だけ設定ファイルを用意すれば良いということになります。\nそこで、次のコマンドで設定ファイルをカメラの台数分用意するとともに、既存の webcam.txt を読み込ませないためにリネームします。\n1cp klipper_config/webcam.txt klipper_config/webcam1.txt 2cp klipper_config/webcam.txt klipper_config/webcam2.txt 3mv klipper_config/webcam.txt klipper_config/webcam.txt.backup そして、webcam1.txt と webcam2.txt を設定しますが、カメラを複数台使う場合、デバイスファイル（/dev/video*）と映像の出力先（-p 808*）を指定する必要があります。\nデバイスファイルは次のコマンドで確認できます。私のカメラは2台とも Logicool C270 なので usb-046d_0825 の部分が同じですが、video0, video1 が1台目のカメラ、video2, video3 が2台目のカメラのデバイスファイルで、webcam*.txt では、video0, video2 を指定します。\n1ls -la /dev/v4l/by-id 2total 0 3drwxr-xr-x 2 root root 120 Feb 6 06:17 . 4drwxr-xr-x 4 root root 80 Feb 6 06:17 .. 5lrwxrwxrwx 1 root root 12 Feb 6 06:17 usb-046d_0825_338DCAC0-video-index0 -\u0026gt; ../../video2 6lrwxrwxrwx 1 root root 12 Feb 6 06:17 usb-046d_0825_338DCAC0-video-index1 -\u0026gt; ../../video3 7lrwxrwxrwx 1 root root 12 Feb 6 06:17 usb-046d_0825_C0A8C1F0-video-index0 -\u0026gt; ../../video0 8lrwxrwxrwx 1 root root 12 Feb 6 06:17 usb-046d_0825_C0A8C1F0-video-index1 -\u0026gt; ../../video1 映像の出力先は、camera_http_options に -p 8080 とポート番号で指定します。\nこれらを踏まえて、デフォルト設定から変更した点は次のとおりです。\n1# webcam1.txt 2-camera_usb_options=\u0026#34;-r 640x480 -f 10\u0026#34; 3+camera_usb_options=\u0026#34;-r 640x480 -d /dev/video0\u0026#34; 4-#camera_http_options=\u0026#34;-n\u0026#34; 5+camera_http_options=\u0026#34;-n -p 8080\u0026#34; 1# webcam2.txt 2-camera_usb_options=\u0026#34;-r 640x480 -f 10\u0026#34; 3+camera_usb_options=\u0026#34;-r 640x480 -d /dev/video2\u0026#34; 4-#camera_http_options=\u0026#34;-n\u0026#34; 5+camera_http_options=\u0026#34;-n -p 8081\u0026#34; 上手くいけば、次のとおり webcamd.service で2つのカメラが制御されるようになります。\n1systemctl status webcamd.service 2● webcamd.service - the FluiddPI webcam daemon (based on OctoPi) with the user specified config 3 Loaded: loaded (/etc/systemd/system/webcamd.service; enabled; vendor preset: enabled) 4 Active: active (running) since Sun 2022-02-06 06:49:48 GMT; 6h ago 5 Process: 378 ExecStart=/usr/local/bin/webcamd (code=exited, status=0/SUCCESS) 6 Tasks: 6 (limit: 3596) 7 CGroup: /system.slice/webcamd.service 8 ├─537 ./mjpg_streamer -o output_http.so -w ./www-mjpgstreamer -n -p 8080 -i input_uvc.so -r 640x480 -d /dev/v 9 └─590 ./mjpg_streamer -o output_http.so -w ./www-mjpgstreamer -n -p 8081 -i input_uvc.so -r 640x480 -d /dev/v 10Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: Format............: JPEG 11Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: TV-Norm...........: DEFAULT 12Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: www-folder-path......: ./www-mjpgstreamer/ 13Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: HTTP TCP port........: 8081 14Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: HTTP Listen Address..: (null) 15Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: username:password....: disabled 16Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: commands.............: disabled 17Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: starting input plugin input_uvc.so 18Feb 06 06:49:47 fluiddpi mjpg_streamer[590]: MJPG-streamer [590]: starting output plugin: output_http.so (ID: 00) 19Feb 06 06:49:48 fluiddpi systemd[1]: Started the FluiddPI webcam daemon (based on OctoPi) with the user specified config 20lines 1-19/19 (END) ここまできたら、後は FluiddPi 側の設定に移ります。\nFluiddPi の設定 まず、http://fluiddpi.local または http://192.168.1.5:7125 にアクセスします。それから、右上のメニューアイコンをクリックしてから Add Printer をクリックします。\nFluiddPi - Menu FluiddPi - Add Printer すると API URL の入力を求められますので、上記の Moonraker のインストールの最後に表示された 192.168.1.5:7126 を入力します。問題がなければ入力欄右側にある雲マークが緑色になりますので、SAVE ボタンを押して保存します。\nFluiddPi - URL 入力 これで Printers にもう1台のプリンタが表示されますので、必要に応じて2台のプリンタの制御画面を切り替えて操作します。\nFluiddPi - プリンタ追加後 ","link":"http://localhost:1313/post/2022-02-24/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"Raspberry Pi 1台で3Dプリンタ2台を動かしつつタイムラプス動画を撮影する方法"},{"body":"","link":"http://localhost:1313/archives/2022/01/","section":"archives","tags":null,"title":"2022/01"},{"body":"前置き Klipper \u0026amp; Moonraker \u0026amp; FluiddPi の組み合わせで 3Dプリンタの印刷の様子をタイムラプス動画にすることに成功しましたので、その方法をまとめます。\nなお、Klipper などのバージョンは次のとおりです。\nfluidd v1.16.2 klipper v0.10.0-208-g247cd753 moonraker v0.7.1-273-g0a541bb 手順の概要 手順を簡単にまとめると次のとおりとなります。なお、カメラの設定は終わっている前提です。\n専用のスクリプトをインストールする Klipper と Moonraker の設定ファイルを編集する スライサーにカスタム G-Code を追加する 手順の詳細 専用のスクリプトのインストール タイムラプス動画は、次のスクリプトを使って撮影します。\nhttps://github.com/mainsail-crew/moonraker-timelapse\nこのスクリプトは、Raspberry Pi に SSH 接続してから次のコマンドを実行すればインストールできます。\n1cd ~/ 2git clone https://github.com/mainsail-crew/moonraker-timelapse.git 3bash ~/moonraker-timelapse/install.sh 設定ファイルの編集 スクリプトをインストールしたら moonraker.conf ファイルに必要な設定を追加します。私が追加した設定は次のとおりです。\nなお、moonraker.conf ファイルはFluiddPi の Configuration から編集できます。\n撮影時にプリントヘッドを中心に移動させる プリントヘッドの移動前にフィラメントを 1mm 引き込む トラベル速度を 90mm/s に設定（デフォルトだと高速過ぎてうるさいので） プリント後に自動で撮影した画像をレンダリングする 1[update_manager timelapse] 2type: git_repo 3primary_branch: main 4path: ~/moonraker-timelapse 5origin: https://github.com/mainsail-crew/moonraker-timelapse.git 6 7[timelapse] 8## Following basic configuration is default to most images and don\u0026#39;t need 9## to be changed in most scenarios. Only uncomment and change it if your 10## Image differ from standart installations. In most common scenarios 11## a User only need [timelapse] in there configuration. 12#output_path: ~/timelapse/ 13## Directory where the generated video will be saved 14#frame_path: /tmp/timelapse/ 15## Directory where the temporary frames are saved 16#ffmpeg_binary_path: /usr/bin/ffmpeg 17## Directory where ffmpeg is installed 18#enabled: True 19#mode: layermacro 20#snapshoturl: http://localhost:8080/?action=snapshot 21#gcode_verbose: True 22parkhead: true 23parkpos: center 24#park_custom_pos_x: 0.0 25#park_custom_pos_y: 0.0 26#park_custom_pos_dz: 0.0 27park_travel_speed: 90 28park_retract_speed: 25 29#park_extrude_speed: 15 30park_retract_distance: 1.0 31#park_extrude_distance: 1.0 32#hyperlapse_cycle: 30 33autorender: True 34#constant_rate_factor: 23 35#output_framerate: 30 36#pixelformat: yuv420p 37#time_format_code: %Y%m%d_%H%M 38#extraoutputparams: 39#variable_fps: False 40#targetlength: 10 41#variable_fps_min: 5 42#variable_fps_max: 60 43#flip_x: False 44#flip_y: False 45#duplicatelastframe: 0 46#previewimage: True 47#saveframes: False 続いて、printer.cfg に次の設定を追加します。\n1[include timelapse.cfg] これで Klipper、Moonraker、FluiddPi 側の設定は完了です。\nスライサーの設定 タイムラプス動画用の写真は、各レイヤーの印刷が終わったタイミングで撮影しますので、スライサーで G-Code を生成する際に、レイヤー移動前に撮影コマンドを実行するように設定します。\nPrusaSlicer/SuperSlicer を使っている場合、Printer Settings -\u0026gt; Custom G-code -\u0026gt; Before layer change Gcode と画面を開き、TIMELAPSE_TAKE_FRAME G-Code として追加します。\nカスタムG-Codeの追加 これで、STL ファイルをスライスして G-Code を生成すると、レイヤー移動前に撮影コマンドが自動的に挿入されますので、後は G-Code をアップロードして印刷すればタイムラプス動画を撮影できます。\n撮影されたタイムラプス動画は、/home/pi/timelapse に mp4 形式で保存されていますので、ホストPCから scp pi@fluiddpi.local:~/timelapse/timelapse_xxx.mp4 ~/Downloads/ コマンドを実行するなどしてダウンロードしてください。\n蛇足 もし、printer.cfg から PAUSE マクロを削除していた場合、印刷を開始すると !! Error evaluating 'gcode_macro TIMELAPSE_TAKE_FRAME:gcode': UndefinedError: 'dict object' has no attribute 'gcode_macro pause' というエラーが発生して印刷がストップしてしまいます。\nエラーの原因は、スクリプトの [gcode_macro TIMELAPSE_TAKE_FRAME] セクション内に {printer.configfile.settings['gcode_macro pause'].rename_existing} というコードがあるためです。そのため、printer.cfg から PAUSE マクロを追加すれば解消できます。\n1[gcode_macro PAUSE] 2rename_existing: BASE_PAUSE 3gcode: 4 PAUSE なお、rename_existing は、既存の同名コマンドを引数に指定したコマンド名にリネームして、実質的に既存の同名コマンドを上書きするものです。\nrename_existing:\nThis option will cause the macro to override an existing G-Code command and provide the previous definition of the command via the name provided here. This can be used to override builtin G-Code commands. Care should be taken when overriding commands as it can cause complex and unexpected results. The default is to not override an existing G-Code command. https://www.klipper3d.org/Config_Reference.html?h=rename#gcode_macro\n","link":"http://localhost:1313/post/2022-01-29/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"Klipper \u0026 Moonraker \u0026 FluiddPi でタイムラプス動画を撮影する方法"},{"body":"前置き Raspberry Pi に Klipper と FluiddPi をインストールして色々と設定を行っていますが、万が一の事態に備えて、RClone を使って設定ファイルをクラウドストレージに定期的にバックアップするようにしまし た。\nそこで、備忘録として実施した手順をメモします。\n手順 手順の変更などに合わせて記事を修正 (2022/04/22) RClone のインストール ホストPCから Raspberry Pi に SSH 接続する sudo ls を実行して root ユーザのパスワードを入力しておく curl https://rclone.org/install.sh | sudo bash でインストール用スクリプトをダウンロードして実行する RClone の設定 RClone をインストールしたら、rclone config を実行して設定ダイアログを起動します。\nなお、ここでは過去に行った設定（ Fuliddpi_backup ）が表示されています。\n1Current remotes: 2 3Name Type 4==== ==== 5Fluiddpi_backup drive ← 過去に行った設定 6 7e) Edit existing remote 8n) New remote 9d) Delete remote 10r) Rename remote 11c) Copy remote 12s) Set configuration password 13q) Quit config 14e/n/d/r/c/s/q\u0026gt; n n を選択して新しい設定を開始します。\n1name\u0026gt; test 設定の名前を入力します。名前は任意のものを設定します。\n1Option Storage. 2Type of storage to configure. 3Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 4Choose a number from below, or type in your own value. 5 1 / 1Fichier 6 \\ \u0026#34;fichier\u0026#34; 7 2 / Alias for an existing remote 8 \\ \u0026#34;alias\u0026#34; 9 3 / Amazon Drive 10 \\ \u0026#34;amazon cloud drive\u0026#34; 11 4 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, SeaweedFS, and Tencent COS 12 \\ \u0026#34;s3\u0026#34; 13 5 / Backblaze B2 14 \\ \u0026#34;b2\u0026#34; 15 6 / Better checksums for other remotes 16 \\ \u0026#34;hasher\u0026#34; 17 7 / Box 18 \\ \u0026#34;box\u0026#34; 19 8 / Cache a remote 20 \\ \u0026#34;cache\u0026#34; 21 9 / Citrix Sharefile 22 \\ \u0026#34;sharefile\u0026#34; 2310 / Compress a remote 24 \\ \u0026#34;compress\u0026#34; 2511 / Dropbox 26 \\ \u0026#34;dropbox\u0026#34; 2712 / Encrypt/Decrypt a remote 28 \\ \u0026#34;crypt\u0026#34; 2913 / Enterprise File Fabric 30 \\ \u0026#34;filefabric\u0026#34; 3114 / FTP Connection 32 \\ \u0026#34;ftp\u0026#34; 3315 / Google Cloud Storage (this is not Google Drive) 34 \\ \u0026#34;google cloud storage\u0026#34; 3516 / Google Drive 36 \\ \u0026#34;drive\u0026#34; 3717 / Google Photos 38 \\ \u0026#34;google photos\u0026#34; 3918 / Hadoop distributed file system 40 \\ \u0026#34;hdfs\u0026#34; 4119 / Hubic 42 \\ \u0026#34;hubic\u0026#34; 4320 / In memory object storage system. 44 \\ \u0026#34;memory\u0026#34; 4521 / Jottacloud 46 \\ \u0026#34;jottacloud\u0026#34; 4722 / Koofr 48 \\ \u0026#34;koofr\u0026#34; 4923 / Local Disk 50 \\ \u0026#34;local\u0026#34; 5124 / Mail.ru Cloud 52 \\ \u0026#34;mailru\u0026#34; 5325 / Mega 54 \\ \u0026#34;mega\u0026#34; 5526 / Microsoft Azure Blob Storage 56 \\ \u0026#34;azureblob\u0026#34; 5727 / Microsoft OneDrive 58 \\ \u0026#34;onedrive\u0026#34; 5928 / OpenDrive 60 \\ \u0026#34;opendrive\u0026#34; 6129 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH) 62 \\ \u0026#34;swift\u0026#34; 6330 / Pcloud 64 \\ \u0026#34;pcloud\u0026#34; 6531 / Put.io 66 \\ \u0026#34;putio\u0026#34; 6732 / QingCloud Object Storage 68 \\ \u0026#34;qingstor\u0026#34; 6933 / SSH/SFTP Connection 70 \\ \u0026#34;sftp\u0026#34; 7134 / Sia Decentralized Cloud 72 \\ \u0026#34;sia\u0026#34; 7335 / Sugarsync 74 \\ \u0026#34;sugarsync\u0026#34; 7536 / Tardigrade Decentralized Cloud Storage 76 \\ \u0026#34;tardigrade\u0026#34; 7737 / Transparently chunk/split large files 78 \\ \u0026#34;chunker\u0026#34; 7938 / Union merges the contents of several upstream fs 80 \\ \u0026#34;union\u0026#34; 8139 / Uptobox 82 \\ \u0026#34;uptobox\u0026#34; 8340 / Webdav 84 \\ \u0026#34;webdav\u0026#34; 8541 / Yandex Disk 86 \\ \u0026#34;yandex\u0026#34; 8742 / Zoho 88 \\ \u0026#34;zoho\u0026#34; 8943 / http Connection 90 \\ \u0026#34;http\u0026#34; 9144 / premiumize.me 92 \\ \u0026#34;premiumizeme\u0026#34; 9345 / seafile 94 \\ \u0026#34;seafile\u0026#34; 95Storage\u0026gt; 16 利用するオンラインストレージを聞かれるので、利用したいものを選択します。今回は Google Drive を使うので、16 を選択しています。\nRClone が対応するオンラインストレージが変更されると番号は変わります。2022年4年22月時点では、Google Drive は 17 になっています。 1Option client_id. 2Google Application Client Id 3Setting your own is recommended. 4See https://rclone.org/drive/#making-your-own-client-id for how to create your own. 5If you leave this blank, it will use an internal key which is low performance. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7client_id\u0026gt; 8Option client_secret. 9OAuth Client Secret. 10Leave blank normally. 11Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 12client_secret\u0026gt; client_id と client_secret を聞かれますが、空欄でOKです。\n1Option scope. 2Scope that rclone should use when requesting access from drive. 3Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 4Choose a number from below, or type in your own value. 5 1 / Full access all files, excluding Application Data Folder. 6 \\ \u0026#34;drive\u0026#34; 7 2 / Read-only access to file metadata and file contents. 8 \\ \u0026#34;drive.readonly\u0026#34; 9 / Access to files created by rclone only. 10 3 | These are visible in the drive website. 11 | File authorization is revoked when the user deauthorizes the app. 12 \\ \u0026#34;drive.file\u0026#34; 13 / Allows read and write access to the Application Data folder. 14 4 | This is not visible in the drive website. 15 \\ \u0026#34;drive.appfolder\u0026#34; 16 / Allows read-only access to file metadata but 17 5 | does not allow any access to read or download file content. 18 \\ \u0026#34;drive.metadata.readonly\u0026#34; 19scope\u0026gt; 1 どのスコープ範囲を適用するか聞かれるので、フルアクセス可能な 1 を選択します。\n（書き込みオンリーの権限がないため、止むを得ずフルアクセスを選択しています。）\n1Option root_folder_id. 2ID of the root folder. 3Leave blank normally. 4Fill in to access \u0026#34;Computers\u0026#34; folders (see docs), or for rclone to use 5a non root folder as its starting point. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7root_folder_id\u0026gt; root_folder_id を聞かれますが、空欄のままでOKです。\n1Option service_account_file. 2Service Account Credentials JSON file path. 3Leave blank normally. 4Needed only if you want use SA instead of interactive login. 5Leading `~` will be expanded in the file name as will environment variables such as `${RCLONE_CONFIG_DIR}`. 6Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). 7service_account_file\u0026gt; service_account_file について聞かれますが、こちらも空欄でOKです。\n1Edit advanced config? 2y) Yes 3n) No (default) 4y/n\u0026gt; n アドバンスト設定を行うか聞かれますので、 n を入力してアドバンスト設定を行わず先に進みます。\n1Use auto config? 2 * Say Y if not sure 3 * Say N if you are working on a remote or headless machine 4 5y) Yes (default) 6n) No 7y/n\u0026gt; n オート設定を行うか聞かれますが、SSH 接続で設定しているので n を選択します。\n1Option config_token. 2For this to work, you will need rclone available on a machine that has 3a web browser available. 4For more help and alternate methods see: https://rclone.org/remote_setup/ 5Execute the following on the machine with the web browser (same rclone 6version recommended): 7 rclone authorize \u0026#34;drive\u0026#34; \u0026#34;eyJzY29wZSI6ImRyaXZlIn0\u0026#34; 8Then paste the result. 9Enter a value. 10config_token\u0026gt; *** この手順は変更されていますので、2022年4月22日に修正しています。 ダイアログに「RClone が使える PC で以下のコードを実行して結果を貼り付けること（意訳）」と指示が表示されますので、指示に従って手元の PC で rclone authorize \u0026quot;drive\u0026quot; \u0026quot;eyJzY29wZSI6ImRyaXZlIn0\u0026quot; を実行します。\nすると、起動したローカルサーバの URL が表示されますので、その URL にアクセスすると Google のアクセス権限設定ページにジャンプします。\n12022/04/19 13:09:19 NOTICE: Config file \u0026#34;/home/***/.config/rclone/rclone.conf\u0026#34; not found - using defaults 22022/04/19 13:09:19 NOTICE: If your browser doesn\u0026#39;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=hogehoge 32022/04/19 13:09:19 NOTICE: Log in and authorize rclone for access 42022/04/19 13:09:19 NOTICE: Waiting for code... 使用するアカウントを選択 アクセスを許可 RClone で使うコードをコピー 1Configure this as a Shared Drive (Team Drive)? 2 3y) Yes 4n) No (default) 5y/n\u0026gt; n 今回使う Google Drive がチームで使うものか聞かれますが、私の Google Drive は個人用なので n を選択します。\n1-------------------- 2[test] 3type = drive 4scope = drive 5token = {\u0026#34;access_token\u0026#34;:\u0026#34;***\u0026#34;,...} 6team_drive = 7-------------------- 8y) Yes this is OK (default) 9e) Edit this remote 10d) Delete this remote 11y/e/d\u0026gt; y これまでの選択に基づいた設定結果が表示されますので、問題がなれば y を選択します。\n1Current remotes: 2 3Name Type 4==== ==== 5Fluiddpi_backup drive 6test drive 7 8e) Edit existing remote 9n) New remote 10d) Delete remote 11r) Rename remote 12c) Copy remote 13s) Set configuration password 14q) Quit config 15e/n/d/r/c/s/q\u0026gt; 設定完了後のリモートドライブの一覧が表示されます。\n設定が上手くできたか確認するため、 rclone ls Fluiddpi_backup: を実行してリモートドライブの内容が表示されるか確認します。きちんと設定できていれば、Google Drive に保存しているファイルがリストアップされます。\n1pi@fluiddpiender3:~ $ rclone ls Fluiddpi_backup: 2 10138 FluiddPi_Prusa/klipper_config/printer.cfg 3 10138 FluiddPi_Prusa/klipper_config/printer-20220110_020804.cfg 4 10152 FluiddPi_Prusa/klipper_config/printer-20220110_020020.cfg 5 ... 続いて、Cron で定期的に実行するバックアップスクリプトを作成します。スクリプトは ~/klipper_backup.sh としました。\nなお、バックアップ先の Google Drive には、あらかじめ FluiddPi_Ender3 という名前でディレクトリを作成しています。\n1#!/bin/bash 2rclone copy klipper_config/ Fluiddpi_backup:FluiddPi_Ender3/klipper_config 3rclone copy -L klipper_logs/ Fluiddpi_backup:FluiddPi_Ender3/klipper_logs スクリプトを作成したら、 chmod 777 ~/klipper_backup.sh コマンドでスクリプトに実行権限を与えます。\nそれから crontab -e で Cron の設定ファイルを開き、バックアップスクリプトを実行する日時を設定します。ここでは、毎日夜中の2時15分にバックアップを実行する設定にしています。\n1# Edit this file to introduce tasks to be run by cron. 2# 3# Each task to run has to be defined through a single line 4# indicating with different fields when the task will be run 5# and what command to run for the task 6# 7# To define the time you can provide concrete values for 8# minute (m), hour (h), day of month (dom), month (mon), 9# and day of week (dow) or use \u0026#39;*\u0026#39; in these fields (for \u0026#39;any\u0026#39;). 10# 11# Notice that tasks will be started based on the cron\u0026#39;s system 12# daemon\u0026#39;s notion of time and timezones. 13# 14# Output of the crontab jobs (including errors) is sent through 15# email to the user the crontab file belongs to (unless redirected). 16# 17# For example, you can run a backup of all your user accounts 18# at 5 a.m every week with: 19# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ 20# 21# For more information see the manual pages of crontab(5) and cron(8) 22# 23# m h dom mon dow command 2415 2 * * * /home/pi/klipper_backup.sh 以上で設定完了です。これで毎日同じ時間にバックアップが実行されます。\n","link":"http://localhost:1313/post/2022-01-16/","section":"post","tags":["備忘録","3Dプリンタ","Klipper"],"title":"RClone を使って Klipper の設定をバックアップする方法"},{"body":"3D プリンタで新しいフィラメントを使う場合、最適な温度やリトラクト長を探し出す必要がありますが、「プリント→結果を確認→設定変更→プリント」という順番で調査すると時間がいくらあっても足りません。そのため、1回のプリントで様々な設定を試せると便利ということになります。\n幸い、スライサー側の機能を使うことで、レイヤー高に応じて設定を変更することが可能となりますので、その方法を紹介します。\nなお、スライサーによって設定方法だけでなくできることも違いますので、スライサー毎に説明します。ただし、結論を先取りしますと、PrusaSlicer/SuperSlicer よりも Cura の方が設定が簡単な上に出来ることも多いので、こういう処理を行う場合は Cura を使うか、G-Code を生成してくれるサービスを利用することをお勧めします。\nCura の場合 まず、一度スライスしてからプレビュー画面に移動し、設定を変更するレイヤーの番号をメモします。ここでは45・90番目のレイヤーで温度を変更し、50番目のレイヤーでリトラクション長を変更するという前提とします。\nまず、Cura のメニューの 「Extensions ｰ\u0026gt; Post Processing ｰ\u0026gt; Modify G-Code」を開きます。\nそれから、Add a script ボタンをクリックして「ChangeAtZ」を追加して Trigger を layer No. にして、Change Layer に設定を変更したいレイヤーの番号を指定します。そして、Apply To を Target Layer + Subsequent Layersにします。これで layer No. より上のレイヤーでは変更した設定が適用されるようになります。\n例えば、最初は250度で印刷し、45番目のレイヤーから上は245度で印刷したいというときは Change Extruder 1 Temp にチェックを入れた上で、Extruder 1 temp に 245 を入力します。\n45番目のレイヤーから上の温度を240度に変更 また、最初はリトラクション長を 1mm で印刷し、50番目のレイヤーから上ではリトラクション長を 2mm にしたいというときは、Change Retraction にチェックを入れてから、Change Retraction Length にもチェックを入れ、Retract Length に 2 を入力します。\nリトラクション長を2mmに変更 あとは、必要な分だけこの設定を繰り返します。\n90番目のレイヤーから上の温度を230度に変更 PrusaSlicer/SuperSlicer の場合 PrusaSlicer/SuperSlicer の場合、温度設定は変更できますが、リトラクション長の変更方法は見つけられていません。\n一応、リトラクション長を変えつつ一度のプリントで9つのモデルを印刷するという方法はあるようですが、思わぬ失敗で時間を無駄にしそうなので挑戦していません。\n温度設定を変更する方法は、一度スライスしてからプレビュー画面に移動し、右側のスクロールバーを設定を変更するレイヤーに合わせます。\nそれから、そのレイヤーで右クリックして「カスタムG-Codeの追加」をクリックします。\nカスタムG-Codeの追加 カスタムG-Codeの追加（拡大） するとカスタム G-Code の入力画面が開きますので、以下のコードを追加します。なお、コードは上から順番に実行されるようです。\n1M106 S0; 2M104 S240; 3M109 S240; 4M106 S255 M106 S0 パーツ冷却ファンをストップさせるコマンドです。これがないと、エクストルーダーの温度が設定温度になるまでの間、同じ個所を冷やし続けることになります。 M104 S240 エクストルーダーの温度が240度に設定するコマンドです。設定温度に到達する前に次のコマンドに移ります。 M109 S240 エクストルーダーの温度が240度になるまで待機するというコマンドです M106 S255 パーツ冷却ファンの回転数を元に戻す（ここでは全開にする前提）コマンドです。これがないと、パーツ冷却ファンがストップしたままとなります。 以上で PlusaSlicer/SuperSlicer を使ってレイヤー高に応じて設定を変える方法を紹介しましたが、正直な所、Cura と比較して明らかに面倒になります。\nなので、もっと楽をする方法を紹介します。\nウェブページで G-Code を生成する方法 YouTube で3Dプリンタの情報を中心に色々な解説動画を出している Teaching Tech が 3Dプリンタのキャリブレーションテクニックなどをまとめたページを作成しています。\nTeaching Tech 3D Printer Calibration\nこちらでは温度調整やリトラクト長の調整のための G-Code を生成することが出来ますので、こちらで G-Code を生成して印刷するとスライサーの設定をしなくても必要な G-Code が作れます。\nまとめ 新しいフィラメントを使う場合、温度設定やリトラクション長などは試行錯誤して最適値を割り出す必要がありますので、上記の方法を利用すると最適値の探索が少し楽になります。\n一度最適値を割り出してしまえば、その設定値はずっと使えますので、上記の方法が何かの役に立てば幸いです。\n","link":"http://localhost:1313/post/2022-01-07/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"PrusaSlicer/SuperSlicer で 一定のレイヤー毎に温度を変化させる方法"},{"body":" 目次 前置き 作業の順番 FluiddPi のインストール Kiuah のインストール Klipper ファームウェアのビルド \u0026amp; インストール Klipper の設定 移動距離の調整 PID チューニング Pressure advance の調整 コマンドでファームウェアを再起動 Input Shaper スライサーと FluiddPi を繋ぐ方法 G-Code の問題 position_min の設定 BLTouch の使い方 プローブの Z-Offset の調整 Mesh Bed Leveling のトラブル その他のエラー対策 printer.cfg 等の設定ファイルの保存場所 前置き 我が家の3Dプリンタのファームウェアを Marlin から Klipper に変更し、あわせてプリンタ操作ツールを OctoPrint から FluiddPi に変更しましたので、インストール方法などをメモしておきます。\n順不同であれこれ書いていますので、必要に応じて上の目次を利用してください。\n作業の順番 作業は次の順番で行います。\nFluiddPi をRaspberryPi にインストール 1.の RaspberryPi に Kiuah をインストール Kiuah を使って Klipper をインストール Klipper を設定 FluiddPi のインストール FluiddPI - Fluidd からイメージファイルをダウンロードし、Raspberry Pi Imager を使って MicroSD カードにイメージファイルを書き込みます。\nイメージを書き込んだら、MicroSD カードの fluiddpi-wpa-supplicant.txt ファイルを開いて無線LANの設定を行います。それからカードを RaspberryPi に差し込んで起動します。\nRaspberryPi が起動してしばらくしたら、作業用PCで ssh pi@fluiddpi.local コマンドを実行して RaspberryPi に SSH 接続し、sudo raspi-config を実行して次の設定を行います。\nSystem Options -\u0026gt; Password でパスワードを変更します Localization Options -\u0026gt; Timezone でタイムゾーンを変更します Localization Options -\u0026gt; Locale でローカル設定を変更します 必要に応じて System Options -\u0026gt; Hostname でホスト名を変更します http://fluidd.local にアクセスして FluiddPi の画面が表示されることを確認します。\nFluiddPi の画面が表示されたら、ひとまずカメラの設定を行います。\n私は Logitech の C270 カメラを利用していますので、左の Configuration タブにある webcam.txt ファイルを開いて camera_usb_options をアンコメントします。画面解像度は、FluiddPi の中の小さな画面で見ますので 640x480 とし、フレームレートを 30 にしています。\nそれから Settings の Cameras でカメラを追加します。Stream type は MJPEG Adaptive にします。\nKiuah のインストール Klipper のビルドや各種アップデートを簡単に行うため、Kiuah をインストールします。インストールは以下のコマンドで行います。\n1cd ~ 2git clone https://github.com/th33xitus/kiauh.git Klipper ファームウェアのビルド \u0026amp; インストール Kiuah をインストールしたら、./kiauh/kiauh.sh を実行し、4) [Advanced] を選択してメニューを開きます。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~~~ [ Main Menu ] ~~~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| 0) [Upload Log] | Klipper: Installed: 1 | 10| | Branch: master | 11| 1) [Install] | | 12| 2) [Update] | Moonraker: Installed: 1 | 13| 3) [Remove] | | 14| 4) [Advanced] | Mainsail: Not installed! | 15| 5) [Backup] | Fluidd: Installed! | 16| | KlipperScreen: Not installed! | 17| 6) [Settings] | Telegram Bot: Not installed! | 18| | | 19| | DWC2: Not installed! | 20| v3.1.0-85 | Octoprint: Not installed! | 21|-------------------------------------------------------| 22| Q) Quit | 23\\=======================================================/ 24Perform action: 4 メニューを開いたら、3) [Build only] を選択してファームウェアビルドのオプション画面に移ります。\n1/=======================================================\\ 2| ~~~~~~~~~~~~~~~~~ [ KIAUH ] ~~~~~~~~~~~~~~~~~ | 3| Klipper Installation And Update Helper | 4| ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | 5\\=======================================================/ 6/=======================================================\\ 7| ~~~~~~~~~~~~~ [ Advanced Menu ] ~~~~~~~~~~~~~ | 8|-------------------------------------------------------| 9| Klipper: | Mainsail: | 10| 1) [Switch Branch] | 7) [Theme installer] | 11| 2) [Rollback] | | 12| | System: | 13| Firmware: | 8) [Change hostname] | 14| 3) [Build only] | | 15| 4) [Flash only] | Extensions: | 16| 5) [Build + Flash] | 9) [Shell Command] | 17| 6) [Get MCU ID] | | 18| | CustomPiOS: | 19| | 10) [Migration Helper] | 20|-------------------------------------------------------| 21| B) « Back | 22\\=======================================================/ 23Perform action: 3 ファームウェアビルドのオプション画面が開きますので、必要な設定を行って保存するとファームウェアがビルドされて ~/klipper/out/klipper.elf に保存されます。\nあとは、作業用 PC で scp pi@fluiddpi.local:~/klipper/out/klipper.bin ~/ を実行してファームウェアをダウンロードし、プリンタに書き込みます。\nKlipper の設定 Klipper の設定は、~/klipper_config/printer.cfg を編集して行います。\nFliddpi をインストールした RaspberryPi の ~/klipper/config/ ディレクトリには主要なマザーボードの設定例が保存されていますので、自分に合ったものを cp ~/klipper/config/generic-einsy-rambo.cfg ~/klipper_config/printer.cfg でコピーして編集していきます。なお、FluiddPi の Configuration タブの Other Files の CONFIG_EXAMPLES からも同じ設定例にアクセスできます。\nなお、Prusa MK3S+ については、Klipper の Github のプルリクに「Prusa i3 MK3S に合わせた printer.cfg を作成したので config/printer-prusa-mk3s-2021.cfg として追加して欲しい」とがありましたので、これを元に設定していきました。\n移動距離の調整 Marlin では「プリンタを 1mm 動かすのにステッピングモーターを何ステップ動かすか」を設定する steps_per_mm でプリントヘッドやベッドの移動距離を調整していましたが、Klipper では「ステッピングモーターが完全に1回転したときに軸方向に動く距離」を設定する rotation_distance で調整します。\nklipper/docs/Rotation_Distance.md at master · Klipper3d/klipper\n\u0026#x2139; 以前は `step_distance` という項目で調整されていましたが、2021年11月2日の変更でこの項目は使えなくなっています。 rotation_distance を求める方法は次の4つですが、上記で説明した printer.cfg の見本には標準的な値が設定されていますので、そちらを用いて微調整する方が早いと思います。\nrotation_distance の値はプリンタの部品で決まるため、printer.cfg の見本がない場合、同じ部品を使っているプリンタの値を流用すれば大丈夫だと思います。\nベルトのピッチとプーリーの歯の数から求める方法 (XY 軸) リードスクリューのピッチとスレッド数から求める方法 (Z 軸) エクストルーダーのホブボルトの直径から求める方法 (エクストルーダー) step_distance から求める方法 (古い設定例を用いる場合) 調整方法の具体的な内容 ベルトのピッチとプーリーの歯の数から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\n1rotation_distance = ベルトのピッチ数 * プーリーの歯の数 2（筆者翻訳） 2mmピッチのベルトと20歯のプーリーを使っていれば 2 * 20 = 40 となります。\nリードスクリューのピッチとスレッド数から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\n1rotation_distance = ピッチ数 * スレッド数 2（筆者翻訳） 3Dプリンタで良く使われる T8 リードスクリューの場合、ピッチ数が 2 でスレッド数が 4 なので、2 * 4 = 8 となります。\nエクストルーダーのホブボルトの直径から求める方法 ホブボルトとは、次の写真のような溝付きボルトのことのようです。このボルトの直径を公式リファレンスに掲載されている計算式に代入して求めます。\n1rotation_distance = \u0026lt;diameter\u0026gt; * 3.14 ただ、エクストルーダーの場合、後述の「rotation_distance の調整」に沿って調整する方が手っ取り早いと思います。\nstep_distance から求める方法 公式リファレンスに掲載されている次の計算式で求めます。\n1rotation_distance = \u0026lt;full_steps_per_rotation\u0026gt; * \u0026lt;microsteps\u0026gt; * \u0026lt;step_distance\u0026gt; full_steps_per_rotation ステッピングモーターが一回転するためのステップ数です。モーターの最小回転角が 1.8度なら 200 に、0.9度なら 400 になります。 私の Prusa で使用中のモーターは全て最小回転角が1.8度なので、200 を代入します。\nmicrosteps モータードライバーのマイクロステッピング機能です。大抵の場合 1/16 なので 16 を代入します。Prusa の TMC2130 も 1/16 です（実際は補間機能で 1/256 になっています）。 TMC2130 のマイクロステッピングは、Trinamic が公表しているデータシートの86ページで確認できます。\nギア比の設定 エクストルーダーなどにギアボックス (BMG Extruder 等) を使っている場合、歯車の歯の数の比に応じて gear_ratio: 50:17 のように設定します。\n注意点は、商品説明で「3:1」のギア比と紹介されていても、歯車の数は「50:17」となっていたりしますので、設定値は歯車の歯の数に基づく必要があります。\nrotation_distance の調整 エクストルーダーの rotation_distance の値の調整は、100ミリ押し出した時に何ミリ押し出されたか確認し、その値を元に 実際に押し出された距離 / 100mm * 現在の設定値 を計算して行います。\nXYZ 軸については、XYZ 20mm Calibration Cube by iDig3Dprinting - Thingiverse を印刷して XYZ 方向の実測値を元に 実測値 / 20mm * 現在の設定値 を計算して調整します。\nなお、’rotation_distance は、steps_per_mm` とは違い、値が小さくなるほど移動量が増えることに注意が必要です。\nPID チューニング エクストルーダーのチューニングは PID_CALIBRATE HEATER=extruder TARGET=170 コマンドで行います。コマンドを実行して結果が出たら、SAVE_CONFIG コマンドを実行してチューニング結果を printer.cfg に保存します。ベッドのチューニングは PID_CALIBRATE HEATER=heater_bed TARGET=60 コマンドで同様に行います。\nPressure advance の調整 Pressure advance は、Marlin の Linear_advance に相当する機能です。\n調整方法は Klipper の公式リファレンスに掲載されていますが、簡単に言うと、プリンタの設定を一時的に変更してからテスト印刷し、その結果から設定値を計算して printer.cfg に設定するというものです。\nまず、SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 コマンドを実行してコーナーの速度を落とします。速度を落とす理由は、コーナーでエクストルーダーの押し出し効果を強調するためです。\n次に、TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 を実行して、1レイヤー毎に PRESSURE_ADVANCE のパラメータを 0 から 0.005 ずつ増やしていきます。なお、ボーデン型のプリンタを使っている場合、FACTOR=.005 を FACTOR=.020 にします。\nそれから square_tower.stl を次の設定で印刷します。\nレイヤーの高さ ノズルの直径の 75% とするよう指示されていますので、0.4mm ノズルなら 0.3mm とします。 速度 100mm/s のような高速にし、スライサーの加速度コントロール機能は無効にします。 インフィル 0% にします。 トップレイヤー 不要なので 0 とします。 印刷が終わったら、底面からコーナーの造形がダメになる部分までの高さを測り、次の式で PRESSURE_ADVANCE のパラメータを求めます。なお、この印刷は「上のレイヤーほどコーナーの造形がダメになる」ので、コーナーの造形がダメになった時点で印刷を中止すると時間の節約になります。\n底面から造形がダメになる部分までの高さを計測 Klipper documentation Pressure advance より 1pressure_advance = \u0026lt;start\u0026gt; + \u0026lt;measured_height\u0026gt; * \u0026lt;factor\u0026gt;. 2(For example, 0 + 12.40 * 0.005 would be 0.062.) なお、PRESSURE_ADVANCE のパラメータは、温度やフィラメントによって異なりますので、その都度調べる必要があります。\nThe pressure advance value is dependent on the extruder, the nozzle, and the filament. It is common for filament from different manufactures or with different pigments to require significantly different pressure advance values. Therefore, one should calibrate pressure advance on each printer and with each spool of filament.\nPRESSURE_ADVANCE の値は、エクストルーダー、ノズルまたはフィラメントに依存します。メーカーや顔料が異なるフィラメントでは、PRESSURE_ADVANCE の値が大きく異なるのが一般的です。そのため、フィラメントスプール毎またはプリンター毎に PRESSURE_ADVANCE の値を調整するべきです。（拙訳）\nPressure advance - Klipper documentation より引用\nコマンドでファームウェアを再起動 次のコマンドでファームウェアを再起動できます。これで再起動できない場合、本体の電源を切ることになります。\n1curl -X POST fluiddpi.local/printer/firmware_restart Moonraker Docs » Client Developers » Client API\nInput Shaper Input Shaper とは、プリンタ自身の振動をキャンセルして印刷物の品質を向上させる機能で、Klipper オリジナルの機能です。大量の計算を必要とするため、現時点では RapberryPi をプリンタの MCU として使用する Klipper しか実現できない機能ではないかと思います。\nInput shaping is an open-loop control technique which creates a commanding signal that cancels its own vibrations.\nInput Shaping は、プリンタ自身の振動をキャンセルする制御信号を作成するオープンループの技術です。（拙訳）\nこの機能を使うにはプリンタ特有の振動を調べる必要があり、調査方法は、手動＆目視で行う方法と加速度センサーを使う方法の2つがあります。最初は手動＆目視で調査を試みましたが、確認が難しかったため加速度センサーを使うことにしました。\n事前準備 Input Shaper の測定はハードとソフトの両方で事前準備が必要ですので、それぞれ説明します。\nハードの準備 まず、加速度センサーを入手する必要があります。使うセンサーは ADXL345 で、私は Amazon で販売されている HiLetgo のセンサーを使っています。\nHiLetgo® 2個セット GY-291 ADXL345 3軸デジタル 加速度モジュール 重力 加速度 チルトセンサモジュール 傾斜センサモジュール 傾斜センサ [並行輸入品] このセンサーで XY 軸の振動をそれぞれ計測しますが、X 軸の計測ではセンサーをエクストルーダーに、Y 軸の計測ではセンサーをベッドに固定する必要があるため、センサーマウントを設計しました。\nADXL345 をプリントヘッドに取り付け ADXL345 をベッドに取り付け このセンサーと Raspberry Pi の接続は次のとおりです。ジャンパワイヤを1本ずつ繋ぐのは面倒なので、2x4 のコネクタと 1x4 のコネクタを作成して少しでも配線を楽にしました。\nKlipper documentation Measuring_Resonances.html#wiring より ソフトの準備 RapberryPi で Input Shaper の計算を行うため、Python で数値計算を効率的に行うための拡張モジュールである numpy をインストールします。\nインストールは、SSH コマンドで Raspberry pi にログインしてから ~/klippy-env/bin/pip install -v numpy コマンドを実行して行います。インストールに時間がかかるのでしばし待機します。\nnumpy をインストールしたら、sudo apt update でパッケージを更新してから sudo apt install python-numpy python-matplotlib を実行して numpy が依存するライブラリをインストールします。\n次に RapberryPi の MCU を klipper のためのセカンダリ MCU として使うための設定を行います。\nまず、以下のコマンドを実行して、RapberryPi をセカンダリ MCU として使うためのスクリプトをデーモンに登録します。\n1cd ~/klipper/ 2sudo cp \u0026#34;./scripts/klipper-mcu-start.sh\u0026#34; /etc/init.d/klipper_mcu 3sudo update-rc.d klipper_mcu defaults 次に sudo raspi-config を実行して Raspberry Pi の設定画面を開き、3 Interface Options -\u0026gt; P4 SPI と設定画面を開いて SPI 機能を有効化します。\nそれから次のコマンドを実行して Klipper のビルドオプション画面を開きます。ビルドオプションでは、Microcontroller Architecture を Linux process にして設定を保存します。\n1cd ~/klipper/ 2make menuconfig そして、次のコマンドを実行してファームウェアのビルドと書き込みを行います。\n1sudo service klipper stop 2make flash 3sudo service klipper start これで RapberryPi をセカンダリ MCU として使う準備が出来ましたので、printer.cfg に次の設定を追加します。\n1[mcu rpi] 2serial: /tmp/klipper_host_mcu 3 4[adxl345] 5cs_pin: rpi:None 6 7[resonance_tester] 8accel_chip: adxl345 9probe_points: 10 100,100,20 # an example 以上で事前準備は完了です。\n測定 センサーをプリンタに固定して RapberryPi に接続したら、FluiddPi から SHAPER_CALIBRATE AXIS=X コマンドを実行して計測と調整を行います。センサーの XYZ 軸の方向を計測したい方向に合わせます。測定が終わったら SAVE_CONFIG を実行して測定結果に基づく設定値を printer.cfg に保存します。\nADXL345 の測定向きを計測方向に合わせる 1// 測定結果 2[x-axis] 321:14:50 // Wait for calculations.. 421:14:51 // Calculating the best input shaper parameters for x axis 521:14:52 // Fitted shaper \u0026#39;zv\u0026#39; frequency = 59.4 Hz (vibrations = 8.1%, smoothing ~= 0.050) 621:14:52 // To avoid too much smoothing with \u0026#39;zv\u0026#39;, suggested max_accel \u0026lt;= 13800 mm/sec^2 721:14:54 // Fitted shaper \u0026#39;mzv\u0026#39; frequency = 54.0 Hz (vibrations = 0.2%, smoothing ~= 0.070) 821:14:54 // To avoid too much smoothing with \u0026#39;mzv\u0026#39;, suggested max_accel \u0026lt;= 8600 mm/sec^2 921:14:56 // Fitted shaper \u0026#39;ei\u0026#39; frequency = 64.0 Hz (vibrations = 0.0%, smoothing ~= 0.079) 1021:14:56 // To avoid too much smoothing with \u0026#39;ei\u0026#39;, suggested max_accel \u0026lt;= 7600 mm/sec^2 1121:14:57 // Fitted shaper \u0026#39;2hump_ei\u0026#39; frequency = 79.8 Hz (vibrations = 0.0%, smoothing ~= 0.085) 1221:14:57 // To avoid too much smoothing with \u0026#39;2hump_ei\u0026#39;, suggested max_accel \u0026lt;= 7100 mm/sec^2 1321:14:59 // Fitted shaper \u0026#39;3hump_ei\u0026#39; frequency = 95.8 Hz (vibrations = 0.0%, smoothing ~= 0.089) 1421:14:59 // To avoid too much smoothing with \u0026#39;3hump_ei\u0026#39;, suggested max_accel \u0026lt;= 6700 mm/sec^2 1521:14:59 // Recommended shaper_type_x = mzv, shaper_freq_x = 54.0 Hz 1621:14:59 // Shaper calibration data written to /tmp/calibration_data_x_20211229_211233.csv file 1721:14:59 // The SAVE_CONFIG command will update the printer config file 18// with these parameters and restart the printer. なお、測定結果には加速度の上限値 (suggested max_accel \u0026lt;= 8600 mm/sec^2) も表示されていますが、加速度は SAVE_CONFIG コマンドでは保存されないため、手動で [printer] セクションの max_accel を修正します。\n1[printer] 2max_accel: 4000 スライサーと FluiddPi を繋ぐ方法 Cura の場合 Settings → Printer → Manage Printers → Connect Octoprint → Add の順番で設定画面を開き、接続名称と IP アドレスを入力します。それから Connect ボタンをクリックしますと接続します（API Key は不要）。\nCura の設定画面 Cura の設定画面 PrusaSlicer / SuperSlicer の場合 右パネルのプリンタメニューの右側の歯車アイコンをクリックして “Add physical printer” を開き、ホスト名に fluiddpi.local (ホスト名を変更している場合は変更後のホスト名) を入力し、テストボタンをクリックします。API Key は入力不要です。\nPrusaSlicer/SuperSlicer の設定画面 G-Code の問題 Klipper 非対応の G-Code PrusaSlicer と SuperSlicer の Start G-code にある M862.3 と M862.1 は、Prusa のオリジナル G-Code なので、Klipper に読み込ませても Unknown command:\u0026quot;M862.3\u0026quot; となってしまいます。また、G29 と G80 も Klipper は対応していないので、マクロとして登録する必要があります。\n1[gcode_macro G29] 2gcode: 3 G28 4 BED_MESH_CALIBRATE 5 6[gcode_macro G80] 7gcode: 8 BED_MESH_CALIBRATE 9 G1 X0 Y0 Z0.4 F4000 G-code - RepRap - M862 G-code - RepRap - G29 G-code - RepRap - G80 Cura でスライスした場合の問題 Cura でスライスした場合、最初のノズル加熱の G-Code が M104 S210 � となり、プリンタがこのコードに到達した時点で停止してしまうという不具合に遭遇しました。\nPrusaSlicer や SuperSlicer では発生しないので、考えられる原因は、Cura がノズルの温度を小数点以下第1位 (ex: 220.0) まで指定できることではないかと思っています。\n手作業で修正すれば OK なのですが、面倒なので Ender 3 Pro で印刷するときは Cura ではなく SuperSlicer を使うようにしました。\nposition_min の設定 Ender 3 Pro のエクストルーダー改造により、ベッドを Y=0 の場所まで移動させるとノズルがベッドからはみ出してしまう状態になっています。\nノズルのはみ出し状況 この状態だと Y=0~20 の部分が印刷に使えないため、[stepper_y] セクションに次の設定を追加して、ノズル位置のオフセットを行っています。\n1[stepper_y] 2position_endstop: -20 3position_min: -20 BLTouch の使い方 マザーボードとの接続方法 SKR mini e3 V2.0 と BLTouch は、BIGTREETECH の Github に掲載されている次の写真のとおり接続します。\nhttps://github.com/bigtreetech/BIGTREETECH-SKR-mini-E3/blob/master/hardware/BTT SKR MINI E3 V2.0/Hardware/bltouch-2.0-1.jpg より Github には、次の写真のように Z 軸のエンドストップに接続する方法も掲載されていますが、こちらでは上手くいきません。\nhttps://github.com/bigtreetech/BIGTREETECH-SKR-mini-E3/blob/master/hardware/BTT SKR MINI E3 V2.0/Hardware/bltouch-2.0-2.jpg より Klipper で BLTouch を Z 軸のエンドストップとして使う場合、[stepper_z] セクションの endstop_pin を endstop_pin: probe: z_virtual_endstop と指定するため、BLTouch の Zmin は、SKR mini e3 V2.0 の Z-STOP(PC2) ではなく PROBE(PC14) に接続します。\nIf the BL-Touch will be used to home the Z axis then set endstop_pin: probe:z_virtual_endstop and remove position_endstop in the [stepper_z] config section, then add a [safe_z_home] config section to raise the z axis, home the xy axes, move to the center of the bed, and home the z axis\nBLTouch を Z 軸のホーミングで使うなら、endstop_pin: probe:z_virtual_endstop を設定するとともに、position_endstop を [stepper_z] セクションから削除します。それから、XY 軸のホーミングの時に Z 軸を持ち上げて、Z 軸のホーミングでベッドの中心に移動するために [safe_z_home] セクションを追加します。（拙訳）\nBL-Touch - Klipper documentation より\n1[stepper_z] 2endstop_pin: probe:z_virtual_endstop 3#position_endstop: 0.0 BIGTREETECH-SKR-mini-E3/BTT SKR MINI E3 V2.0SCHpdf.PDF at master · bigtreetech/BIGTREETECH-SKR-mini-E3 より そして、printer.cfg の [bltouch] セクションにピンの設定を追加します。\n1[bltouch] 2sensor_pin = ^PC14 3control_pin = PA1 4pin_up_reports_not_triggered = false 5probe_with_touch_mode = true ちなみに、3DTouch の各ピンと SKR mini e3 V2.0 のピンの対応関係は次のとおりです。BLTouch のクローン品である 3DTouch は、オリジナルの BLTouch とワイヤーのカラーが違いますが、各ピンの用途は同じです。\nBLTouch のワイヤーカラー 3DTouch のワイヤーカラー 用途 SKR mini e3 V2.0 の対応するピン Klipper の対応する設定 Brown White GND GND *** Red Black 5V 5V *** Orange Yellow Control Signal PA1 (SERVOS) control_pin Black Red GND GND *** White Blue Z min PC14 (PROBE) sensor_pin Creality3D CR-10S Pro | antclabs より [safe_z_home] セクションの設定 Z 軸のホーミング時に、どの場所にノズルを下ろすか、下ろすときの速度、2回目のプロービングの速度などを設定します。\n1[safe_z_home] 2home_xy_position: 115,115 # Change coordinates to the center of your print bed 3speed: 50 4z_hop: 10 # Move up 10mm 5z_hop_speed: 5 プローブピンのオフセット設定 ノズルとプローブピンの位置のずれを設定します。以下の設定値のうち、x_offset はエクストルーダー改造 MOD の作者が指定した値であり、y_offset は実測値に基づいて設定した値です。\n1[bltouch] 2x_offset = 38.2 3y_offset = -5 4#z_offset = 0 z_offset は、最初は設定しますが、次に説明する Z-Offset の調整を行ったら自動でコメントアウトされ、新しい設定値が printer.cfg ファイルの末尾に自動で追加されます。\nプローブの Z-Offset の調整 G28 でホーミングしてから PROBE_CALIBRATE コマンドを実行すると測定地点に移動しますので、TESTZ Z=-x.x or TESTZ Z=+x.x を実行して、シックネスゲージの 0.1mm ゲージが若干引っ掛かるところまでノズルの位置を調整します。\nちょうど良いところまでノズルが下がったら、ACCEPT コマンドを実行してから SAVE_CONFIG コマンドを実行し、オフセット値を printer.cfg に保存します。\nメッシュベッドレベリングの設定 メッシュベッドレベリングを行う場合、printer.cfg に [bed_mesh] セクションを追加して測定個所やポイント数などを設定します。\nmesh-min の場所が最初の測定個所で、mesh_max の場所が最後の測定個所となります。重要な点として、Klipper はここで設定した座標にプローブピンを下ろしますが、プローブピンのオフセット値を考慮しない座標を設定すると、ノズルの位置がマイナスになって Move out of range というエラーが発生することがあります。\n私の場合、プローブピンがノズルから X 方向に +38.2 ずれていますので、X: 0~38.1 の範囲を測定個所に指定しますと、ノズルの位置が X: -38.2~-0.1 となりエラーとなります。\n1[bed_mesh] 2speed = 60 3horizontal_move_z = 6 4mesh_min = 40, 10 5mesh_max = 190, 210 6probe_count = 5, 5 7mesh_pps = 2,2 probe_count は、mesh_min と mesh_max の2点を結んだ長方形を何分割して測定するかというものです。具体的な動作は次の図のとおりです。\nBed Mesh - Klipper documentation より mesh_pps は、プロービング地点とプロービング地点の間の高低差を補間します場合のポイント数を指定するもので、mesh_pps = 2,2 は、XY でそれぞれ補間するポイントの数を2つにするというものです。\nBed Mesh - Klipper documentation より メッシュベッドレベリングの結果に基づくベッドのネジ調整(Prusa限定) (2022年1月16日追記)\nPrusa の定番改造の1つに、ナイロンナットを使ってベッドの高さを厳密に調整できるようにするというものがあります（ PRUSA i3 MK3 Nylock Bed Leveling - YouTube 参照）。\n私はナイロンナットの代わりにシリコンチューブを使う方法（Silicone Bed Level Mod Prusa MK3 – SCHWEINERT.COM 参照）を採用していますが、どちらの方法でも、メッシュベッドレベリングの計測結果から中心部を除く8つのネジの回転量を計算する必要があります。\nOctoPrint にはそのためのプラグイン（PrusaOwners/OctoPrint-PrusaMeshMap: This plugin performs a mesh bed leveling operation then returns the results as an easy to read heatmap. がありますが、FluiddPi にはそうした機能がありません。\nそのため代替手段が必要になりますが、Convert g81 absolute values to relative ones. を使えば、メッシュベッドレベリングの結果を元にネジの回転量を計算してくれます。\n作業の流れは次のとおりです。\nベッドを加熱する（ex: 60℃） 左のメニューの Tune を開いて XYZ のホーミングを行う CALIBRATE をクリックしてメッシュベッドレベリングを行う 測定結果を SAVE_CONFIG コマンドで printer.cfg に保存する printer.cfg に保存された測定結果を Convert g81 absolute values to relative ones. に貼り付ける 求められたネジの回転量に従ってネジを回す に戻って調整結果の確認と再調整を行い、納得できるまで繰り返す。 測定結果を毎回 printer.cfg に保存するのは無駄に見えますが、FluiddPi のターミナルに表示される測定結果を Convert g81 absolute values to relative ones. の形式に整えるのは面倒なのに対し、printer.cfg に保存した測定結果の形式を整えるのは相対的に楽なので、測定結果を printer.cfg に保存してから作業を行っています。\n1FuliddPi のターミナルに表示される測定結果 217:09:21 3// probe at 1.806,14.998 is z=2.166976 417:09:26 5// probe at 39.303,14.998 is z=2.076594 6,. 717:11:00 8// probe at 114.297,215.002 is z=1.853148 917:11:05 10// probe at 151.794,215.002 is z=1.687447 1//printer.cfg に保存される測定結果 2#*# 0.075000, 0.032500, -0.001250, 0.030000, 0.052500 3#*# 0.081250, 0.061250, -0.022500, 0.011250, 0.026250 4#*# 0.040000, -0.007500, -0.008750, 0.011250, -0.022500 5#*# 0.070000, 0.058750, 0.083750, 0.033750, 0.035000 6#*# 0.102500, 0.062500, 0.083750, 0.072500, 0.071250 Convert g81 absolute values to relative ones. の貼り付け画面 Mesh Bed Leveling のトラブル Mesh Bed Leveling が途中で停止する現象に悩まされていましたが、Discord の The 602 Wastelan の投稿を元に horizontal_move_z: 2 を horizontal_move_z: 5 に変更したところ、きちんとレベリングしてくれるようになりました。\n4隅のレベリング調整機能 Ender 3 Pro は、ベッドの4隅にあるネジで高さを調整してベッドの水平を出しますが、Klilpper には、BLTouch で4隅の高さを測り、ベッドを水平にするにはネジをどれだけ回せば良いか教えてくれる機能が備わっています。\nManual leveling - Klipper documentation 参照\nこの機能を使うには、printer.cfg に [screws_tilt_adjust] セクションを追加して測定個所を設定します。\n1[screws_tilt_adjust] 2screw1: 0, 32.5 3screw1_name: front left screw 4screw2: 164.3, 32.5 5screw2_name: front right screw 6screw3: 164.3, 202.5 7screw3_name: rear right screw 8screw4: 0, 202.5 9screw4_name: rear left screw 10horizontal_move_z: 10 11speed: 30 12screw_thread: CW-M4 ここで指定している座標値はノズルを下ろす場所なので、ノズルとプローブピンの位置のずれを考慮して座標を指定する必要があります。\nEnder 3 Pro のネジの場所は、次の図のとおりベッドの角から XY 方向に 32.5mmの場所に中心点があります。\nEnder 3 Pro のネジの配置 よって、最初の点（左手前）は X:32.5 Y:32.5 を測定すべきですが、プローブピンがノズルから X方向に +38.2 ずれているため、やむを得ず X:0 Y:32.5 を測定しています。この設定だと X:38.2 Y:32.5 を測定することになります。その次の2番目の点（右手前）の X座標は 235-32.5-38.2 で求めています。\n設定が終わったら SCREWS_TILT_CALCULATE コマンドを実行します。そうすると、FluiddPi のターミナルに測定結果とネジの回転量が出力されるので、ネジを回して再度 SCREWS_TILT_CALCULATE コマンドを実行し、可能な限りベッドが平面になるように調整していきます。\n1// 調整途中の結果のため、座標値は上の設定値と異なっている 222:31:02 $ SCREWS_TILT_CALCULATE 322:31:08 // probe at 0.000,57.500 is z=0.845000 422:31:16 // probe at 159.800,57.500 is z=2.102500 522:31:25 // probe at 159.800,227.500 is z=1.970000 622:31:33 // probe at 0.000,227.500 is z=0.862500 722:31:33 // 01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise 822:31:33 // front left screw (base) : x=0.0, y=57.5, z=0.84500 922:31:33 // front right screw : x=159.8, y=57.5, z=2.10250 : adjust CCW 01:48 1022:31:33 // rear right screw : x=159.8, y=227.5, z=1.97000 : adjust CCW 01:36 1122:31:33 // rear left screw : x=0.0, y=227.5, z=0.86250 : adjust CCW 00:02 なお、ここにある時計回り・反時計回りは、ベッドを上から見た場合の回転方向です。\nクローン品を使うための追加設定 純正の BLTouch ではなくクローン品の 3DTouch を使っているせいか、Failed to verify BLTouch probe is raised; retrying. というエラーと No trigger on probe after full movement というエラーが発生したため、以下の設定を追加して対応しています。\n1[bltouch] 2pin_up_reports_not_triggered = false 3probe_with_touch_mode = true その他のエラー対策 上記以外のエラーとその対応策をメモします。\nEndstop x still triggered after retract 原因は不明ですが、センサーレスホーミングを使っている状態で [stepper_x], [stepper_y] セクションの homing_retract_dist: に 0 以外を設定していると発生します。\nhoming_retract_dist: に 5 とかの値を設定していると、エクストルーダーやベッドが端に衝突した後に設定値の分だけ反対方向に移動するようになり、0 を設定すると衝突した場所で停止します。衝突後に反対方向に移動してもらう必要性は乏しいので 0 を設定してエラーが発生しないようにしています。\n!! Move exceeds maximum extrusion (0.752mm^2 vs 0.640mm^2) このエラーは、Klipper が「一度に押し出すフィラメントの量が多過ぎる」と判断した時に生じるエラーです。小さなエリアに過度のフィラメントを押し込んでしまうことを防ぐために設けられたエラーチェック機能です。\nエラーメッセージの 0.752mm^2 が G-Code を元に計算された押し出し量で、0.640mm^2 が閾値です。閾値の 0.640mm^2 はデフォルト設定で、これを変えるには、[extruder] セクションの max_extrude_cross_section に任意の値 (ex: 1.00) を設定します。\nなお、デフォルト閾値の 0.640mm^2 は、公式リファレンスによると「ノズルの直径の2乗に4を乗じた」数値とのことですが、この計算式を採用した理由は不明です。\nこのエラーについては、max_extrude_cross_section に大きな値 (ex: 50) を設定して対応しているケースが多い模様ですが、Klipper の作者は「スライサーのバグが原因で発生していると思う」とコメントしています。\nそのコメントを踏まえてエラー発生個所の G-Code を見ると、印刷前のノズル掃除を行う部分でエラーになっていました。\n1G1 X60.0 E9.0 F1000.0 ; intro line 2G1 X100.0 E12.5 F1000.0 ; intro line ノズル掃除のためにフィラメントを多めに押し出していることが原因と思われたので、押し出し量 (E9.0) を少なくするとエラーが発生しなくなり、かつ、ノズル掃除にも支障がなかったので、押し出し量を抑えて対応しました。\nなお、このエラーチェックを行っている部分のコード (klippy/kinematics/extruder.py) を見ると、フィラメントの直径やノズルの大きさも考慮してチェックしているようです。\nUnable to read tmc uart 'stepper_z' register MSCNT UART 通信で Z 軸のモータードライバーの MSCNT レジスタを読み取ろうとしたが読み取れなかったというエラーで、Z 軸のホーミングを開始しようとした時に発生していました。\nTrinamic 社の TMC2209 のデータシートの28ページによると、MSCNT レジスタは、マイクロステップのカウンタで、マイクロステップテーブルにおける位置を示すインジケータのようです。\n公式リファレンスの TMC Driver のページの「一般的な質問」に、よく似たエラーとして Unable to read tmc uart 'stepper_x' register IFCNT というものが掲載されており、そこでは、原因として次の2つが挙げられています。\nモータードライバが Klipper と互換性のない状態にプログラムされている (Klipper インストール直後にエラーが発生している場合) （対応策）プリンタの電源コードを抜き、Raspberry pi と接続している USB ケーブルも抜いてから数秒間待ってリセットします。 UART 通信の配線又はピン設定が間違っている しかし、電源コードと USB ケーブルを抜いてしばらく放置してもエラーが解消できず、また、配線と設定を再確認しても問題はありませんでした。Klipper の Discord サーバで質問しても解決しませんでしたが、マザーボードを新品に交換したら解消したので、ボードの故障が原因だったと思います。\nディスプレイ関係 Klipper は FluiddPi で操作しますので、配線を楽にするために思い切って外部ディスプレイを取り外したところ、次の警告メッセージが表示されるようになりました。\n1fluidd warnings found. 2[display_status] is required if you do not have a [display] defined. 3Fluidd setup requirements can be found here. そこで、警告メッセージ中の [display_status] を printer.cfg に追加したところ、警告メッセージが表示されなくなりました。なお、このセクションの下に設定を追加する必要はありません。\nprinter.cfg 等の設定ファイルの保存場所 ~/klipper_config/ ディレクトリに保存されています。\n","link":"http://localhost:1313/post/2022-01-02/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"Klipper と FluiddPi の設定について"},{"body":"前置き 自作キーボードのトラブルシューティングのための問診票テンプレートを作る時に、QMK Firmware リポジトリの keyboards ディレクトリにあるキーボードのリストを取得する方法を発見していました。\nネットを検索しても紹介されているページが見当たらないので、こちらで紹介します。\n方法 https://api.qmk.fm/v1/keyboards にアクセスするとキーボードのリストが JSON 形式で返ってきますので、使用目的に合わせてテキスト処理をして使います。\n1// コード例 2fetch(\u0026#39;https://api.qmk.fm/v1/keyboards\u0026#39;) 3 .then(response =\u0026gt; { 4 if (!response.ok) { 5 throw new Error(\u0026#39;Response not success.\u0026#39;); 6 } 7 return response.text(); 8 }) 9 .then(data =\u0026gt; { 10 // `data` は CSV なので `split(\u0026#39;,\u0026#39;)` で配列に変換。 11 const keyboardList = data.split(\u0026#39;,\u0026#39;); 12 console.log(keyboardList); 13 }) 14 .catch(error =\u0026gt; console.error(\u0026#39;There has been a problem with your fetch operation:\u0026#39;, error)); 15 16\u0026gt; [\u0026#34;[\u0026#34;0_sixty\u0026#34;\u0026#34;, \u0026#34;\u0026#34;10bleoledhub\u0026#34;\u0026#34;, \u0026#34;\u0026#34;1upkeyboards/1up60hse\u0026#34;\u0026#34;, \u0026#34;\u0026#34;1upkeyboards/1up60hte\u0026#34;\u0026#34;, ... コード例2\n1curl https://api.qmk.fm/v1/keyboards | jq 2 3[ 4 \u0026#34;0_sixty\u0026#34;, 5 \u0026#34;0_sixty/underglow\u0026#34;, 6 ... 7 \u0026#34;zvecr/zv48/f401\u0026#34;, 8 \u0026#34;zvecr/zv48/f411\u0026#34; 9] 参考情報 qmk_api/docs/keyboard_api.md at master · qmk/qmk_api フェッチ API の使用 - Web API | MDN\n","link":"http://localhost:1313/post/2021-12-12/","section":"post","tags":["プログラミング","自作キーボード"],"title":"QMK API を使ってキーボードのリストを取得する方法"},{"body":"前置き 今年の3月から部下に業務遂行のバックグラウンドとなる知識を伝えるための勉強会を開いており、そのための資料を RE:View Starter で作成しています。\n勉強会の都度その回の資料を執筆し、ビルドして出来た PDF ファイルを職場にメールで送っているのですが、送り忘れた場合に備えて、Github Actions を使って Github 上でもビルドを行ってリポジトリからダウンロードできるようにしようと思いました。\nそのため Github Actions の設定をあれこれ調べたのですが、プライベートリポジトリにしているせいで詰まった部分が結構ありましたので、備忘録代わりに調べたことをまとめます。\n前提 ファイルの構成は次のとおり（主なファイルのみ列挙）で、リポジトリはプライベートリポジトリ。contens/ ディレクトリに .re ファイルを保存しています。\n1. 2├ README.md 3├ Rakefile 4├ catalog.yml 5├ config-starter.yml 6├ config.yml 7├ contents/ 8├ workshop.pdf 結論 .github/workflows/main.yml を次のとおり設定し、環境変数 PAT に Personal access token（Scope は repo ）を設定すればビルドできます。\n1on: [push] 2 3jobs: 4 review: 5 runs-on: ubuntu-latest 6 container: docker://kauplan/review2.5 7 steps: 8 - name: Checkout 9 uses: actions/checkout@v2 10 with: 11 repository: s-show/workshop_document 12 token: ${{ secrets.PAT }} 13 path: ./ 14 - name: Build pdf 15 run: rake pdf 16 - uses: actions/upload-artifact@v1 17 with: 18 name: Save PDF 19 path: ./workshop.pdf 解説 on: [push] アクション実行のタイミングを push 時に設定します。 jobs.review:runs-on: ubuntu-latest ワークフローを実行する仮想環境に Ubuntu の最新版を指定します。 jobs.container: docker://kauplan/review2.5 Re:view Starter のビルドは Docker のコンテナを利用しているので、Github Actions でも Docker のコンテナを利用するための設定。コンテナには Re:view Starter の作者が作成したコンテナを指定します。 kauplan/review2.5 - Docker Image | Docker Hub\njobs.steps.name: Checkout ジョブの命名。このジョブは、勉強会資料のリポジトリを Github Actions で使うためにチェックアウトするものなので「Checkout」としています。 jobs.steps.name.uses: actions/checkout@v2 Github Actions の環境はリポジトリがチェックアウトされていない状態なので、そのままではリポジトリのデータにアクセスできません。そこで、公開アクションの actions/checkout@v2 を使ってリポジトリをチェックアウトして $GITHUB_WORKSPACE の下に置くようにします。 actions/checkout: Action for checking out a repo\njobs.steps.name.with.repository: s-show/workshop_document 勉強会資料のリポジトリをチェックアウトの対象に指定してます。 jobs.steps.name.with.token: ${{ secrets.PAT}} 勉強会資料のリポジトリはプライベートリポジトリなので、認証情報がなければ Github Actions はリポジトリにアクセスできない。そのため、ここで環境変数経由で認証情報を渡しています。 プライベートリポジトリを使う場合のコードは以下に掲載されています。\nactions/checkout: Action for checking out a repo\n認証情報の生成は後で説明します。\njobs.steps.name.with.path: ./ リポジトリのトップディレクトリを作業ディレクトリに指定しています。 jobs.steps.name: Buid pdf ジョブの命名。このジョブは、PDFファイルを出力するジョブ。 jobs.steps.run: rake pdf PDF ファイルをビルドするコマンド。Re:view Starter のユーザーズガイドに記載されている PDF 出力コマンドは docker run --rm -v $PWD:/work -w /work kauplan/review2.5 rake pdf であるが、最後の rake pdf だけで実行可能。 jobs.steps.uses: actions/upload-artifact@v1 ビルドした PDF ファイルを保存するため、公開アクションの upload-artifact@v1 を使用しています。 jobs.steps.uses.with.path: ./workshop.pdf トップディレクトリに workshop.pdf というファイル名で保存するよう設定しています。 プライベートリポジトリにアクセスするための準備 プライベートリポジトリにアクセスするには認証情報が必要なので、認証情報を環境変数経由で Github Actions に渡すための設定を行います。\nPersonal access token の生成 Personal access token の生成画面はユーザー設定画面にありますので、画面右上のユーザーアイコンの「Settings」を開いてから「Developer settings -\u0026gt; Personal access token -\u0026gt; generate new token」の順番で開いていきます。\n生成ページを開いたら、Note に任意の名称を入力し、スコープに repo を指定して Personal access token を生成し、生成した Personal access token をコピーします。\n環境変数の設定 環境変数はリポジトリ毎に設定するので、リポジトリの「Setting」を開いてから「Secrets -\u0026gt; New repository secret」の順番で開いていきます。\n環境変数の設定画面を開いたら、 Name に PAT を、 Value に Personal access token の値を貼り付けて保存します。\nデバッグ用の設定 デフォルト設定でもそこそこ詳しいログが保存されますが、さらに詳細なログが保存されても問題はないので、環境変数に次のペアを登録して詳細なログが保存されるように設定します。\nACTIONS_STEP_DEBUG → true\nACTIONS_RUNNER_DEBUG → true\nデバッグ ログを有効にする - GitHub Docs\n","link":"http://localhost:1313/post/2021-12-11/","section":"post","tags":null,"title":"Github Actions で Re:view Starter のファイルをビルドする方法"},{"body":"前置き ~~この記事は 3Dプリンター改造記録 Advent Calendar 2021 - Adventar の1日目の記事です。\n（最初に本記事を執筆したときは2日目の記事でしたが、トップバッターを務められる予定だった tomorrow56@ガジェット分解(モ2済) さんが公開日を12日に変更されたので、期せずしてトップバッターになりました。）\n本アドベントカレンダーは「今年実施した/今年までに実施した3Dプリンターへの改造内容をまとめる記事」なので、今使っている Prusa MK3S+ と Ender3Pro の改造履歴をまとめます。\n実際の改造 私が現在使っている 3Dプリンタは「Prusa i3 MK3S+」と「Ender 3 Pro」の2台で、それぞれの改造は次のとおりです。\nPrusa MK3S+ Prusa の改造は次のとおりです。Prusa は元の性能が高いので、Ender 3 Pro に比べると小規模な改造に留まっていると思います。\nBear Extruder の導入 ギヤードモーターの導入 Klipper の導入 シリコンベッドレベリング リニアブッシュの交換 Bear Extruder ホットエンド回りのメンテナンス性を上げるため、エクストルーダーを gregsaun/bear_extruder_and_x_axis: An improved extruder and X axis for Prusa i3 printers に切り替えました。プリンター全体を Bear にしなかったのは、そこまでしなくても大丈夫だろうという思いと、アルミフレームを買う出費と改造の手間を惜しんだためです。\nただ、吐き出し量のチューニングに問題があったのか、ナットが手で入らないので止むなくハンダごてを使って力技でナットを入れた個所があり、あらためて印刷してパーツを交換する必要があるかなと考えているところです。\n当初の狙いであったメンテナンス性の向上については、何度か分解を繰り返していますが、分解＆再整備に苦労することがないので、向上が図られていると思います（切り替え前の記憶が乏しいので正確なところが不明になっています）。\nギヤードモーターの導入 フィラメントの送り出し量を細かく制御するため、減速ギヤを使ってモーターの回転数を減速させることにしました。\nまず、既存のモーターにギヤを後付けできる次の MOD を使うことを検討しました。\nNema 17 Gearbox \u0026quot;Pulleybox\u0026quot; Mod for Extruder by vertigo235 - Thingiverse\nしかし、これを使う改造が上手くいかないときに、3Dプリンタパーツを多数販売している TriangleLab からギヤ内蔵のモーターが販売されましたので、こちらを導入することにしました。\nTrianglelab nema 17ギヤードステッピングモータ1:3 reductingステッピングモータprusa I3 MK3S押出機変更1:3ギヤ比|3D Printer Parts \u0026amp; Accessories| - AliExpress\nフィラメントの送り出し量が細かく制御できるようになり、プリント品の品質が向上しました。\nKlipper の導入 既存のファームウェアに大きな不満があったわけではないのですが、印刷品質の向上等を図るためにファームウェアを Klipper にしました。なお、プリンタの制御は FluiddPi で行っています。\nWelcome - Klipper documentation\nfluidd-core/fluidd: Fluidd, the klipper UI.\nファームウェア切り替え後は設定で大分悩みましたが、設定ができてしまうと FluiddPi から何でもできるため非常に便利になりました。\nEnder 3 Pro にも導入する予定ですが、なかなか時間がとれないため作業が進んでいません。\nシリコンベッドレベリング ベッドの水平を出すために PRUSA i3 MK3 Nylock Bed Leveling - YouTube で紹介されている方法を導入していましたが、調整がとにかく面倒でした。レベリングを繰り返して調整を追い込んでいく必要があるのは仕方ないのですが、調整の際にナイロンナットをペンチで固定しながらネジを回すという作業がとにかく面倒で、一度実施したら可能な限り再調整したくないという状況でした。\nそんなとき、Silicone Bed Level Mod Prusa MK3 – SCHWEINERT.COM でシリコンチューブを使ってレベリングする方法が紹介されていて、これならベッドの上からネジを回すだけで調整が可能になって調整が楽になると思って導入しました。\n実際に導入してみると、ナイロンナットを使うより簡単に導入できて調整作業も楽なので、非常にコストパフォーマンスの良い改造でした。\nなお、上記のサイトでは「外径 7-8mm、内径 3mm」のシリコンチューブを使うとありますが、国内でこのサイズのシリコンチューブが見つからなかったので、モノタロウで「外径 6mm、内径 3mm」のシリコンチューブを購入しました。\nSR1554 シリコンチューブ タイガースポリマー 内径 3Φmm、外径 6Φmm、長さ 1m、SR1554、1巻 - 【通販モノタロウ】\nリニアブッシュの交換 Prusa は XY 軸の可動部分が V スロットではなくリニアブッシュですが、移動時に結構な音がするので、これを少しでも静かにするためにプラスチック製のリニアブッシュに交換しました。使ったリニアブッシュは ドライリンR リニアベアリング RJ4JP-01 です。\n体感による比較ですが、交換してからは XY 軸の移動時の音が少し静かになりました。これ以上静かにしようと思ったら、モーターダンパーを導入して、さらにプリンタをコンクリート板の上に載せる必要がありますが、いまのところそこまで行う予定はないです。\nEnder 3 Pro Ender 3 Pro の改造も色々行っています。MOD も改造パーツも豊富な機種なので、色々いじりがいがあります。\nマザーボードの交換 BLTouch の導入 XY 軸のリミット制御をセンサーレスホーミングに切り替え エクストルーダーをダイレクト化 Z 軸をデュアル化 エクストルーダーファンを Noctua 製に切り替え マザーボードの交換 私が買った Ender 3 Pro のストックのマザーボードのモータードライバーは8ビットだったので、印刷中の騒音がひどかったです。そのため、モータードライバーの32ビット化を図るため、Bigtreetech 製の SKR mini e3 V2.0 に取り換えました。これにより騒音問題が解消し、動きも滑らかになって印刷品質も向上しました。また、後述する BLTouch の導入やセンサーレスホーミングの導入も簡単にできるようになりました。\nあと、ファームウェアを更新するときにマザーボードと PC を接続する必要がないのも便利です。\nBIGTREETECH SKR MINI E3 V2 32Bit Motherboard Integrated TMC2209UART Upgrade For SKR V1.4 Creality Ender 3/5 Pro 3D Printer Parts\nBLTouch オートベッドレベリング導入のために行いました。これにより、最初にベッド4隅のネジを調整してベッドの水平を出してしまえば、ベッド内の凹凸によるレベリングの差は BLTouch のメッシュベッドレベリングで対応できるようになりました。\nセンサーレスホーミング SKR mini e3 V2.0 のモータードライバーは TMC2209 で、ジャンパコネクタでマザーボードのヘッダーピンの接続を変えるだけでセンサーレスホーミングが使えます。印刷品質向上には繋がらないですが、リミットスイッチを撤去できて配線が楽になり、また、リミットスイッチが壊れても限界を超えてエクストルーダーやベッドが動くことが無くなりました。あと、なんとなく Prusa っぽい動きにもなったのもうれしい点です。\n“ジャンパコネクタの取り付け図” これに伴い、ついでにリミットスイッチの代わりになる部品を設計して取り付けています。Auto Home 移動時は、この部品にぶつかってプリントヘッドやベッドが停止します。\n“リミットスイッチの代替品” ダイレクトエクストルーダー化 エクストルーダーのダイレクト化は、次の MOD を使って行いました。\nPetsfang Bowden Direct with Bondtech BMG for CR10/S/4, Ender3 and Tevo Tornado by dpetsel - Thingiverse\nダイレクト化により、糸引きを大幅に減らすことができるようになりました。また、この MOD は V6 ホットエンド対応なので、ストックの MK8 ホットエンドから V6 ホットエンドに交換しました。これにより、それまでたまに発生していたホットエンド内でのフィラメント詰まりも発生しにくくなりました。\nZ 軸のデュアル化 Z 軸のデュアル化は、左右の Z 軸で動きに差が出ることを避けるために行いました。幸い、SKR mini e3 V2.0 はデュアル Z 軸に対応しているため、パーツを購入して配線すれば簡単に実現できます。これにより、左右の Z 軸の動きにずれが出なくなりました。\n購入したパーツはこちらです。\n3dプリンター部品Ender 3プロ用アップグレードキット,アルミニウム,デュアルz軸|3D Printer Parts \u0026amp; Accessories| - AliExpress\nエクストルーダーファンの交換 エクストルーダーファンの交換ですが、ストックのエクストルーダーファンは爆音で耳障りだったため、Noctua ファンに交換しました。\nEnder 3 Pro のエクストルーダーファンは24Vで動く前提となっており、SKR mini e3 V2.0 も24Vの電圧を供給しているため、DCDCコンバーターで電圧を24Vから12Vに変換しています。これによりファンが非常に静かになりました。\nなお、この改造はつい最近行ったため、これで冷却が十分足りるかどうかの検証は不十分な状態です。\n最後に 以上が2021年に実施した3Dプリンタの改造です。\n色々と改造を行っていますが、どちらのプリンタもまだ改造したい点はあります。現時点で考えている改造は次のとおりです。\nPrusa\nThe PitStop Extruder for Prusa printers の導入 フレーム全体を Bear に改造 リニアレールの採用 Backlash 低減のための改造 Ender3\nKlipper の導入 エクストルーダーの交換（今のエクストルーダーはホットエンドの冷却が少々気になる） リニアレールの採用 何かを作ることも楽しいですが、改造すること自体も楽しいのが3Dプリンタだと思っていますので、来年も色々やってみる予定です。\n次のアドベントカレンダーの記事は @Ikeji さんの Ender 3改造記録 | my.remarkbox.com です。\n","link":"http://localhost:1313/post/2021-12-10/","section":"post","tags":null,"title":"2021年に実施した3Dプリンターの改造"},{"body":"前置き この記事は キーボード #2 Advent Calendar 2020 の4日目の記事です。何気に Advent Calendar 初参加です。 さて、この記事で何を書くかですが、「キーボードのお店を始めるに至った話」とか「小説家に営業した話」といったディープな話題は書けません。 なので、自作キーボード活動2年目を振り返る記事を書きたいと思いますが、2年目を簡単に振り返ると、オリジナルキーボードの製作が一番比重が大きく、QMK のドキュメント翻訳レビューがそれに続き、Discord の #mon-shin チャンネル用のダイアログページを作ったという1年間でした。なので、これらの活動について書いていきます。\nオリジナルキーボードの設計 オリジナルキーボードの設計については、1年目に色々なキーボードを使う中で自分なりに「こういうキーボードが良さそう」という像が見えてきたことから、それを形にするべく挑戦しました。 最初の1台目は、ProMicro を使う方法で3〜4月に作成したのですが、コネクタ類の位置を間違えて、USB ケーブルと TRRS ケーブルが PCB と干渉してしまいました。そのため、TRRS ケーブルのコネクタをナイフで削り、ProMicro と基板の間のスペースを確保するためピンヘッダを基板に取り付ける羽目になりました。とはいえ、キー入力は問題なくできることと、自分が理想と考えていたキー配列の打ちやすさを実地に試すことができたので、失敗も含めて収穫は大きかったと思います。\nそのキーボードを現在まで使っているのですが、ケーブルが PCB と干渉するキーボードを End Game にするのは無理があるのと、キー配列の問題点 (Zの入力が失敗しやすい) が判明したことから、9月頃から2台目の作成に着手しました。 2台目のキーボードの設計コンセプトは\n配列はColumn Staggerd 形状は左右分離型 キー数は48 親指で『Space/BackSpace、Lower/Raise、Win/CMD、Alt』キーが押せる プレートとケースは3Dプリントで作る ProMicro を使わずに ATMega32U4 直付け このうち、1〜4番目は単なる好みに基づくものですが、5番目はへそ曲がりな性格が顔を出したが故のコンセプトです。\n自作キーボードでは、打ち心地の向上などを図るため、ケースをアルミ削り出しで、プレートを真鍮やステンレスの穴あけ加工で作成することがありますが、1年前よりもそういったケースなどを作る人が増えているという印象です。ただ、それらを見ていると「そこまでお金を出すのは躊躇うな〜」と感じていました。そこで、その対極という訳ではないのですが、ケースやプレートの3Dモデルをダウンロードすれば誰でも 3Dプリンタで安価に出力できて、その気になれば自分でカスタマイズできるキーボードがあっても良いのではないかと考えて、このコンセプトを盛り込みました。\n6番目のコンセプトは、ProMicro による出っ張りを上手に活かせる設計がどうにもこうにもできなかったので、レイアウトの自由を求めて ATMega32U4 直付けに切り替えたものです。これにより、USB コネクタを Micro-B から TypeｰC にできるという収穫もありました。\nこれらのコンセプトを満たすべく設計に着手したのですが、小学1年生の時から科学図鑑を読むのが大好きだったとはいえ、文系高卒で文系職場に就職した身では電子回路の知識が乏しく、ATMega32U4 の使い方をどうやって勉強するかを勉強するところからのスタートでした。\nそして勉強を始めて痛感したのは、ATMega32U4 を使う人は使い方や前提知識をわざわざ書かない、ということでした。具体的には、ATMega32U4 を使うためのコンデンサやクリスタルや抵抗について、なぜそれらの部品が必要なのか、どういう基準で選べば良いのか、どのように配置していくのか、といった点を説明しているサイトがほとんど見つけられませんでした。そのため、ATMega のデータシートを読み込み、個別の項目に絞って検索して調べ、それを自分なりにまとめていくという方法で理解に努めました。その成果はこちらですが、実際に設計に着手すると色々と改善点が見えてきたので、今後修正する予定です。 ATMega32u4を使う場合の設計メモ.md\nとまあ、こんな具合に2台目のキーボードを設計しているのですが、基板設計まで進んだところで Discord でレビューをお願いしたら、見事なダメ出しを受けて自分の知識の無さと皆さんの協力のありがたさを痛感している、というのが現時点の状況です。(そのまま PCBA 発注していたら間違いなく動かないキーボードになっていたので、本当に感謝しています。\nQMK の翻訳レビュー こちらは 2019年11月4日に umi-umi (umi) さんが add japanese translation by umi-umi · Pull Request #7248 · qmk/qmk_firmware で47ファイルの日本語への翻訳のプルリクを出したところから始まったもので、私も docs/ja/feature_tap_dance.md (Merge 済) や docs/ja/keycodes.md (レビュー中) 、docs/ja/keycodes_basic.md (レビュー待ち) を翻訳したり、他の方々の翻訳をレビュー(こちらがメイン) したりしています。\n自分の翻訳については、ケアレスミスから翻訳漏れまで多数の指摘をいただくことになり、レビュワーの方々に多大なご迷惑をおかけしています。その穴埋めという訳ではないですが、他の方々の翻訳のレビューにあたっては、指摘の根拠を明示し、レビューされる側の負担を少しでも減らすように努めています。\n進歩の早い分野では、英語に怯まず公式ドキュメントに当たるのが正しい姿勢なので、その公式ドキュメントに日本語訳があることは日本のコミュニティにとってプラスにこそなれマイナスになることはないと思います。そう思って、少しでも日本の自作キーボードコミュニティに貢献すべく、翻訳とレビューに取り組んでいます。\nちなみに、Windows と Mac の両方を使っているのですが、翻訳はレビューを含めて Mac で行なっています。理由は、ランチャーアプリの Alfred を設定すれば、d hogehoge と打ち込むだけで内蔵辞書を開けるためです。文法を調べる頻度はそんなに多くないので、文法書を手でめくっていても作業効率にたいした影響は無いのですが、単語はしょっちゅう調べるので、手作業では作業効率がガクッと落ちてしまいます。そのため、翻訳は Mac で行なっています。 note: 翻訳の進捗状況は、ファイル数ベースで未翻訳が19%という状況です。\nダイアログページの作成 キーボード制作でトラブルに遭遇した時に Discord で質問する際のチャンネルとして #mon-shin というチャンネルがあり、質問用テンプレートが用意されています。\nただ、テンプレートの穴埋め状況にばらつきがあると感じていましたので、誰でも必要項目を選んでいけば質問文が容易に作れるようにするため、専用のページを作成しました。\n問診票テンプレート\n幸い、作成したページが採用され、これまでにこのページを利用した質問がいくつも出されていますが、実際に運用すると足りない機能も出てくるので、これから修正していく予定です。\nまとめ 「自作キーボードについて考えていることなどをつらつら書きます」と Advent Calendar には書いておきながら活動報告になってしまいましたが、自作キーボードを始める前は、自分が同好の士の中に混じってこんな形で活動することになるなんて全く予想していませんでした。 毎日使う道具でありながら、凝ったことをしなければ制作は思うほど難しくないという絶妙な存在なのが自作キーボードだと思っていますが、こういうとっても面白い世界に巡り合えたことには感謝しています。\nまた、あれこれ迷惑をかけているのに、いつも親切に対応していただいているコミュニティの皆様にも感謝しています。少しでもコミュニティに貢献できるべく努力したいと思っていますので、引き続きよろしくお願いします。 明日は、Takeshi Nishio さんの『自キ活1年目で出来たものと、総当たりマトリクスのご紹介。』という記事です。\n最後まで読んでいただきありがとうございます。この記事は、自作のオリジナルキーボードで書きました。\n","link":"http://localhost:1313/post/2020-12-03/","section":"post","tags":["未分類","自作キーボード"],"title":"自作キーボード活動2年目の振り返り"},{"body":"","link":"http://localhost:1313/tags/%E6%9C%AA%E5%88%86%E9%A1%9E/","section":"tags","tags":null,"title":"未分類"},{"body":"明けましておめでとうございます。新年もよろしくお願いします。\n本記事が新年最初の記事になるが、新年最初の記事ということで、昨年1年間を振り返って今年の簡単な抱負を書いてみようと思います。\n昨年1年間の大きな変化 仕事は変わらなかったので大きな変化はありませんが、私生活では意外な変化がありました。といっても、結婚とかそういう話ではなく、趣味というか、新たな世界が広がったという話です。\nこう書くと大仰な話に聞こえますが、簡単に言えば「物を作る」とことの面白さを知ったということです。\n以下、そういう変化に至った経緯を簡単に書いていきます。\n経緯 「物を作る」ことの面白さを知ったきっかけは、自作キーボードを作ったことです。では、なぜ自作キーボードを作ったのかというと、始まりは Amazon で以下のキーボードを買ったことです。\nAmazon | HAVIT | havit | パソコン用キーボード 通販\nこのキーボードが「メカニカルキーボード」という分類に属すると知り、それではメカニカルキーボードとはなんぞやと調べていたところ、自作キーボードのキットが販売されているのを発見し、面白そうだと思って2019年1月にキットを買ったのが自作キーボードの始まりです。\nMint60スターターセット – ゆかりキーボードファクトリー\nこの Mint60 に限らず、大部分の自作キーボードは QMK Firmware というファームウェアを使用しており、ファームウェアを書き換えてキーマップに自由に変えられるのが自作キーボードの非常に大きなメリットです。そのメリットを享受すべく色々模索していましたが、その過程で、「親指キーが多い方が便利じゃない？」と思うようになり、新しいキットを購入しました。\nErgoDash | 遊舎工房\nこのキーボードは親指キーが豊富で、ホームポジションから手をほとんど動かさずに大抵の入力が可能です。これ以降も以下のキーボードを組み立てていますが、テンキーを除いたキーボードのキーマップは、この ErgoDash で作ったキーマップがベースになっています。\nNaked48LED - 自キ温泉街販売所 - BOOTH\nSetta21 - 自キ温泉街販売所 - BOOTH\nPlaid | 遊舎工房\nAttack25 自作キーボードキット - 25KEYS - BOOTH\nCorne Cherry | 遊舎工房\nKugel-1 - のぎけす屋 - BOOTH\nとまあ、こうやって自作キーボードの沼に入っていったのですが、そうこうしているうちに東京メイカーフェア2019が開催され、自作キーボードのコミュニティである「Self-Made Keyboards in Japan」の方々も出展すると聞いたので、休みを取って足を運びました。\nメイカーフェアに参加したのは初めてでしたが、Google とか LINE のハイレベルな展示物もさることながら、個人でロボットアームを作ったり、R2-D2が動いていたり、挙げ句の果てには個人制作の加速器まであったりと、ものづくりの奥行きと凄さを肌で感じることができたのは大きな収穫でした。\nそうやってものづくりに触れた後、新たなキーボードを作るだけではなく、作成済みのキーボードをカスタマイズしてみようと思い、Illustrator でケースを設計して HANDS Fab でレーザーカットしてもらうことを始めました。しかし、切断しかできないレーザーカッターでは複雑な形状を作るのに限度があると気づき、代わりに3Dプリンタを購入しました。\nそして3Dプリンタを使い始めましたが、間に合わせのデスクでは水平が出ない、水平を出すべく脚に物を挟んで調整すると振動が大きくなって品質が悪化する、仕方がないので床に置いて印刷すると不便で邪魔になる、とにっちもさっちもいかなくなったので、SUS社のアルミフレームを発注して専用の印刷台を作成するに至りました。\nまた、3Dプリンタを買う前には、雑多な物をまとめて置いておける背高の棚（木製）も自作しました。小ぶりな棚は以前から作っていましたが、部屋に合わせて作ると引越しで間取りが変わると使いにくくなるし、そもそも全く塗装していない白木では高級感も何もあったものではないので、その都度バラして粗大ゴミになっていました。その反省を踏まえて、どの部屋でも使えるような設計にするとともに、しっかりワックスを塗り込んで高級感を出し、引越しても使う気になる家具に仕上げてみました。\nさらに、Raspberry pi を使ったスマートリモコンを作ってみるため、プリント基板CADを使って設計した基板の製造を中国の業者に発注することまで行いました。\nこうしてみると、自作キーボードから始まって色々な物を作ってきた1年間でしたが、1年前には自分がこうして何かを作っている姿は全く想像していませんでした。\nなにも広い部屋に引っ越して工作機械が置けるようになった訳ではないし、自分で作らないと生活に支障が出るから作っている訳ではないです。ただ、キーボードが自作できることを知り、そして、個人でも色々なものが作れるということを知ることで、何かを作るということに対する心理的なハードルが大きく下がったと実感しています。そして、物を作るのは苦労も多いですが、制作過程では「大変だけど楽しい」というある意味矛盾した感覚が得られるので、まだまだ色々なモノづくりに挑戦してみようと思っています。\n一寸先は闇なのが現実世界ですが、面白いと思ったことに挑戦していけば色々なものが得られるという当たり前の事実が分かった以上、うだうだ考えるよりとにかく動いてみることを信条にしてこの1年間を過ごしてみたいと思います。そうすれば、来年の今頃に新たな記事も書けるようになっている（と思います）。\n","link":"http://localhost:1313/post/2020-01-01/","section":"post","tags":["未分類"],"title":"自作キーボードから始まったものづくりへの取り組み"},{"body":"前置き AnyCubic 製の AnyCubic Mega S という3Dプリンタを使っていますが、動作中にモーター音に加えて結構な大きさの電子音が鳴ってうるさいので、モータードライバを工場出荷時の A4988 から TMC2208 に交換しました。ただ、手順を紹介した記事が少なくて苦労しましたので、備忘録代わりに手順をまとめてみました。\nなお、この記事の前提は次のとおりです。\nプリンタの機種 AnyCubic Mega S マザーボード Trigorilla Mega2560+ramps 1.4 作業PC Windows10 必要なもの TMC2208 Amazon や Aliexpress で「TMC2208」を検索するといくつかヒットしますが、バージョン違いがあるので注意が必要です。\n私は FYSTEC社が販売しているVer.1.2を使いました。Ver.1.0と1.2の違いは、UART を使うときの設定方法のようです。\nMarlin Firmware TMK2208 のピン配置は、Mega Sに最初から取り付けられている A4988 と反対なので、TMC2208 を使う場合はマザーボードとモーターを繋ぐコネクタの向きを反対にする必要があります。\nしかし、Anycubic i3 Mega / Mega-S Marlin 1.1.9 Custom Firmware - Extra Features \u0026amp; Quality Tweaks を使うとコネクタの向きを変える必要が無いので、これを使うと便利です。というか、TMC2208のコネクタ以外にも便利な機能があるので、ぜひこのカスタムファームウェアをインストールするべきです。\nRaspberry pi 3 Raspberry pi 3 に OctoPrint という3Dプリンタ制御用の OS を書き込んで、プリンタ制御や設定を行います。無くても交換できるが、交換後の設定変更などで非常に重宝しますし、今後の印刷や設定変更でも大活躍するので、この機会に導入しておいた方が良いと思います。\n作業手順（TMC2208） TMC2208 は、工場出荷時点では StelthChop2 という静穏化を最重要視したモードになっています。このモードは、静穏化には有効な反面、トルクが弱い、チップが高温になるという問題があります。そこで、StelthChop2 より少しうるさいが、トルクが強く温度上昇も抑えられる SpreadCycle というモードを利用することにしました。\nSpreadCycle モードを利用するには TMC2208 のマイコンの設定を変える必要があります。ブレッドボードに TMC2208 と抵抗等を差し込んで USB-シリアル変換装置で PC と繋げば書き込みできますが、専用の書き込み装置を使う方が簡単で FYSTEC 社は専用の書き込み装置も販売していますので、TMC2208 とあわせて購入すると便利です。\nなお、TMC2208 のマザーボードとの接続パターンは次の3つがあるようです。\nLegacy Mode ドライバを取り付けて電圧を調整すればOKという簡単な方法だが、StelthChop2 しか使えないようです。 Stand Alone Mode SpreadCycle モードが使えますが、TMC2208 を PC と接続して動作モードを変更する必要があります。私はこのパターンで接続しています。 UART Mode マザーボードとジャンパピンで接続してファームウェアのソースコードを修正したりと手間がかかりますが、その代わり、SPI でドライバをコントロールすることができるようです。 書き込み装置の準備 書き込み装置を使うには次の作業が必要です。なお、書き込み作業は Windows10 で行なっています。\n書き込み装置にジャンパピンを2つ差し込む シリアル通信用のドライバをインストールする 設定書き込みに使うソフトウェアをインストールする まず、ジャンパピンは次の写真の2箇所に差し込みます。\nTMC2208書き込み装置にジャンパピン取り付け 次に、シリアル通信用のドライバを CH340 Drivers for Windows, Mac and Linux からダウンロードしてインストールします。\nそれから、TMC2208の設定を変えるために使う ScriptCommunicator / serial terminal download | SourceForge.net をインストールし、専用のファイルである Configurator for TMC220x | SilentStepStick | Watterott electronic をリンク先からダウンロードします。\nTMC2208 の半田付け 上記の作業で PC と書き込み装置側の設定はOKですが、設定を変えるには、TMC2208 のパッドをハンダでブリッジする必要があります。ブリッジする箇所は次の写真のとおりです。\nTMC2208の半田ブリッジ SpreadCycleへの書き換え ここまでの作業が完了したら、書き込み装置をPCに接続し、デバイスマネージャーで書き込み装置の COMポート番号を確認します。それから、 MC220X.scez を ScriptCommunicator で開いて書き込み装置に TMC2208 を取り付けます。\nTMC2208 を SpreadCycle モードで使う場合、OTPメモリの値を書き換える必要がありますので、OPT Programmer タブを開いて、次の手順で OTPメモリの値を書き換えます。\nOTP の値を 2.7 にするため、次の画面のとおり数値を入力して write 1-bit to OTP memory ボタンをクリック TMC2208 のOTP書き換え1 TOFF の値を 1.1 にするため、次の画面のとおり数値を入力して write 1-bit to OTP memory ボタンをクリック TMC2208 のOTP書き換え2 作業手順（本体） 分解 底板の取り外し 椅子を隙間を空けて2つ並べ、その隙間にZ軸のフレームを通して本体を裏返すと作業が楽です。\nAnyCubic Mega S の底板取り外し準備 なお、AnyCubic Mega S は、モータードライバを冷却するファンの吸気部分が塞がれていて吸気に問題がありますが、底板の手前と奥を180度回転させると吸気部分が開くので、この方法をお勧めします。\nAnyCubic Mega S の底板の前後入れ替え モータードライバ用ファンの取り外し 作業の邪魔になるので、モータードライバ用のファンを取り外します。\nモータードライバ交換 X軸、Y軸、Z軸（左右で1つずつ）、エクストルーダーのモーターを制御するドライバ5個を全て取り外します。万が一、元のドライバに戻すことになった場合に備えて、ドライバの向きや、どのドライバがどこに差し込まれていたかを記録することをお勧めします。\nモータードライバの電圧調整 テスターの端子を FYSTEC社の解説 Wiki で紹介している場所に当てます。YouTube の動画では同 Wiki とは異なる場所にテスターを当てていたりするが、どこで測定しても電圧は同じでした。\nTMC2208 の電圧測定 プリンタの電源を入れてから、テスターを当てて電圧を測定します。電圧の設定ボルトについては、この後インストールするファームウェアの作者が提案している電圧に設定しました。（リンク）\nX, Y, Z, E1 (E1 = 2nd Z axis) 1.1V E0 (=extruder) 1.2V Firmwareの書き込み Curaで書き込む方法 Cura を立ち上げて「Settings \u0026gt; Printer \u0026gt; Manage Printers..」を開いたら、「Update Firmware \u0026gt; Upload Custom Firmware」をクリックしてカスタムファームウェアのファイルを選択します。\nOctoPrintで書き込む方法 OctoPrint を起動して、ファームウェア作者の指示に沿って次のコマンドを実行します。なお、コマンドは Cura でも実行できますが、プリンタが返したメッセージが表示されないので、OctoPrint で作業をする方が楽です。\nM502 - load hard coded default values M92 E384 - set correct steps for the new extruder M203 E30 - limit extruder feedrate M204 R1500.00 - lower retract acceleration M500 - save the values Accelaration \u0026amp; Jerk の設定 Accelaration \u0026amp; Jerk の設定を、ファームウェア作者の推奨値に変更します。\nM201 X2000 Y1500 Z60 E10000 ; max acceleration M204 P1200.00 R3000.00 T1500.00 ; default acceleration M205 S0.00 T0.00 Q20000 X9.00 Y9.00 Z0.40 E5.00 ; min segment time and jerk M500 - save the values ヘッド移動のテスト OctoPrint のコントロール画面かプリンタのメニューでヘッドをホームポジションに移動させます。\nリミットスイッチがあるのでプリンタの制限以上に動かないはずですが、念のため、ヘッドの動きがおかしかったら直ちにプリンタの電源を切れるよう構えておきます。\nMeshBedLeveling実行 5×5 の25点のレベリングができるようになったので、印刷品質向上のためベッドのレべリングを調整します。Anycubic i3 Mega / Mega-S Marlin 1.1.9 Custom Firmware - Extra Features \u0026amp; Quality Tweaks by davidramiro - Thingiverse の手順に従って行うこともできますし、OctoPrint にカスタムボタンを追加して行うこともできます。\nテスト印刷 \u0026amp; キャリブレーション テスト印刷 レベリングが適切にできているか確認するため、次のデータを印刷します。\nBed test pattern for 200mm square bed. by N3wSp3ak - Thingiverse Customizable Bed Leveling Test by kenwebart - Thingiverse レべリングの調整 全体的にノズルが近い/遠い場合、OctoPrintのプラグインの EEPROM Marlin Editor で Z軸のオフセットを調整してレベリングをカバーすることが可能です。\n測定箇所毎のレべリングの値は G29 S0 コマンドを実行すると以下のとおり確認できます。\n1Send: G29 S0 2Recv: State: Off 3Recv: Num X,Y: 5,5 4Recv: Z offset: 0.00000 5Recv: Measured points: 6Recv: 0 1 2 3 4 7Recv: 0 -0.35000 -0.18000 -0.01500 +0.18000 +0.42000 8Recv: 1 +0.01000 +0.03000 +0.09000 +0.18000 +0.41000 9Recv: 2 -0.01000 +0.09000 +0.11000 +0.13000 +0.45000 10Recv: 3 +0.09000 +0.09000 +0.10000 +0.16000 +0.30000 11Recv: 4 +0.06000 +0.11000 +0.17000 +0.17000 +0.29000 12Recv: 13Recv: X:-5.00 Y:215.00 Z:23.41 E:372.56 Count X:-405 Y:17381 Z:9730 14Recv: ok レべリング確認の印刷で部分的にレベリングに問題があった場合、G29 S3 Xn Yn Z-n.nn コマンドで測定箇所毎にレべリングの値を変えられます。レべリングの値を変えた時は、M500 コマンドで忘れずに保存すること。\nちなみに、上記のコマンドで XY を指定する時は、以下のとおり指定します。\n1// XY軸の表示 2 3 X1 X2 X3 X4 X5 4Y1 -0.35000 -0.18000 -0.01500 +0.18000 +0.42000 5Y2 +0.01000 +0.03000 +0.09000 +0.18000 +0.41000 6Y3 -0.01000 +0.09000 +0.11000 +0.13000 +0.45000 7Y4 +0.09000 +0.09000 +0.10000 +0.16000 +0.30000 8Y5 +0.06000 +0.11000 +0.17000 +0.17000 +0.29000 このコマンドによる修正は、レベリングを完璧にするというよりも、どの部分でもノズルとベッドの距離が同じになることを目指します。どの部分でもノズルとベッドの距離が等しくなれば、あとは OctoPrint のプラグインの EEPROM Marlin Editor で Z軸のオフセットを調整することでレベリングを完璧にすることができるようになります。\nEEPROM Marlin Editor による Z軸のオフセットの調整は、Steps -\u0026gt; Home Offset で Load を押して現在の値を取得してから、Z axis のインプットボックスにオフセット値を書き込んで Upload をクリックしてオフセットを変更します。\n正の値を入力するとベッドに近づき、値が増えるに従ってよりベッドに近づきます。逆に、負の値を入力するとベッドから遠ざかり、値が減少するに従ってよりベッドから遠ざかります。\n","link":"http://localhost:1313/post/2019-12-20/","section":"post","tags":["3Dプリンタ","備忘録"],"title":"AnyCubic i3 Mega S に TMC2208 を導入する"},{"body":"前置き 自作キーボードのPlaidはお気に入りのキーボードであるが、このキーボードは、ProMicro の代わりにマイコンの ATMega328P を使っており、キーボードには ISP ポートが用意されている。\nなので、このキーボードを AVR ライターがわりに使えるのではないか、また、秋月とかで購入した ATMega328P にデータをバックアップしておいて、いざというときはマイコンだけ置き換えて対処する、といったこともできるんじゃないかと思って挑戦してみた。\nその挑戦がうまくいったので、その手順を備忘録として残しておく。\n作業の手順 作業に使うものは次のとおり。\nPlaid Arduino Uno（互換品でOK） ブレッドボード・ジャンパーワイヤ（オス－メス）6本 作業の手順は以下のとおり。\nArduinoをAVRライターにする 手順 Arduino IDEをインストール まず、Arduino の公式サイトでアプリをダウンロードしてインストールする。\nArduino - Software\nArduinoのシリアルポートの接続先を確認 Arduino IDEを使う方法 まず、Arduino を接続せずに Auduino IDE を立ち上げ、メニューバーの「ツール」-\u0026gt;「シリアルポート」に表示されるデバイスを確認する。\nArduino 接続前のデバイス確認 それからArduinoを接続して再度「ツール」-\u0026gt;「シリアルポート」を確認すると、Arduinoのシリアルポートの接続先を確認できる。\nArduino 接続後のデバイス確認 ターミナルで確認する方法 まず、Arduino を接続しないでターミナルを開いて次のコマンドを実行し、現在接続されているシリアルデバイスを確認する。\n1$ ls -la /dev/tty.* 2crw-rw-rw- 1 root wheel 19, 0 9 25 07:35 /dev/tty.Bluetooth-Incoming-Port 3crw-rw-rw- 1 root wheel 19, 2 9 25 07:35 /dev/tty.iPhone-WirelessiAP-1 次に、Arduino を接続して同じコマンド実行すると、Arduino のシリアルポートの接続先を確認できる。\n1$ ls -la /dev/tty.* 2crw-rw-rw- 1 root wheel 19, 0 9 25 07:35 /dev/tty.Bluetooth-Incoming-Port 3crw-rw-rw- 1 root wheel 19, 2 9 25 07:35 /dev/tty.iPhone-WirelessiAP-1 4crw-rw-rw- 1 root wheel 19, 200 10 10 00:02 /dev/tty.usbmodem14212401 #これが Arduino のシリアルポート Arduino に ArduinoISP スケッチを書き込む メニューバーの「ファイル」-\u0026gt;「スケッチ例」-\u0026gt;「11. Arduino ISP」-\u0026gt;「ArduinoISP」を選択する。\n書き込みスケッチの選択 それから、「スケッチ」-\u0026gt;「マイコンボードに書き込む」を選択して書き込む。\n書き込み実行 これで、Arduino を AVR ライターとして使う準備が整ったことになる。\n必要なバイナリやライブラリのインストール 以下のコマンドで必要なバイナリやライブラリをインストールできる。ただし、Plaid を使うために QMK Firmware をセットアップすれば必要なバイナリ等もインストールされるので、改めてインストールする必要性は乏しい（はず）。\n1$ brew tap osx-cross/avr 2$ brew tap PX4/homebrew-px4 3$ brew update 4$ brew install avr-gcc@8 5$ brew install dfu-programmer 6$ brew install gcc-arm-none-eabi 7$ brew install avrdude 手順 avrdude のインストール 次のコードを実行して avrdude をインストール\n1$ brew install avrdude --with-usb avrdude のテスト起動 次のコードを実行して avrdude を実行してみる。\n1$ avrdude 2Usage: avrdude [options] 3Options: 4 -p \u0026lt;partno\u0026gt; Required. Specify AVR device. 5 -b \u0026lt;baudrate\u0026gt; Override RS-232 baud rate. 6 -B \u0026lt;bitclock\u0026gt; Specify JTAG/STK500v2 bit clock period (us). 7 -C \u0026lt;config-file\u0026gt; Specify location of configuration file. 8 -c \u0026lt;programmer\u0026gt; Specify programmer type. 9 -D Disable auto erase for flash memory 10 -i \u0026lt;delay\u0026gt; ISP Clock Delay [in microseconds] 11 -P \u0026lt;port\u0026gt; Specify connection port. 12 -F Override invalid signature check. 13 -e Perform a chip erase. 14 -O Perform RC oscillator calibration (see AVR053). 15 -U \u0026lt;memtype\u0026gt;:r|w|v:\u0026lt;filename\u0026gt;[:format] 16 Memory operation specification. 17 Multiple -U options are allowed, each request 18 is performed in the order specified. 19 -n Do not write anything to the device. 20 -V Do not verify. 21 -u Disable safemode, default when running from a script. 22 -s Silent safemode operation, will not ask you if 23 fuses should be changed back. 24 -t Enter terminal mode. 25 -E \u0026lt;exitspec\u0026gt;[,\u0026lt;exitspec\u0026gt;] List programmer exit specifications. 26 -x \u0026lt;extended_param\u0026gt; Pass \u0026lt;extended_param\u0026gt; to programmer. 27 -y Count # erase cycles in EEPROM. 28 -Y \u0026lt;number\u0026gt; Initialize erase cycle # in EEPROM. 29 -v Verbose output. -v -v for more. 30 -q Quell progress output. -q -q for less. 31 -l logfile Use logfile rather than stderr for diagnostics. 32 -? Display this usage. 33 34avrdude version 6.3, URL: \u0026lt;http://savannah.nongnu.org/projects/avrdude/\u0026gt; Arduino と Plaid を接続する Arduino と ISPポートの接続 Arduino を ISP ライターとして使う場合に Arduino で使うピンと、書き込み先の ATMega328P で使うピンの対応関係は次のとおり。\nArduinoのブートローダー書き込み(2種類) - Qiita\nArduino ATMega328P 10 1(reset) 11 17 12 18 13 19 5V (VCC) GND (GND) Plaid の ISP ポートと ATMega328P のピン配置の接続 Plaidの回路図で、基板にあるISPポートの各ピンがATMega328Pのどのピンと接続されているか確認する。確認結果は次のとおり。\nplaid/plaid.pdf at master · hsgw/plaid\nPlaid(ISP) ATMega328P 1 18 3 19 4 17 2 (VCC) 5 (RESET) 6 (GND) なお、Plaid の基板にあるピンの順番は次の写真のとおり。黒い三角（▲）が指し示すピンが1番ピンである。\nPlaid の ISP ポート Plaid と Arduino の接続 上の2つの表を元に、ArduinoとPlaidを次のとおり接続する。\nArduino Plaid 10 5(RESET) 11 4 12 1 13 3 5V 2(VCC) GND 6(GND) Avrdudeの読み込みが可能か確認する 次のコマンドを入力して、デバイスIDを読み取る。無事に読み取れれば次のようなメッセージが出力される。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p 2 3avrdude: AVR device initialized and ready to accept instructions 4 5Reading | ################################################## | 100% 0.02s 6 7avrdude: Device signature = 0x1e950f (probably m328p) 8 9avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) 10 11avrdude done. Thank you. 正常に動く Plaid のデータを読み込む 以上の作業により、Plaid に取り付けている ATMega328P のデータを読み取って、新しい ATMega328P に書き込むことができるようになった。\nそのため、次は具体的な作業方法を説明する。\nヒューズビットの読み込み 次のコマンドを入力して、正常に動いている ATMega328P のヒューズビットを読み込んでおく。この値は、新しい ATMega328P に .hex データを書き込んだ後の設定作業で使用する。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U lfuse:r:con:h -U hfuse:r:con:h -U efuse:r:con:h 2avrdude: AVR device initialized and ready to accept instructions 3Reading | ################################################## | 100% 0.03s 4avrdude: Device signature = 0x1e950f (probably m328p) 5avrdude: reading lfuse memory: 6Reading | ################################################## | 100% 0.01s 7avrdude: writing output file \u0026#34;con\u0026#34; 8avrdude: reading hfuse memory: 9Reading | ################################################## | 100% 0.01s 10avrdude: writing output file \u0026#34;con\u0026#34; 11avrdude: reading efuse memory: 12Reading | ################################################## | 100% 0.01s 13avrdude: writing output file \u0026#34;con\u0026#34; 14 15avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) #カッコ内の値がヒューズビットの値 16 17avrdude done. Thank you. hexデータの読み込み 次のコマンドを入力して、正常に動いている ATMega328P に書き込まれているデータを backup.hex ファイルとして読み込む。このファイルを使って、別の ATMega328P に書き込む。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:r:backup.hex:i 2avrdude: AVR device initialized and ready to accept instructions 3Reading | ################################################## | 100% 0.02s 4avrdude: Device signature = 0x1e950f (probably m328p) 5avrdude: reading flash memory: 6Reading | ################################################## | 100% 19.92s 7avrdude: writing output file \u0026#34;backup.hex\u0026#34; 8avrdude: safemode: Fuses OK (E:FC, H:D0, L:D7) 9avrdude done. Thank you. 新しい ATMega328P への書き込み 上記の作業で正常に動いてる Plaid のデータは読み込めたので、ここで、Plaid に取り付けてある ATMega328P を取り外す。それから、新しい ATMega328P を取り付ける。\n取り外す前に、Arduino と Plaid の接続を切るか Arduino と PC の接続を切ること。そして、接続を切ったまま取り外しと取り付けを行い、取り付けが完了したら再接続する。\nブートローダの書き込み ブートローダが書き込まれていない ATMega328P を使う場合、ブートローダの書き込みを最初に行う。ブートローダ書き込み済みならこの作業は不要である。\nPlaid のブートローダには USBaspLoader を USB ブートローダとして使用する。そのため、USBaspLoader が必要になるが、Plaid の開発者の hsgw 氏が Plaid 用の USBaspLoader を公開してくれているので、それを利用する。\n1# hsgw氏が作成しているPlaidのブランチをcloneする 2# MasterブランチにPlaid用のファームウェアは存在しないので注意！ 3$ git clone -b plaid https://github.com/hsgw/USBaspLoader.git 続いて、USBaspLoader を ATMega328P に書き込む。\n1$ cd USBaspLoader/firmware 2$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:main.hex:i 3avrdude: AVR device initialized and ready to accept instructions 4Reading | ################################################## | 100% 0.03s 5avrdude: Device signature = 0x1e950f (probably m328p) 6avrdude: NOTE: \u0026#34;flash\u0026#34; memory has been specified, an erase cycle will be performed 7To disable this feature, specify the -D option. 8avrdude: erasing chip 9avrdude: reading input file \u0026#34;main.hex\u0026#34; 10avrdude: writing flash (30878 bytes): 11Writing | ################################################## | 100% 0.00s 12avrdude: 30878 bytes of flash written 13avrdude: verifying flash memory against main.hex: 14avrdude: load data flash data from input file main.hex: 15avrdude: input file main.hex contains 30878 bytes 16avrdude: reading on-chip flash data: 17Reading | ################################################## | 100% 0.00s 18avrdude: verifying ... 19avrdude: 30878 bytes of flash verified 20avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) 21avrdude done. Thank you. hex データの書き込み 次のコマンドを入力して、先ほど読み取った backup.hex ファイルを書き込む。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:backup.hex:i 2 3avrdude: AVR device initialized and ready to accept instructions 4Reading | ################################################## | 100% 0.02s 5avrdude: Device signature = 0x1e950f (probably m328p) 6avrdude: NOTE: \u0026#34;flash\u0026#34; memory has been specified, an erase cycle will be performed 7To disable this feature, specify the -D option. 8avrdude: erasing chip 9avrdude: reading input file \u0026#34;backup.hex\u0026#34; 10avrdude: writing flash (30866 bytes): 11Writing | ################################################## | 100% 33.70s 12avrdude: 30866 bytes of flash written 13avrdude: verifying flash memory against backup.hex: 14avrdude: load data flash data from input file backup.hex: 15avrdude: input file backup.hex contains 30866 bytes 16avrdude: reading on-chip flash data: 17Reading | ################################################## | 100% 18.83s 18avrdude: verifying ... 19avrdude: 30866 bytes of flash verified 20avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) 21avrdude done. Thank you. ヒューズビットの値書き込み 最後に、新しい ATMega328P のヒューズビットに、上記の作業で確認した値を書き込む。\n1$ avrdude -c avrisp -P COMポート番号 -b 19200 -p m328p -U flash:w:backup.hex:i 2 3avrdude: AVR device initialized and ready to accept instructions 4Reading | ################################################## | 100% 0.02s 5avrdude: Device signature = 0x1e950f (probably m328p) 6avrdude: NOTE: \u0026#34;flash\u0026#34; memory has been specified, an erase cycle will be performed 7To disable this feature, specify the -D option. 8avrdude: erasing chip 9avrdude: reading input file \u0026#34;backup.hex\u0026#34; 10avrdude: writing flash (30866 bytes): 11Writing | ################################################## | 100% 33.70s 12avrdude: 30866 bytes of flash written 13avrdude: verifying flash memory against backup.hex: 14avrdude: load data flash data from input file backup.hex: 15avrdude: input file backup.hex contains 30866 bytes 16avrdude: reading on-chip flash data: 17Reading | ################################################## | 100% 18.83s 18avrdude: verifying ... 19avrdude: 30866 bytes of flash verified 20avrdude: safemode: Fuses OK (E:FF, H:D9, L:62) 21avrdude done. Thank you. 動作確認 ここまでの作業が終わったら、Arduino から Plaid を外し、Plaid と PC を接続して入力テストを行う。\n作業がきちんとできていれば、それまでと同様に Plaid が使えるはずである。\n","link":"http://localhost:1313/post/2019-10-13/","section":"post","tags":["プログラミング","自作キーボード"],"title":"ArduinoとPlaidを使ってマイコンを複製する方法"},{"body":"salicylic-acid3 さんが作成・販売されている自作キーボードのNaked48LED - 自キ温泉街販売所 - BOOTHとSetta21 - 自キ温泉街販売所 - BOOTHを組み立てた際、LED の取り付けで四苦八苦したので、その時にネットで集めた情報や Discord の Self-Made Keyboards in Japan で教えていただいた情報をまとめてみたいと思う。\nLED チップの向きの確認 LED チップが点灯しない時、まず最初に確認するのは取り付けた LED チップの向きである。LED の向きが違えば当然点灯しないし、テスターを使う必要もない簡単な作業なので、まずはここから開始する。\nもし向きが違っていた場合、一度外して再度取り付けることは可能である。しかし、自分の体験から言うと、取り外す時の熱でチップが壊れる可能性があるので、新品に交換した方がトラブルが少ないと思う。\nProMicro の LED の確認 LED チップの向きが正しいことが確認できたら、次はテスターを使った確認に進む…でも間違いでは無いが、テスター無しでもできる確認事項が1つあるので、それも行ってみる。\n方法は、 ProMicro に QMK Firmware を書き込んだ後、基盤に ProMicro を取り付けた上でPCとUSBケーブルで接続し、 ProMicro のLEDが点灯するか確認するというものである。\nProMicro の LED が点灯した場合、 ProMicro から LED に電力を供給する VCC（＋）と GND（ー）はショートしていないことが確認できるので、その場合、次の確認作業に進むことになる。\nテスターによるテスト 続いて、テスターを使って導通を確認する。\n注意事項として、電源を供給しない状態のキーボードにテスターを当てて分かるのは「ショートの有無と基盤内の断線の有無」までで、 LED チップが壊れているか否かは、キーボードに電源を供給した上で、点灯している LED と点灯していない LED を繋いでみないと分からない。\nなので、テスターによる調査で全てが分かる訳では無いが、デバッグ作業では「原因では無いもの」を除外していくことが大事なので、この作業は省略できない。\n基盤内の断線の有無の調査 まずは、基盤内の断線の有無を調べるため、 LED チップに点灯のための電力や制御信号を送信する ProMicro の設置箇所から各 LED チップまでの導通を確認していく。\n基本情報 フルカラーで輝度・色味を制御できる LED チップの場合、電源のVCCとGNDパッドに加えて、輝度・色味を制御するための DIN と DOUT のパッドがある。それぞれのパッドの位置関係は次の図のとおり（SK6812miniデータシートより）。\nSK6812mini のパッド また、 ProMicro のピン毎の説明は次の図のとおり（製造元の SparkFunのWebページ より）。\nProMicro のピン配置 VCC ラインの導通確認 LED チップを点灯させる電力は ProMicro のVCCから供給されるので、基盤に ProMicro を取り付けた際にVCCのピンが刺さるスルーホールにテスターの電極の片方を当て、もう片方を各 LED チップのVCCに当てる。これを全ての LED チップに対して行っていく。 もし、ここが導通していなければ、基盤内部の電源供給ラインが断線している可能性が考えられる。\nGND ラインの導通確認 ProMicro のVCCから供給された電力はGNDに戻るので、VCCラインを調査した時と同様に、GNDのピンが刺さるスルーホールにテスターの電極の片方を当て、もう片方を各 LED チップのGNDに当てていく。\nGNDは複数のピンがあるので、どれが LED チップと接続しているかは、試行錯誤して確認するしかない。\nDIN ラインの導通確認 LED チップの制御信号を送信する DIN ラインも確認するが、 ProMicro のどのピンから制御信号が出ているかはキーボードによって異なる。\n私が調べたところ、制御信号の出力ピンは config.h ファイルの #define RGB_DI_PIN で定義される1ので、そこを確認する。 ちなみに、QMK-Firmwareのディレクトリで grep -r \u0026quot;#define RGB_DI_PIN\u0026quot; keyboards | cut -d \u0026quot;:\u0026quot; -f 2 | cut -d \u0026quot; \u0026quot; -f 3 | sort | uniq -c | sort -nr | awk -F, '{ sum += $1 } END{ print sum }' コマンドを実行したところ、一番多かったピンはD3（88件）で、二番目のE2（39件）の2倍以上であった。\n何番のピンから制御信号が出力されているか確認できたら、これまでと同様に確認する。\nただし、LEDの制御信号は、 ProMicro から最初のこの方法で確認できるのは、「 ProMicro が送信した制御信号が通るラインが断線していないか」であって、「 LED チップ間のデータ送信の成功・不成功」は、次の方法で確認することになる。\nDOUT ラインの確認 LED チップの制御信号を次の LED チップに送信するのが DOUT になるが、これだけは ProMicro と繋がっていない。\nその代わり、1番目の LED チップの DOUT は2番目の LED チップの DIN に繋がり、2番目の LED チップの DOUT は3番目の LED チップの DIN に繋がり…という連結が繰り返されている。ただし、最後の LED チップの DOUT はどこにも繋がらない形になる。\nそのため、 DOUT については、 ProMicro との接続ではなく、次の LED の DIN との接続を確認することになるが、電源を接続して確認する方が視覚的に分かりやすいので、確認方法は次で述べる。\nLED チップ間の導通確認・ LED チップの故障の調査 まず、作者のウェブサイトなどで、自分が組み立てているキーボードの LED の順番を確認する。続いてキーボードに電気を供給するため、キーボードをPCに接続する。私が組み立てた Setta21 の場合、次の順番となっている。\n(自作テンキーキット『Setta21』ビルドガイド - 自作キーボード温泉街の歩き方より)\nSetta21 の LED の接続順 それから、点灯していない LED の一つ前にある点灯している LED の DIN と、点灯していない LED の DIN をジャンパワイヤーなどで接続する。(@mteiさんのツィートより)\nDINとDOUTの接続確認 もし、この方法で点灯していない LED が点灯した場合、点灯している LED の DOUT が壊れているので、点灯していてもその LED チップは交換しないといけない。\n一方、この方法でも点灯していない LED が引き続き点灯しない場合、点灯していない LED は壊れていると思われるので、交換する必要がある。\n何だかまどろっこしい確認方法であるが、 LED チップが壊れているか否かは、点灯のための電力を供給している状態で、 DIN に制御信号を送り込んで点灯するかどうかで調べるしか無い模様なので、面倒でもこの方法で進めるしか無い。\nまとめ 以上の内容が、私が調べたり教えていただいた情報を自分なりにまとめたものである。\nプログラミングのデバッグ作業とは異なり、「点灯しない」というメッセージ以外のエラーメッセージが表示されないので、骨が折れる作業である。\nその分、全部の LED が点灯した時はとても嬉しいので、この記事が誰かの参考になれば幸いである。\n本記事の執筆で参考にした記事\nm.tei / ishiiさんのツイート コルネキーボードを作りました ～LED取り付けに四苦八苦記～ | キオクノロンダリング QMK Firmware でオリジナルキーボードのファームウェアを作成する - Qiita DiscordのSelf-Made Keyboards in Japanサーバで教えていただいた方々の投稿 Config Options - QMK FirmwareのRGB Light Configurationにて確認した。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"http://localhost:1313/post/2019-07-22/","section":"post","tags":["プログラミング","備忘録","自作キーボード"],"title":"自作キーボードでLEDが点灯しない時のテスト方法と対処方法"},{"body":"前置き 自作キーボードキットのErgoDashを組み立てて日々使っているが、以下のページで紹介されている方法を使って、Raise/Lowerキーを「単独で押せば変換/無変換 or かな/英数、他のキーと組み合わせて押せばRaise/Lower」となるように設定して使っている。\nQMK Firmware で Raise/Lower と変換/無変換を同じキーに割り当てる\nMacOSは「かな/英数キー」でIMEのオン/オフが切り替えられ、Windowsも、enthumbleというアプリを使えば「変換/無変換キー」で同じことができるので、こうした設定を行なっている。\nMacOSではこの設定で問題なくIMEを切り替えられたのだが、Windowsで同じことを実現しようとした時に思いっきりつまづいてしまった。\n試行錯誤の末に、WindowsでもIMEをMacOSと同様に切り替えられるようになったのだが、そのときの知見を備忘録代わりにまとめておこうと思う。\nenthumbleとは？ 前置きでも少し触れているが、Windowsで出番がほとんどない無変換キーをFnキーの代わりとして使うことで、「無変換-HJKL」でカーソル移動、「無変換-スペース」でEnterキーを入力、「無変換-S」でCtrl-Sを入力、といった機能に加えて、変換/無変換キーをIMEのオン/オフのキーとして使えるようにするアプリである。\nenthumble Readme 【説明書】 - Qiita\n自作キーボードを使う前から重宝していたアプリなのだが、自作キーボード導入後はしばらくWindowsPCを操作していなかったので、自作キーボード導入後の最初のWindowsPC操作の時点で、変換/無変換キーをIMEの切り替えに使えないという問題に遭遇してしまったのである。\n最初の悪戦苦闘 enthumbleを入れても変換/無変換キーをIMEのオン/オフキーとして使えなかったので、まずは、本当に変換/無変換がWindowsに送信されているのか調べることにした。\n調査では、まず、Change Keyというキーボードカスタマイズソフトのキーコード調査機能を使ったのだが、以下のスクリーンショットのとおり、ちゃんと変換/無変換キーが送信されているという結果が出てきた。\n変換/無変換キーが送信されているのは確認できたので、Raise/Lowerキーを「単独で押せば変換/無変換、他のキーと組み合わせたらRaise/Lower」という設定がきちんとできていることは確認できたのだが、それでもenthumbleが動作しない理由が分からなかった。とりあえず、enthumbleを再インストールしたりWindowsを再起動したりといった定番の作業は行ったが、一向に問題が解決しない。\nここで、enthumbleを使うことは諦めて、キーボードカスタマイズソフトのAutoHotkeyを使うことにした。\nAutoHotKeyとは？ AutoHotKeyは、元々はキーボードカスタマイズソフトとして開発されていたが、ユーザーの要望を取り入れながら開発しているうちに、Windowsの動作制御までできるようになったソフトである。\n本当に多機能なソフトで、\nアプリ毎に自分用のショートカットキーを作る 変換/無変換キーをIMEの制御キーする アプリ操作を自動化 GUIフォームを備えたアプリを作成する といった具合に、とにかく色んなことができるようになるソフトである。\n[AHK基礎] AutoHotkeyはどんな言語か - ITジョー\nRPA（ロボテックプロセスオートメーション）なくても、AutoHotKeyでPC入力自動化できますが何か？ - ノリックのIT生産性向上、ライフハック、プロマネのお仕事備忘録\nWindows で簡単な GUI ラッパーアプリを作るなら AutoHotkey が良さそうという話 - Qiita\nAuto Hot Keyで簡単にGUIフォームアプリを作る | 読書とプログラミングを中心とした覚書ブログ\nまた、書いたスクリプトを.exeファイルにコンパイルすることもできるので、自作の設定を他人に使ってもらうことも可能である。ちなみに、enthumbleもAutoHotKeyで作成されている。\nただし、様々なことができるとはいえ、自分でスクリプトを書かないといけないので、マウスでぽちぽちクリックすればOKと言う訳ではない。とはいえ、自分用のショートカットキーを作ったり、IMEの制御を「全角/半角」キー以外で行うと言うレベルであれば、そこまで難しいものではない。\nというわけで、AutoHotKeyの使い方を簡単に紹介するとともに、私が行っている設定も紹介したいと思う。\nAutoHotKeyの使い方 詳しい使い方については、ネットを検索すれば優れた先人の解説がいくつも見つかるので、本記事では基本的な部分に絞って解説する。\nAutoHotkeyのチュートリアルを読んだ - もうカツ丼はいいよな\nAutohotkeyに関する記事で1万字超えの記事を書き、 Google からの検索流入が一か月後に増加するかどうかを確認しつつ、タイトルはやっぱり長い方が良いのかも検証する - ノリックのIT生産性向上、ライフハック、プロマネのお仕事備忘録\nAutoHotkey Wiki\nAutoHotKeyの使用方法\n基本的な構文 AutoHotKeyでMyショートカットキー（AutoHotKeyではホットキーと呼ぶ）を作成する場合、*.ahkという拡張子の設定ファイルにホットキーを割り当てるキー::という形でコードを書く。こう書くことで、AutoHotKeyではサブルーチンのラベルとして認識され、指定のキーを押すと、ラベルの次の行以降に処理が移り、ReturnかExitが実行されるまで処理が続けられる。\nなお、/* ~ */という構文はコメントである。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3example2: Alt-Qの2連打でアプリを閉じる 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6~!q:: 7 Input, inputText, I L1 T0.5, !q 8 IfInString, ErrorLevel, EndKey: 9 { 10 Send, !{F4} 11 } 12Return なお、割り当てる処理が1行で足りる場合、以下のコードのようにReturnを省略できる。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3example1: Ctrl-Alt-Rでこのスクリプトを再読み込みする 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6^!r::Reload ホットキーの指定方法 ホットキーを指定するには、こちらに掲載されているキーリストに沿って指定するが、基本的に、アルファベットキーは印字通り（大文字小文字は不問）指定すればOKである。BackSpaceやReturnなどのキーも、基本的にキーの印字通りでOKである。\n一方、変換/無変換のような一部のキーは、vkXX(仮想キーコード)かscYYY(スキャンコード)というキーコードで指定する必要がある。キー毎の具体的なコードは、上記のリンク先を参考にするか、AutoHotKeyのキースキャン機能で確認できる。\nなお、注意事項として、ネットではvkXXscYYYという指定方法が散見されるが、この方式は、2017年12月25日にリリースされたバージョン1.1.27.00で*.ahkスクリプトのバリデーションが変更されたことにより、現在ではエラーとなる。そのため、現在はvkXXかscYYYと指定する。\nCtrlやAltキーなどのモディファイヤキーと組み合わせるホットキーを指定する際は、以下の表に示したコードと組み合わせて指定する（例: ^j）。上の設定例の^!rは\u0026quot;Ctrl-Alt-R\u0026quot;という組み合わせを指定している。\nキー名 説明 + shift ^ control ! alt # windows なお、上の設定例の~!q::の行頭にある~は、押したキーをそのままシステムに通すという設定である。この例で言えば、\u0026quot;Alt-Q\u0026quot;というキーをAutoHotKeyで受け取った後システムにも渡すという設定である。\n変数と条件分岐 変数 変数は、事前の宣言不要でMyVar = 123abcの形で値を代入できる。また、変数の値の展開はMsgBox, MyVar is %MyVar%のように%で囲めばOKである。\nなお、関数の返り値を変数に代入する際は、MyVar := function()のように、=ではなく:=とする必要がある。\n参考\nスクリプト仕様 - 変数 - AutoHotkey Wiki 条件分岐 If文による条件分岐が可能であり、ElseでIfの条件に当てはまらない場合の処理が指定できる。その場合、Elseの後にIfを追加して細かい条件分岐を行うことも可能である。\n1If MyVar \u0026gt; 10000 2 MsgBox,\u0026#34;たくさん\u0026#34; 3Else If MyVar \u0026gt; 1000 4 MsgBox,\u0026#34;多い\u0026#34; 5Else 6 MsgBox,\u0026#34;そこそこ\u0026#34; If文による条件分岐は、「等しい、以上・以下、超・未満」のような判定に加えて、指定した文字列が含まれているか、変数のデータ型が特定の型に等しいか、という判定も可能である。\n参考\nスクリプト仕様 - 条件分岐 - AutoHotkey Wiki 設定ファイルの分割 AutoHotKeyの設定は*.ahkファイルに書いていくが、全ての設定を1つのファイルに書く必要はなく、複数の*.ahkファイルに書くことが可能である。設定が増えた際の管理の手間を考えると、アプリ毎の設定ファイル、Windows全体で適用する設定ファイルのように、目的別で分けた方が良いと思う。\n私の場合、IME関係(IME-setting.ahk)、アプリ毎の設定(settings-for-each-app.ahk)、その他の設定(misc-setting.ahk)の3つに分けて管理しており、その3つのファイルをmy_keybind.ahkで以下のとおり読み込んでいる。なお、1行目では各設定で使うIME.ahkを読み込んでいる。ここで読み込むと、それぞれの設定ファイルでは改めて読み込む必要がなくなる。\n1#Include %A_ScriptDir%/IME.ahk 2#Include %A_ScriptDir%/IME-setting.ahk 3#Include %A_ScriptDir%/settings-for-each-app.ahk 4#Include %A_ScriptDir%/misc-setting.ahk 5Return 実際のファイルを確認したい人は、私のGitHubのリポジトリを確認して欲しい。\n参考\n#Include / #IncludeAgain - AutoHotkey Wiki 具体的な設定 AutoHotKeyの各機能を1つ1つ説明すると非常に長くなるし、そもそも「まずホットキーを指定し、そのホットキーに処理を割り当てる」というスタイルで設定していくアプリなので、これ以降は具体的な設定を逐一解説することで、AutoHotKeyの使い方を説明するという流れにする。\nIMEのオン/オフの切り替え 最初は、上記のとおり悪戦苦闘したIMEのオン/オフの切り替えから。\nキーコードの指定でつまずいたが、以下のコードで望み通りの動作を実現することができた。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3Title: 変換/無変換でIMEをオン/オフする 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6SC079::IME_SET(1) 7SC07B:: 8 if IME_GetConverting() \u0026gt;= 1 { 9 Return 10 } 11 else { 12 IME_SET(0) 13 } 14 Return この設定で使用しているIME_SET()関数とIME_GetConverting関数は、前述の「設定ファイルの分割」の1行目（#Include %A_ScriptDir%/IME.ahk）で読み込んだIME.ahkで定義されている。IME周りの制御では必須の関数が定義されているスクリプトファイルなので、IME制御を行うなら必ずダウンロードすることになる。\nスクリプトを解説すると、6行目で\u0026quot;変換\u0026quot;キーをホットキーに、7行目で\u0026quot;無変換\u0026quot;キーをそれぞれホットキーに指定している。\n変換/無変換キーはキーコードを使ってホットキーに指定する必要があるので、上記の設定を行う前にキーコードを調査した。調査画面は次のとおりである。\n調査結果 ここで、変換キーのスキャンコード(SC)が079、無変換キーのスキャンコードが07Bだと分かるので、SC079、SC07Bと指定した。そのうえで、変換キーにIMEオンの機能を割り当てるため、IME.ahkに定義されているIME_SET関数を使用した。IME_SET(1)でIMEをオンに、IME_SET(0)でオフにできる。\n次に、無変換キーにIMEオフの機能を割り当てるが、私のErgoDashでは、無変換キーがスペースキーの隣の親指担当の場所にあるため、スペースキーと間違えて無変換キーを押すことがしばしばあった。そのため、IMEオンで入力しているときは、無変換キーを押してもIMEをオフにしない設定にした。\nそのため、IME_GetConverting関数でIMEの状態を確認し、返り値が1以上（IMEオンで入力中 or 変換中）なら、何もしない（Returnで処理終了）設定にし、それ以外の場合（IMEオンだが入力していない）にIME_SET(0)関数を実行してIMEをオフにする設定にした。\nなお、IME_GetConverting関数でIMEの状態が取得できるのは、インラインで入力が行われないアプリだけである。そのため、WordやNotepadのようにインラインで入力が行われるアプリでは、IMEの状態が取得できないので、入力中はIMEをオフにしないという細かい調節はできない。\n参考\nIME制御 - eamat @Cabinet - アットウィキ 補足 ちなみに、上記で調査した変換/無変換キーのスキャンコードは、市販のJISキーボードでも同じである。しかし、仮想コードはErgoDashと市販のキーボードで異なっている。\nキーの指定は、スキャンコードか仮想コードで行うので、enthumbleは、スキャンコードではなく仮想コードで指定しているか、それともvkXXscYYYという組み合わせで指定しているのではないかと思う。そのため、ErgoDashでは動作しなかったのではないかと思う。\n仮想キーコード 変換 無変換 ErgoDash FF EB 市販品 1C 1D IME関連の他の設定 これで最大の懸念であったIMEの切り替えが実現できたが、変換キーにIMEオンの機能を割り当てたので、本来の変換キーが無くなっている。誤入力した箇所にカーソルを置いて変換キーを押すと再変換できる機能は便利なので、Ctrl-BackSpaceに変換キーの機能を割り当てることにする。\n1BS::Send, {vk1C} BSはBackSpaceの指定（BackspaceでもOK）で、Sendは、引数に指定したキーをシステムに送信するコマンドである。vk1Cは変換キーの仮想キーコードなので、\u0026quot;Ctrl-BackSpace\u0026quot;を押すと変換キーが送信されるという動作になる。\n参考\nSend / SendRaw / SendEvent / SendInput / SendPlay - AutoHotkey Wiki アプリ毎の設定 AutoHotKeyでは、アプリ毎に設定を行うことも可能である。\n次の例は、Excelで行（列）選択のショートカットキーのShift(Ctrl)-SpaceをIMEオンでも動作させるというものである（このショートカットキーはIMEオンだと動かない）。キーボードでExcelを操作するときに必須のショートカットキーなので、IMEオンでも動作するようにする。\n1#ifWinActive ahk_exe EXCEL.EXE 2 $^Space:: 3 if (IME_GET()) 4 { 5 IME_SET(0) 6 Sleep 30 7 Send,^{Space} 8 Sleep 30 9 IME_SET(1) 10 } 11 else 12 { 13 Send,^{Space} 14 } 15 Return 16 17 $+Space:: 18 if (IME_GET()) 19 { 20 IME_SET(0) 21 Sleep 30 22 Send,+{Space} 23 Sleep 30 24 IME_SET(1) 25 } 26 else 27 { 28 Send,+{Space} 29 } 30 Return 31#ifWinActive IME_GET関数やIME_SET関数は、上記のIME関連の設定で説明したとおりIME.ahkで定義されているものである。\n1行目の#ifWinActiveは、特定のウィンドウがアクティブの時だけ実行するというコマンドである。ウィンドウの指定はウィンドウタイトルやウィンドウクラスで行うが、ウィンドウタイトルで行うのが簡単だと思う。\nウィンドウタイトルの確認は、AutoHotKeyに備わっている「Window Spy」という機能を使うのがベストである。Window Spyは、右下のタスクトレイにあるAutoHotKeyのアイコンを右クリックしたメニューにあるので、そこから起動する。起動した後の操作方法は以下のスクリーンショットのとおり。\n2行目の$^Space::は、\u0026quot;Ctrl-Space\u0026quot;というホットキーを指定するものであるが、行頭に$をつけているのは、\u0026quot;Ctrl-Space\u0026quot;をAutoHotKeyで強制的にフックするためである。システムが使うショートカットキーを上書きする場合に必要となる。\n3行目のif (IME_GET())は、IME_GET()の返り値が1、つまりIMEがオンになっているという条件式である。AutoHotKeyは、数値が0ならfalse、それ以外の数値はtrueと処理するので、こういうコードでOKとなる。\n5〜9行目はIMEがオンの場合の処理であるが、まず、5行目のIME_SET(0)でIMEをオフにし、続いて6行目のSleep 30で30ミリ秒処理を中断する。この中断処理を除くとIMEオンの状態で\u0026quot;Ctrl-Space\u0026quot;を入力したのと同じ動作になるので、中断処理を行っている。なお、30ミリ秒より短いと上手くいかない。\nそれから7行目のSend,^{Space}で\u0026quot;Ctrl-Space\u0026quot;を送信し、8行目のSleep 30で再び処理を中断している（この中断処理を省略しても上手く動作しない）。\nそして、9行目のIME_SET(1)でIMEをオンに戻している。\n11行目のelseは、IMEがオフの場合の分岐で、この場合は、単純に13行目のSend,^{Space}で\u0026quot;Ctrl-Space\u0026quot;を送信している。\n17行目の$+Space::は、\u0026quot;Shift-Space\u0026quot;というホットキーを指定するものである。以降の設定はこれまでと同じなので、省略する。\nなお、Excelについては、次のような設定も行なっている。説明の都合上2つに分けているが、実際の設定ファイルでは、#ifWinActiveを除いた部分を上記のコードの続きに書いている。\n1#ifWinActive ahk_exe EXCEL.EXE 2 $F1::Return 3 $+F1::SendInput, {F1} 4#ifWinActive 2行目の$F1::Returnは、\u0026quot;F1\u0026quot;キーを無効化する設定である。以前使っていたキーボードで、F1キーがEscキーの隣にあるためにEscとF1をの押し間違いが頻発していたので、思い切ってF1を無効化したのである。特定のキーを無効化する場合、無効化したいキー::Returnとすることで、そのキーを無効化できる。\nなお、F1キーを無効化したが、ヘルプを見たい時があるかもしれないので、$+F1::SendInput, {F1}で\u0026quot;Shift-F1\u0026quot;に元々のF1を割り当てている。\n参考\nIfWinActive / IfWinNotActive - AutoHotkey Wiki キー２連打への割り当て キー２連打への割り当て方法は２通りあるので、それぞれ紹介する。\n方法１（モディファイヤキーが無い場合） CtrlやAltなどのモディファイヤキーと組み合わせないキーの２連打の場合、AutoHotKeyの組み込み変数を使うことで簡単に２連打の設定ができる。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3Title: テンキーのピリオド2連打でカンマ入力 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6~NumpadDot:: 7 If (A_PriorHotKey == A_ThisHotKey and A_TimeSincePriorHotkey \u0026lt; 200) 8 { 9 SendInput, {BackSpace 2} 10 Send,{U+002c} 11 } 12Return 上記のコードを解説すると、まず、~NumpadDot::でテンキーの\u0026quot;.\u0026quot;をホットキーに指定している。行頭に~を追加しているので、\u0026quot;.\u0026quot;の入力はシステムにも渡されて\u0026quot;.\u0026quot;が入力される。\nそして、7行目のIf (A_PriorHotKey == A_ThisHotKey and A_TimeSincePriorHotkey \u0026lt; 200)は、組み込み変数を使って、「前回入力されたホットキーと今回のホットキーが同じ」かつ「前回のホットキー入力から今回のホットキー入力までの時間が200ミリ秒未満」という条件文を組み立てている。\nA_PriorHotKey変数には前回押されたホットキー、A_ThisHotKey変数には今回押されたホットキーが格納されているので、2つの変数が等しければ同じホットキーを2回連続で入力したと判断できる。そして、A_TimeSincePriorHotkey変数には、前回のホットキー入力から今回のホットキー入力までの時間がミリ秒単位で格納されているので、この変数の値が200未満なら２連打したと判断している。\nつまり、最初の\u0026quot;.\u0026quot;入力では、7行目のIf文の条件が必ず満たされず最後のReturnコマンドに直行し、2回目の\u0026quot;.\u0026quot;入力で7行目のIf分の条件が満たされて、次のSend~の処理に移るという訳である。\nそして、この段階までに2回入力されている\u0026quot;.\u0026quot;を削除するため、SendInput, {BackSpace 2}コマンドでBackSpaceを2回入力している。それからSend,{U+002c}コマンドで\u0026quot;,\u0026quot;を入力している。なお、{U+002c}は、\u0026quot;,\u0026quot;のUnicodeの文字コードである。わざわざUnicodeの文字コードで指定している理由は、Send,{,}だとIMEがオンの場合に全角の\u0026quot;、\u0026quot;が入力されてしまうためである。\n参考\n組み込み変数 - AutoHotkey Wiki If (式) Unicode文字一覧表 - instant tools 方法２（モディファイヤキーがある場合） CtrlやAltなどのモディファイヤキーと組み合わせたキーの２連打の場合、上記より面倒になる。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3Title: Alt-Qの2連打でアプリを閉じる 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6~!q:: 7 Input, inputText, I L1 T0.5, !q 8 IfInString, ErrorLevel, EndKey: 9 { 10 Send, !{F4} 11 } 12Return 最初に掲載した設定例の再掲であるが、解説すると、まず~!q::で\u0026quot;Alt-Q\u0026quot;をホットキーに指定している。\nそして、Inputコマンドで最初の\u0026quot;Alt-Q\u0026quot;に続くキー入力を横取りして、inputText変数に格納している。\nInputコマンドのI L1 T0.5という引数は、「AutoHotKeyが生成したキー入力は無視、入力を受け付けるキーの長さは1文字、キー入力を待つ時間は0.5秒以内」という条件を指定するもので、!qという引数は、「\u0026quot;Alt-Q\u0026quot;が入力されたらコマンドを終了して次の行に進む」という条件を指定するものである。\nその次のIfInString, ErrorLevel, EndKey:は、「ErrorLevel変数にEndKey:という文字列が含まれているか」という条件文である。\nInputコマンドの待ち時間（0.5秒）以内に\u0026quot;Alt-Q\u0026quot;が押されたら、ErrorLevel変数にEndKey:!{q}という値が格納され、0.5秒以内に\u0026quot;Alt-Q\u0026quot;が押されない場合はTimeoutという値が格納されるので、EndKey:が含まれていれば「Alt-Qが２連打された」と判断できる。\nそのうえで、Send,!{F4}で\u0026quot;Alt-F4\u0026quot;キーを送信してアプリを終了させている。\n参考\nInput - AutoHotkey Wiki IfInString - AutoHotkey Wiki クリップボードを活用 クリップボードを活用することで、選択した文字列を\u0026quot;(\u0026quot;や\u0026quot;[\u0026quot;や\u0026quot;#\u0026quot;で囲むということも可能になる。なお、このコードだけ Gist から引っ張っている理由は、コードの「Send,{{}」の {{} が Hugo のビルド時に文法エラー扱いされてビルドが中断されるのを避けるため。\n8行目のbackup = ClipboardAllは、その時点でクリップボードに格納されているデータをbackup変数に退避させる処理である。ClipboardAll変数は組み込み変数で、クリップボードのデータを読み取る際に使用する。\n9行目のClipboard =は、クリップボードを空にする処理である。Clipboard変数も組み込み変数で、クリップボードの中身を書き換える際に使用する。\n10行目のSend, ^cで、\u0026quot;Ctrl-C\u0026quot;をシステムに送信して選択中の文字列をコピーするが、コピー失敗に備えて、11行目にClipWait, 1という処理を挟んでいる。ClipWaitコマンドは、引数で指定した秒数の間待機し、時間内にコピーが成功すればその時点でErrorLevel変数に0を格納する。そのため、ErrorLevel変数の値でコピーが成功したか否かが確認できるようになる。\n12行目はIME_GET()関数で現在のIMEの状態を変数に格納している。この処理はSendコマンドで囲み文字を入力する方法なので、囲み文字を確実に半角入力するため、一度IMEをオフにする必要がある。そのため、処理実行前のIMEの状態を取得している。なお、関数の戻り値を変数に格納する際は:=で代入する必要がある。\n15行目のInput, inputText, I L1 T1,{Esc}, (,[,\\`{,',\u0026quot;,`,-,_,=,`%,`#,`*, ,|は、前述のInputコマンドを使って、\u0026quot;Ctrl-,\u0026quot;の次に入力された文字が( [ { ` - _ = % # | 半角スペースだった場合に、その文字をinputText変数に格納している。なお、{ ` # % *はAutoHotKeyで特別な意味のある文字であることから、これらの文字を指定する際は`でエスケープ処理する必要があり、また、半角スペースは条件式の途中（この例では|の前）に書かないと認識されないという2点に注意が必要である。\n16行目のIf ErrorLevel = Matchは、Inputコマンドで(,[,\\`{,',\u0026quot;,`,-,_,=,`%,`#,`*, ,|が入力されていればErrorLevel変数にMatchが格納されているので、それを分岐条件にしている。\nあとは、18行目のIME_SET(0)でIMEをオフにして、入力された文字に応じた分岐を18行目以降のIf inputText =で行い、\n入力された文字をSendコマンドで送信 Send,^vコマンドでクリップボードの文字を貼り付け 再び入力された文字をSendコマンドで送信 という処理を行うことで、選択した文字列を指定した文字で囲むという動作を実現している。\n工夫が必要な点は、まず、(,[,\\`{は、対になる),],\\`}とセットで囲む必要があることから、この3つのカッコは個別に分岐条件を設定している。そのほかの囲み文字については、同じ文字を2回入力すればOKである。\nまた、半角スペースはIf inputText = \u0026quot; \u0026quot;のような条件判定がどうやってもできなかったので、指定した変数のデータ型で判断するif inputText is typeを使って、inputTextが半角スペース（タブもOK）か否かによる条件判定を行なった。\nそのほか、なぜか#は個別に条件判定を行う必要があったので、やむなく個別に判定している。\nそれ以外の囲み文字については、まとめて最後のElse節で処理している。\n最後に、IMEの状態を処理前に戻して動作完了である。\n参考\nIf var is [not] type - AutoHotkey Wiki 設定ファイルの再読み込みを簡単に 設定ファイルを編集した場合、右下のタスクトレイにあるAutoHotKeyのアイコンを右クリックして「Reload This Script」をクリックする必要があるが、非常に面倒な作業なので、設定ファイル再読み込みのショートカットキーを作成する。\n1/* 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 3Title: Ctrl-Alt-Rでこのスクリプトを再読み込みする 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 5*/ 6^!r::Reload 最初の方で紹介した設定例の再掲であるが、^!rで\u0026quot;Ctrl-Alt-R\u0026quot;をホットキーとして指定し、現在実行中の設定ファイルの再読み込みを行うReloadコマンドを割り当てている。\n参考\nReload - AutoHotkey Wiki ","link":"http://localhost:1313/post/2019-06-18/","section":"post","tags":["プログラミング","備忘録"],"title":"AutoHotKeyの解説と自分の設定について"},{"body":"","link":"http://localhost:1313/tags/mac/","section":"tags","tags":null,"title":"Mac"},{"body":"前置き メルカリで売りに出ていた「Macbook pro, 2011Early, 15インチ」を購入して、さらにメモリを16GBに増強して快適な環境を構築しようとしたら、メモリ交換後に電源ボタンを押しても反応がないというまさかの事態に陥ってしまった。何とか蘇らせることができてこの記事を書けるまでになったので、同じ症状に遭遇した人のために、顛末を書いてみたいと思う。\n経緯（購入まで） それまで使用していたMacbook pro(2015, 13インチ)は、持ち歩きも考慮して13インチにしたものの、据え置きで使うことが多く、また、据え置きで使うべく外付けディスプレイやキーボードを接続しているので、外に持ち出す都度、ケーブル類や電源の着脱が手間になっていた。\nそこで、もし、安価な15インチのMacbook proがあればそれを据え置き機にして、既存の13インチは持ち歩き専用にしようと思い立ち、メルカリで探したらちょうど良い商品があったので、Amazonで16GBのメモリを購入するのと合わせて、早速購入した。\n経緯（商品到着からメモリ交換実施まで） メルカリで購入したMacとAmazonで購入したメモリが同時に届いたので、まずはMacの起動確認を行い、ちゃんと起動することを確認したら、出品者を評価してからMacの電源を落とした（後述するが、多分この時に、間違えて電源オフではなくスリープにした可能性がある。） それから、以下のページを参考にしてメモリを交換して、上手くいったか確認するために電源ボタンを押した。 MacBook Pro：メモリの取り外し方法と取り付け方法 - Apple サポート\n・・・全く反応がない。。。\n一体何が起きたか分からなかったが、交換したメモリに不具合があるかと思い、元から取り付けられていたメモリに戻して電源ボタンを押す。\n・・・さっきと同じように全く反応がない。。。\nここまで来て事態の深刻さに気付き、対処策を探すことになる。\n経緯（試行錯誤の過程） まずはネットで同様の症状に遭遇した人がいないか検討するが、電源が入らなくなった時の対処方法は見つかるものの、メモリ交換で電源が入らなくなった事例は見つからなかった。\n仕方なく、NVRAMのリセットやSMCのリセットを試すものの、全く事態は改善されない。\n最初のトラブルの時にNVRAMリセットを行っても復旧しなかったが、３時間後にリセットしたら復旧したという記事も見つけたので、２時間ほど経ってからリセットしてみるが、反応が無い状態は全く変わらない。\n対象方法を探す中で地元の修理ショップの存在を発見するが、ロジックボードの修理費が３〜６万円とあるのを見て、これだけ出すなら諦めた方が安上がりかなという考えも浮かんでくる。\nまた、この辺りになると、最初の起動確認をした後、いつもの癖で電源オフではなくスリープを選んでしまい、その状態でメモリ交換をしてしまったのではないかという嫌な予感がして来てしまい、さらに気が滅入ることになる。\nとはいえ、あれこれ作業をしていると夜遅くになってしまったので、仕方なくその日はそれ以上の作業を諦めて寝ることにした。\n経緯（復旧まで） 次の日は朝から用事があったため、夕方に帰って来てから作業に取り掛かった。\n昨日、スリープ状態でメモリ交換をしてしまった可能性を考えていたので、一度完全に電源オフにした上で、あらためてNVRAMリセットとかしたら復旧するのはないかと思い、バッテリーを取り外すことにした。 以下のページを見ながらバッテリーを取り外し、その状態で一度電源ボタンを押して内部の電気を完全に放出したうえで、２時間ほど待つことにした。 MacBook Pro 15\u0026quot; Unibody Early 2011 Battery Replacement\n２時間待ったところで、バッテリーを取り付けて電源ボタンを押したところ、DVDドライブへのアクセス音が聞こえてMacの起動音が鳴り、少ししてからMacが無事に起動した。この時は本当にホッとしたのを覚えている。\nMacが無事に起動するのを確認したが、内部時計がおかしくなっていたのと、一度リセットした方が良いと判断して、あらためて電源オフにしてから、NVRAMリセットを行ったところ、内部時計もちゃんとした日時になった。動作にも問題がないので、\nSMCリセット OSをOS X LionからHigh Sierraにアップグレード 外付けHDDにバックアップしたTimeMachineのデータを使用して環境を移行 の作業を行い、こうしてブログ記事を書けるまでの環境構築に成功した。\nまとめ トラブルの原因は、起動確認後に間違えて電源オフではなくスリープを選んでしまっていて、それに気づかないままメモリ交換に着手してしまったことではないかと思う。OSのアップデートでもない限り、電源オフではなくスリープを選んでいるので、その癖でスリープを選んでいたのではないかと思う。\n電源ボタンを押しても反応が無い時はNVRAMのリセットもできないので、こういう時はダメ元でバッテリーを外して完全に電源オフにし、その状態をしばらく続けた後にリセットすると直るかもしれない。 この記事が誰かの役に立てば幸いである。\n蛇足 元々使っていたMacbook proの環境を移行するため、外付けHDDにTimeMachineでデータをバックアップして移行したが、アプリやデータに加えて各アプリの設定まで自動的に移行されるのには驚いた。新しいMacで行う必要があった作業は、Homebrewを使うためにXcodeをインストールすることだけで、Karabiner-Elementsの設定も1Passwordの設定もそのまま移行されたので、環境移行は拍子抜けするほど簡単だった。\nただ、買った直後のOSがOS X Lionだったが、このOSには２ファクタ認証の機能がないので、iCloudの設定などでIDとパスワードを入力しても、確認コードを入力する画面が表示されず随分と困った。\nこの問題には、パスワードの後に確認コード６桁を入力すれば対処できる。具体的には、まず、IDとパスワードを一度入力し、手持ちのiPhoneなどに確認コードが表示されたら、再度IDとパスワードを入力し、そのパスワードの後ろに確認コード６桁を入力すれば認証される。 Mac OSでApple IDの確認コード画面が表示されない場合の対応方法 | 好きな音楽をいい音で\n","link":"http://localhost:1313/post/2018-03-22/","section":"post","tags":["Mac","備忘録"],"title":"Macbook proでメモリ交換して電源が入らなくなってから復活するまでの経緯"},{"body":" 日本軍兵士―アジア・太平洋戦争の現実 (中公新書) 太平洋戦争において、日本軍が補給をおろそかにしたことで前線の兵士が塗炭の苦しみを味わったことは周知の事実であるが、その苦しみがどれほどのものであったかを克明に記したのが本書である。\n膨大な戦病死と餓死や、劣悪極まりない輸送船の悲劇などは他の書籍でも描かれているが、本書は大量の資料――日本軍と戦った米軍側の資料も含めて――を駆使してそうした事実を「兵士の目線」で「兵士の立ち位置」から捉えなおし、その悲惨な現実を描き出すとともに、日本軍の実情が貧弱なものであったことも描き出している。\n兵士を戦場に送り込むために用意した輸送船は奴隷船のような船であり、攻撃を受ければ瞬く間に沈没して多数の兵士が海没死し、攻撃を受けなくても船倉の異常な温度と湿度の上昇で中枢神経障害を起こして死亡する。\nそうやって送り込まむ兵士の質も、日中戦争の全面戦争化に伴う大量動員の必要から、\n身体または精神にわずかな異常があっても、軍陣医学上」、軍務に支障なしと判断できる者は、「できるだけ徴集の栄誉に浴し得るよう、身体検査の条件を全般的に緩和した (p.86)\n条件で集められた兵士であり、体格や体力の劣る兵士、病弱な兵士が増加していくこととなった。さらに、軍服は地の厚い毛織物から綿製になって洗濯のたびに生地が傷む代物になり、軍靴も素材が牛革から馬革や豚革に、さらには鮫皮にまで劣化し、補強用の釘や鋲まで減らされたことで耐久性がなくなり、前線では靴を履けない兵士が多数存在していた。飯盒さえ、金属製から孟宗竹製になっていった。戦国時代の足軽よりひどい装備ではないかと思うが、太平洋戦争の戦地は日本と環境が大きく異なる東南アジアや中国であり、装備品の劣悪化によるダメージはより深刻になっていたはずである。\n前線に到着した兵士も、上記のような劣悪な装備で補給なき戦いを強いられ、餓死する者、マラリヤなどの病気で死亡する者が続出し、さらには自分の身体を傷付けて戦場を離脱する者がでてくるまでに追い詰められていった。\n視点をマクロ的な面に移しても、当時の日本は後発の近代国家であり、機械化が遅れ労働生産性は低く、工場では多数の熟練労働者を現場に確保する必要があり、農村でも大量の農業従事者を確保する必要があった。このため、兵力と労働力の競合関係が深刻で、大規模な徴兵を行うと労働力が不足してしまうことになった。この「後発の近代国家」という弱点については経理から見た日本陸軍 (文春新書 1312) | 本間 正人 |本 | 通販 | Amazonでも触れられているが、同じ部品でも工場が違うとはまらないといった不具合が出るのは当たり前で、物資については輸送だけでなく生産についても大問題を抱えていた。\nこの状況では軍隊の機械化も進むはずもなく、日本軍はトラックの不足を歩兵の背負う荷物を増やすことで、土木機械の不足を『つるはし・もっこ・ローラー』で対応しようとした。そして、通信機器は米軍から10年遅れており、中国戦線の歩兵第二三二連隊第二大隊に配属された小柴無線分隊の「装備」は、無線機１台と伝書鳩５羽（！）であった。もはや、どこを見ても日米の軍事力の差は絶望的であり、日本軍が米軍を苦しめたとはいっても、それは前線の兵士の超人的な努力に頼ったものであり、兵士の塗炭の苦しみを一層際立たせるものでしかない。\n太平洋戦争の意味をどのように捉えるにせよ、本書が示す戦場の現実は、太平洋戦争は勝てる戦争でもなければ、まともに戦える戦争でもなかったことを示している。それは、後発の近代国家である日本が戦うにはあまりにも無謀な戦いであり、また、中国を簡単に屈服させられると思い込んで日中戦争を泥沼化させ、その挙句に日米戦争に向かわざるを得なくなった戦前日本の政治的・戦略的ミスの悲惨な総決算となってしまった戦争であった。\n","link":"http://localhost:1313/post/2018-02-12/","section":"post","tags":["太平洋戦争","読書記録","読書記録"],"title":"【読書記録】日本軍兵士――アジア・太平洋戦争の現実"},{"body":"","link":"http://localhost:1313/tags/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E6%88%A6%E4%BA%89/","section":"tags","tags":null,"title":"太平洋戦争"},{"body":"","link":"http://localhost:1313/tags/%E8%AA%AD%E6%9B%B8%E8%A8%98%E9%8C%B2/","section":"tags","tags":null,"title":"読書記録"},{"body":" 日米開戦と情報戦 (講談社現代新書) 本の概要 日米戦争の開戦決定過程を、インテリジェンスの問題も視野に入れて再検討する著作である。著者は、南部仏印進駐（1941年7月末）以降、日米開戦に到るまでの決定過程については『日本はなぜ開戦に踏み切ったか』（新潮社、2012年）で道筋を説明していたが、同書では南部仏印進駐に至った経緯や、英米の動向については最小限にとどめていたことから、本書でそうした点を補うとともに、政策決定に密接に関わるインテリジェンスの問題も取り上げている。\n本書が対象とする期間は、1940年7月から1941年12月の真珠湾攻撃の直前までの期間であり、日米双方がどのような情報を基にし、その情報をどのように評価しながら政策を決定したのかという過程を描き出している。それはまた、情報の入手方法と評価軸を巡る問題を描き出すものでもある。\n感想 敵国の暗号を解読すれば機密の通信を読むことができる。しかし、暗号文を平文に戻せたからといって、その平文を\u0026quot;きちんと\u0026quot;読むことができるとは限らない。\n開戦前の日本と英米は、相手国の暗号を解読して平文に戻すことに成功していた。そして、解読した情報は最高機密情報として管理し、政策立案者が首相や大統領が直接目を通していた。日英米の過ちは、解読情報を読み解くという仕事を、情報の専門家ではなく、政策立案者や首脳が行なってしまったことであった。彼らには、得られた機密通信の行間や文脈を読み取る力量は欠けており、また、自らに都合の良い情報ばかり集める傾向にも無自覚であった。\nさらに、日本の暗号の解読文は、漢字を含まない音だけで構成された文章であった。例えば、「御前会議」を暗号化して送信して英米が解読した場合、得られる情報は「GOZENKAIGI」という日本語の音だけであった。これを日本語に翻訳する際、通訳の力量によっては「GOZENKAIGI」を「午前会議」と訳すこともあった。これはマシな方で、中には悪意を持って翻訳したとしか思えない翻訳もあり、それはアメリカ側の対日不信感を増幅させることとなった。一方、日本側にはそうした問題は原理的に起こり得ないため、得られた平文をそのまま日本語に訳せば良いという有利な立場であったにも関わらず、そもそも暗号文を読んでいた陸海軍の首脳部がアメリカについて無知であったため、自らの行動がアメリカにどう解釈されるのかという点を見誤ることとなった。\nしかし、機密の通信を読むことができているという事実は、アメリカに「自分たちは日本の出方を知悉している」と思い込ませることとなった。日米は、お互いに機密通信を読んでいたが故に、相手からのメッセージについて、双方でコミュニケーションを重ねてその意図を探るという行為を軽んじることとなり、それが結果的に深刻なコミュニケーションギャップを生むことになった。\nここで非常に示唆的なのは、そうした暗号解読情報に接することはできないが、相手国のことは熟知している外交官——幣原やグルー駐日大使——は、公開情報と相手国に対する深い理解を根拠として、相手の出方を正確に予測できていたことである。そこから得られる教訓は、たとえ苦労の末に解読した暗号文であったとしても、その情報は単なるインフォメーションであって、インテリジェンスでは無いということ。そして、そうした情報を慎重かつ正確に評価できる専門家に評価を依頼し、その意見を尊重する文化がなければ、たとえ軍や政府の首脳であっても、情報の評価を誤ってしまうということであろう。\nその結果は、日本は無条件降伏をして明治維新以降の成果のほとんど失い、英国は勝利したが、植民地を失い大英帝国の栄光を完全に失うこととなった。アメリカも勝ったとはいえ、日米間の原則的対立の中心だった中国は、アメリカの巨大市場となることはなく、竹のカーテンの向こうへ消えていってしまった。日本との戦いに投じた労力に見合う成果を得られたのかは疑問であった。\nこうしたことを踏まえ、著者は最後に日英米の情報戦の結果を次のようにまとめている。\n戦争では、どの国も過誤を犯す。そして、より少なく過誤を侵した国が勝利を収める。情報戦でも、日英米何れもが過誤を犯した。その結果が、あの戦争だった。最も少ないコストで目的を達成するという観点からすれば、日英米いずれも開戦前の情報戦に敗れたのである。\n","link":"http://localhost:1313/post/2017-11-27/","section":"post","tags":["読書","読書記録"],"title":"【読書記録】日米開戦と情報戦"},{"body":"","link":"http://localhost:1313/tags/%E8%AA%AD%E6%9B%B8/","section":"tags","tags":null,"title":"読書"},{"body":" 忘れられた日本の村 本の概要 著者の筒井功氏は、元共同通信社の記者で、正史に登場しない非定住民の生態や民俗の調査・取材を行っている。\n本書を一言で紹介するのは難しく、著者も本書を「エッセイとも旅行記ともつかない妙な内容の著述」と後書きに記している。学術書ではないが、風景の美しさや旅情とやらを紹介する旅行記でもないし、旅の感想を述べるエッセイでもない。著者が、民俗学や歴史の研究成果を踏まえ、実地調査も行い、そこから得られた知見をまとめた書物、というのが本書の簡単な紹介になるかと思う。\n現在の町や村が見かけは似ていてたしても、少し古い時代に遡れば、様々な歴史を辿ったために豊かな個性を持つ町村は多数存在していた。例えば、全戸が狩猟を生業にしていた、芸能を演ずることで生活を支えていた、無籍の漂白民が集住して一村をなした、など非常に個性豊かな町村が多数存在していたのである。そうした個性は、通りすがりに一瞥しただけでは気付くことのないが、文献を紐解き、現地を訪れ、人々に話を聞くことで見えてくるものであり、そうして見えたものを文章にしてみたいという著者の思いから本書は生まれている。\n本書で紹介されている村は、南は大分県から北は秋田県まで7つあり、それらの村が辿った歴史に触れることは、日本が辿った歴史の一端を垣間見ることでもある。\n感想 特に個性的な村を選んだはずなので、出てくる村の歴史はどれも面白いものばかりである。歴史学者の網野義彦氏は「日本の東西間の違いは、日本と外国の違いより大きいのではないかと思う」と述べていたが、本章に登場する村々を見ていると、日本には豊かな歴史があるという思いが非常に強くなる。\nただ、その豊かな歴史は、歴史教科書に掲載される大事件ではなく、歴史教科書に登場しない人々の日々の営みが積み重なってできたものであり、どうしてもその歴史を確認したいと強く願う人が探さなければ見つからない。この本を読むと、そうした歴史の痕跡を探そうと、古い地名、地元の祭り、はたまた地元民の良く知る場所についてもっと知りたいと思うようになってくる。戦後の高度経済成長で山間部から都会へ人が大量に移動し、昔のことを知る人がどんどん減っていることを踏まえると、そうした歴史を掘り起こすことが出来る時間も、そんなに残されていないと思う。だからこそ、そうした歴史を掘り起こすことは大切なことだと思う。\n特に印象に残った部分 どれも印象に残るが、一つ挙げるとすれば、本書第六章に登場する徳島県美馬市穴吹の三ツ木が一番印象に残る。四国の徳島県美馬市木屋平字三ツ木という山奥に三木家（場所は下の地図参照）という家がある。その住宅は母屋の平屋だけで建坪200平方メートル余り、茅葺きの江戸時代初期の建築であり、1976年に国の重要文化財に指定されている。とはいえ、本章の主題はこの建物についてではなく、この三木家が果たしてきた役割である。\n三木家は、天皇が大嘗祭（天皇が即位後初めて行う新嘗祭のこと。詳細は脚注のリンクを参照1）を行う際に着用する麁布（読みは「あらたえ」。麻布で作った服。）を貢納する家であり、貢納が始まった時期は、伝承では古代から、文献で確認できるところでは文保2年（1318年）からである。この麁布の貢納の話を紹介し、そこから三木家を含めた村の歴史を、平安時代の京都の動きと絡めながら現代まで描き出していく。それは、三木家が古代の阿波忌部氏にまで遡るという話から始まり、後醍醐天皇即位の際の大嘗祭に麁布を献上し、その繋がりで南朝側に立って戦ったこと、百姓身分でありながら苗字帯刀が許されていた江戸時代の状況、そして、地区の発展や村の歴史書の執筆に尽力した明治・大正までの歴史であり、村が辿った歴史を描くことでもある。\nこの本を読むまで、天皇が執り行う神事で使う物は、宮内庁で作るか皇室御用達の店から購入しているのかと思っていて、四国の山奥にある一つの家が貢納しているとは夢にも思っていなかった。見方を変えれば、今は途絶えているとしても、昔は三木家と同様に天皇家に何らかの品を貢納していた家が存在していたのではないだろうか。もし、そうした家の歴史を振り返ることが出来たなら、多彩な歴史を有する村が日本には多数あったことが裏付けられると思う。\n宮内庁公表資料：皇位の継承に係わる儀式等（大嘗祭を中心に）について \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","link":"http://localhost:1313/post/2017-11-26/","section":"post","tags":["読書記録","読書記録"],"title":"【読書記録】忘れられた日本の村"},{"body":"","link":"http://localhost:1313/tags/karabiner-elements/","section":"tags","tags":null,"title":"Karabiner-Elements"},{"body":"Karabiner-Elementsとは Karabiner-Elementsは、Macのキーボードカスタマイズアプリで、設定ファイルを自分で記述することで以下のような機能を実現できます。\n\u0026quot;control-H\u0026quot;のようなキー入力を\u0026quot;Command-A\u0026quot;の入力に変換 \u0026quot;Escape\u0026quot;を１回入力したら\u0026quot;Escape, 英数, Escape\u0026quot;のようなキー入力を実現する \u0026quot;control-2\u0026quot;のようなキー入力に\u0026quot;open -a 'safari'\u0026quot;のようなシェルコマンドの実行を割り当てる \u0026quot;スペースバー\u0026quot;を押している間だけ、\u0026quot;H, J, K, L\u0026quot;をカーソルキーに変換する \u0026quot;control-x control-c\u0026quot;のようなキー入力を\u0026quot;command-Q\u0026quot;の入力に変換したり、シェルコマンドの実行を割り当てる。 左右のコマンドキーを押すとIMEをオン・オフできるようにする 同じキーボードカスタマイズアプリで、同じ開発者が開発していたKarabinerがmacOS Sierraで使用できなくなったため、後継アプリとして開発されています。ちなみに、KarabinerはKeyRemap4MacBookと呼ばれていたアプリです。 アプリの配布場所：Karabiner-Elements\nKarabiner-Elementsを使って実現した機能（主なもの） Karabiner-Elementsを使うと様々な機能を実現することが可能で、コピーなどの各種操作をWindowsと同じにしたり、キーボードの配列をQWERTYからDVORAKに変更するカスタマイズまでしている人もいるようです。そこまでいかなくても、以下のページを見ると、たくさんのユーザーが実に様々な設定を行なっていることが分かります。 Karabiner-Elements complex_modifications rules 私が行っている設定のうち、主なものは以下のとおりです。\nIMEの切り替え方法の改善 全角/半角キーでIMEを切り替え 変換/かなキーでIMEオン 無変換キーでIMEオフ ブラウザ（Safari, Chrome, Firefox）やターミナルのタブの移動をctrl-pageup(down)で行えるように設定 Windowsと同様の動作を実現 F5キーでブラウザの更新を行う Shift-F10やアプリケーションキーに右クリックを割り当て PrintScreenで画面全体のスクリーンショット撮影 Option-PrintScreenで指定したウィンドウのスクリーンショットを撮影 Finderでファイル(フォルダ)を選択してDeleteを押すとファイルをゴミ箱へ移動 Command-EでFinderを開く Control-EscapeでLaunchPad表示（スタートメニュー表示の代わり） Windowsのキーボードユーティリティーソフトのenthumbleと同様の操作を実現 無変換/英数 + I, J, K, L -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + A, S, W, D -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + B, N, P, F -\u0026gt; 矢印キー（←, ↓, ↑, →） 無変換/英数 + H, J, K, L -\u0026gt; 矢印キー（←, ↓, ↑, →）※この組み合わせを使用中 無変換/英数 + Space/かな -\u0026gt; Enter/Escape 無変換/英数 + N, M -\u0026gt; BackSpace 無変換/英数 + ',' '.' -\u0026gt; Delete 無変換/英数 + Y, U -\u0026gt; BackSpace 無変換/英数 + I, O -\u0026gt; Delete 無変換/英数 + 矢印キー（←, ↓, ↑, →）で「←, ↓, ↑, →」を入力 Windowsのキーボードユーティリティーソフトの秀Capsの「テンキーのピリオド２連打でコンマ入力」を実現 上記の他にも設定している項目はあります。設定ファイルは、GitHubで管理していますので、適宜開いて見てください。また、Karabiner-Elementsには、設定ファイルを自分で書かなくても、他の人の設定をインポートして使用可能にする機能があります。上記の設定を紹介しているページからも設定をインポートできますし、私の設定であれば、以下のリンクからインポートできます。 設定ファイル（JSONファイル）：KE-complex_modifications Karabiner-Elementsに読み込ませる設定ファイルは、docs/json/ディレクトリにあります。 設定のインポートページ：Karabiner-Elements complex_modifications rules by s-show\n設定で工夫した点 Emacsの２ストロークキーや、一つのキーを押している間だけキーの変換を行いたい場合、Karabiner-Elementsには専用の設定がありません。そのため、キーを押しているか否かをアプリで判断するため、変数を使ってフラグを立てて判断したり、トリガーとなるキーを\u0026quot;fn\u0026quot;キーに一時的に変換し、\u0026quot;fn\u0026quot;と合わせて押した場合のみ変換を行う、などのテクニックが必要となります。\nEmacsの２ストロークキーの設定は、最初は非常に面倒な作業でした。割り当てたいキーを指定するだけなら簡単でしたが、キー入力を間違えた時に備えたエラー処理を全てのキーについて行う必要があり、設定を記述したJSONファイルが17,000行以上になったこともありました。その後、Karabiner-Elementsに新しい機能が追加され、その機能を利用したら設定ファイルが220行程度まで縮小できました。また、一つのキーを押している間だけキーの変換を行うという設定については、当初は変数を使ってフラグを立てる方法で実装していましたが、GitHubにある設定例を見て、トリガーとなるキーを一時的に\u0026quot;fn\u0026quot;キーに変換し、\u0026quot;fn\u0026quot;と合わせて押した場合のみキーの変換を行うという設定方法を知ってから、変数をチェックする処理や変数の初期化処理が不要となり、設定がシンプルに行えるようになりました。さらに、先日、開発者がリファレンスを作成してくれましたが、このリファレンスに掲載されていた例を参考にすることで、「テンキーのピリオド２連打でコンマ入力」を実現する方法が思いついたりもしました。\nあと、Karabiner-Elementsはキー変換とコマンド実行の機能しかないため、enthumbleの「\u0026quot;無変換/英数 ＋ カーソルキー\u0026quot; で \u0026quot;←↑↓→\u0026quot;を入力」という機能を実現するのには試行錯誤しました。最初は、\u0026quot;shell_command\u0026quot;: \u0026quot;echo '←' | pbcopy | pbpaste\u0026quot;で上手くいくかと思いましたが、よく考えると、pbcopyもpbpasteも標準入出力が対象になっているので、それ以外の場面で動くことはないことに気付きました。\n次に、\u0026quot;←\u0026quot;を一旦クリップボードにコピーして、それをペーストすれば文字入力と同じ結果が得られると考えて、以下の方法を試しました。しかし、クリップボードに\u0026quot;←\u0026quot;をコピーするところまではできましたが、クリップボードへのコピーより先に\u0026quot;command-v\u0026quot;が実行されてしまいました。\n1{ \u0026#34;shell_command\u0026#34;: \u0026#34;osascript -e \u0026#39;set the clipboard to \\\u0026#34;←\\\u0026#34;\u0026#39;\u0026#34; }, 2{ 3 \u0026#34;key_code\u0026#34;: \u0026#34;v\u0026#34;, 4 \u0026#34;modifiers\u0026#34;: [\u0026#34;option\u0026#34;] 5} どうも、AppleScriptの動作が遅いことが原因で、\u0026quot;osascript -e 'set the clipboard to \\\u0026quot;←\\\u0026quot;'\u0026quot;の処理が終わる前に\u0026quot;command-V\u0026quot;の処理が行われたようでした。\u0026quot;osascript ~~~\u0026quot;の処理が終わるまで\u0026quot;command-V\u0026quot;を実行しないという処理を実現する方法は全く分かりませんでしたので、\u0026quot;←\u0026quot;のクリップボードへのコピーもペーストもAppleScriptで行うように設定したところ、動作は遅いものの、狙い通りの機能が実装できました。\n1{ \u0026#34;shell_command\u0026#34;: \u0026#34;osascript -e \u0026#39;set the clipboard to \\\u0026#34;←\\\u0026#34;\u0026#39;\u0026#34; }, 2{ \u0026#34;shell_command\u0026#34;: \u0026#34;osascript -e \u0026#39;tell application \\\u0026#34;System Events\\\u0026#34; to keystroke \\\u0026#34;v\\\u0026#34; using command down\u0026#39;\u0026#34; } カスタマイズの効果 自分が欲しい機能を順次実装しているので、Macの操作は随分と楽になっています。特に、Windowsでは可能なのにMacでは不可能な操作（全角/半角キーでのIME切り替えなど）が可能になり、２つのOSを使う際に戸惑うことが少なくなりました。\n今ではむしろ、\u0026quot;ctrl-h/d → Backspace/Delete\u0026quot;のように、Macでは可能だがWindowsではカスタマイズしないと実現できないキー操作を実現する方法が欲しくなっています。\nまた、「全角/半角キーでIMEを切り替え」や「Controlキー連打で特定の処理実行」といったカスタマイズは、Macのシステム環境での設定とKarabiner-Elementsを組み合わせたり、BetterTouchToolを使って実現したりしていましたが、そうした設定を全てKarabiner-Elementsだけで可能となり、設定の管理も非常に楽になりました。\n本記事の補足情報 QiitaでKarabiner-Elementsの設定項目の解説や設定例を掲載していますので、よろしければそちらも見てください。\nKarabiner-Elementsの各設定項目の内容について Karabiner-Elementの設定例について - Qiita Karabiner-Elementsを使ってJISキーボードの\u0026quot;全角/半角\u0026quot;でIMEを切り替える方法 - Qiita Karabiner-Elementsの設定項目が増えてEmacsライクな設定が楽になった - Qiita Karabiner-Elementsでenthumble(Windows App)のような操作を実現する方法 - Qiita Karabiner-Elementsを使ってキーの２連打に処理を割り当てる方法 - Qiita KE-complex_modificationsを使ってKarabiner-Elementsの設定を楽にする方法 - Qiita ","link":"http://localhost:1313/post/2017-11-25/","section":"post","tags":["Karabiner-Elements","Mac","プログラミング"],"title":"Karabiner-Elementsを使ってMacのキーボード操作を快適にする方法"}]